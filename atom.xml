<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Koufuchi&#39;s blog</title>
  
  
  <link href="https://koufuchi.github.io/atom.xml" rel="self"/>
  
  <link href="https://koufuchi.github.io/"/>
  <updated>2023-09-01T09:40:00.337Z</updated>
  <id>https://koufuchi.github.io/</id>
  
  <author>
    <name>Koufuchi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>快取的一致性難題與架構模式 (中)</title>
    <link href="https://koufuchi.github.io/2023/05/07/Cache/CacheConsistencyCanal/"/>
    <id>https://koufuchi.github.io/2023/05/07/Cache/CacheConsistencyCanal/</id>
    <published>2023-05-07T12:58:29.000Z</published>
    <updated>2023-09-01T09:40:00.337Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/default.png" alt=""></p><h5 id="阿里巴巴的開源專案-canal"># 阿里巴巴的開源專案 canal :</h5><blockquote><ul><li>讀：和 Read Aside 一樣。先從 Cache 讀，讀到就回，沒讀到就從 DB 讀然後寫回 Cache。</li><li>寫：只寫回 DB，canal 會從 DB 的 binlog 複製到 Cache (canal 扮演 Slave 的角色去監聽 binlog)。</li></ul><p>補充 : binlog 是 MySQL 二進位制格式的日誌，只要資料庫有操作，就會寫入 binlog。</p></blockquote><h5 id="MySQL-主從複製"># MySQL 主從複製 :</h5><blockquote><p>在探討 canal 如何運作之前，我們必須先了解 MySQL 是如何達到主從複製的 :</p><p><img src="/images/MySQLMasterSlave.jpeg" alt=""></p><ol><li>Slave 產生 I/O thread 向 Master 請求 binlog。</li><li>Master 會產生一個 log dump thread，負責傳 binlog 給 Slave 的 I/O thread，而在讀取和發送<br>給 Slave 的過程中會將 binlog 上鎖。</li><li>Slave I/O thread 將得到的 binlog 日志<strong>寫入</strong> Relay log(中繼日誌) 文件中。</li><li>Slave 產生 SQL thread 讀取 Relay log 文件中的日誌，並<strong>解析</strong>成具體操作，這樣就能保證主從操作一致，即達成資料一致。</li></ol><p>你可能已經發現了他實際上還是會存在不一致的時間，至於具體是多久，可能的影響因素很多，包括網路如何連接、有多少個從機、採用什麼樣的主從架構和同步方式等等…。</p><p>大部分人給出的答案都是在同個 lan 下是瞬時的，因為採用獨立的 thread 和 socket 連接，且 binlog 是二進制文件，但是具體的數據官方也沒有提供，可能需要自己測試，可以架好環境後用 SHOW SLAVE STATUS 看 seconds_behind_master 的值。</p></blockquote><h5 id="canal-工作原理"># canal 工作原理 :</h5><blockquote><p>如同上面提到的，MySQL 主從複製是一個成熟且使用者眾多的架構，他的目的也是為了解決分散式架構造成的一致性問題，所以如果我們能讓一個服務偽裝成 Slave 加入這個架構，就能直接沿用這個可靠的架構。</p><p><img src="/images/canal.png" alt=""></p><p>如上圖，canal 模擬 MySQL Slave 的交互協議，讓自己偽裝成 MySQL Slave，並向 MySQL Master 發送 dump 協議，之後 MySQL Master 收到 dump 請求，開始推送 binlog 给 Slave (即 canal)，之後 canal 再解析 binlog，就能再去同步到快取或是做其他事情。</p></blockquote><h5 id="小結"># 小結 :</h5><blockquote><p>canal 其實是基於 MySQL 解決一致性的方法作延伸來達成快取架構，但也代表其綁定了 MySQL，如果你是使用其他關聯式資料庫就不適用，可能需要另外找解法。</p><p>在之後的文章裡，我們會探討 Meta 是如何設計快取架構的，由於不是基於單一資料庫的延伸，他的架構會更加的複雜，以達到 99.99999999% 的快取寫入一致性。</p></blockquote><h5 id="參考"># 參考 :</h5><ul><li><a href="https://github.com/alibaba/canal">canal 官方開源</a></li><li><a href="https://github.com/xingwenge/canal-php">canal-php(基於 canal)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/default.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;阿里巴巴的開源專案-canal&quot;&gt;# 阿里巴巴的開源專案 canal :&lt;/h5&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;讀：和 Read Aside 一樣。先從 C</summary>
      
    
    
    
    <category term="快取" scheme="https://koufuchi.github.io/categories/%E5%BF%AB%E5%8F%96/"/>
    
    
    <category term="Cache" scheme="https://koufuchi.github.io/tags/Cache/"/>
    
    <category term="系統架構" scheme="https://koufuchi.github.io/tags/%E7%B3%BB%E7%B5%B1%E6%9E%B6%E6%A7%8B/"/>
    
    <category term="MySQL" scheme="https://koufuchi.github.io/tags/MySQL/"/>
    
    <category term="Consistency" scheme="https://koufuchi.github.io/tags/Consistency/"/>
    
  </entry>
  
  <entry>
    <title>快取的一致性難題與架構模式 (上)</title>
    <link href="https://koufuchi.github.io/2023/05/07/Cache/CacheConsistency/"/>
    <id>https://koufuchi.github.io/2023/05/07/Cache/CacheConsistency/</id>
    <published>2023-05-07T04:42:32.000Z</published>
    <updated>2023-09-01T09:40:00.336Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/default.png" alt=""></p><h5 id="快取是什麼"># 快取是什麼 :</h5><blockquote><p>我們都知道電腦的核心運算是由 CPU 負責的，而我們的主要的資料儲存單元是硬碟，由於要在硬碟裡面搜尋資料並帶回來是一件時間成本極高的事，所以就有了<strong>將找過的資料暫存起來</strong>的概念，如下圖 :</p><p><img src="/images/cacheIO.png" alt=""></p><p>CPU 會先在 CPU Cache 裡尋找資料，當發現沒有之後就會去 main memory(DRAM) 找，再沒有才會去硬碟找。<br>找到之後就會一路寫回來，這樣你下次要找同樣資料時就不用再跑這麼遠去硬碟找。</p><p>我們之後會探討的快取就是 main memory(DRAM) 與硬碟的這一塊。</p></blockquote><h5 id="為什麼要使用快取"># 為什麼要使用快取 :</h5><blockquote><ol><li>DB 很慢 : 因為 RDBMS 需要保證 <a href="https://zh.wikipedia.org/zh-tw/ACID">ACID</a>，所以必須等待整個流程跑完。</li><li>DB 很貴 : 由於 RDBMS 的資料儲存在硬碟，會需要更多次 IO，上面已說明過。</li><li>DB 離使用者很遠 : 從使用者到你的伺服器再到你的資料庫，中間的關卡相當多。</li></ol></blockquote><h5 id="為什麼快取會有一致性難題"># 為什麼快取會有一致性難題 :</h5><blockquote><p>如果你是分散式系統，那就一定逃不過 <a href="https://zh.wikipedia.org/zh-tw/CAP%E5%AE%9A%E7%90%86">CAP 定理</a>，但如果我只在單一台電腦上同時裝 Cache(ex. Redis) 和 DB(ex. MySQL)，還會有一致性難題嗎？讓我們接著以實作方式來探討。</p></blockquote><h5 id="快取模式-Read-Aside"># 快取模式 - Read Aside :</h5><blockquote><p><img src="/images/cacheReadAside.png" alt=""></p><ul><li>讀：先從 Cache 讀，讀到就回，沒讀到就從 DB 讀然後寫回 Cache。</li><li>寫：先寫回 DB，接著清掉 Cache。</li></ul><p>大部分情況都會正常，因為架構很簡單所以是常見的做法。<br>缺點為極端情況下不符合一致性，因為先對 DB 做事再去同步 Cache，所以同步前的時間差會導致非一致性。</p><ul><li>問題一 : A 寫了新資料，但還沒同步到 Cache 前 B 就去讀 Cache 的資料，導致不一致。</li></ul><p><img src="/images/cacheReadAsideProblem1.png" alt=""></p><ul><li>問題二 : A 寫了新資料，但要去同步到 Cache 時出了狀況，導致 DB 和 Cache 不一致。</li></ul><p><img src="/images/cacheReadAsideProblem2.png" alt=""></p><ul><li>問題三 : A 讀資料時發現 Cache 沒資料，所以去 DB 讀，但在寫回 Cache 前 B 就已經更新此資料並清掉Cache 了，這時候 A 才將舊資料寫回 Cache，導致不一致。</li></ul><p><img src="/images/cacheReadAsideProblem3.png" alt=""></p></blockquote><h5 id="快取模式-Double-Delete"># 快取模式 - Double Delete :</h5><blockquote><p><img src="/images/cacheReadAside.png" alt=""></p><ul><li>讀：先從 Cache 讀，讀到就回，沒讀到就從 DB 讀然後寫回 Cache。</li><li>寫：先清掉 Cache 再寫回 DB，接著<strong>等一下</strong>(依需求調整，例如 0.5s) 再清掉 Cache。</li></ul><p>我們可以發現他和 Read Aside 只差在寫的部分，原理是先避免其他人讀到舊資料，之後寫入 DB，先等一下再清掉 Cache 的過程則是為了減少 Read Aside 的問題三發生機率，所以雖然一致的機率提高了，但終究是會在極端情況下不符合一致性。</p></blockquote><h5 id="快取模式-Read-through"># 快取模式 - Read through :</h5><blockquote><p><img src="/images/cacheReadThrough.png" alt=""></p><ul><li>讀：先從 Cache 讀，讀到就回，沒讀到就<strong>由 Cache 從 DB 讀</strong>。</li><li>寫：無所謂，通常結合 Write Through 或 Write Behind 使用。</li></ul><p>注意<strong>由 Cache 從 DB 讀</strong>的實現 Redis 並不支援，NCache 則是需要收費。<br>可以自己實作 Data Access Layer(DAL)，在 DAL 裡用內部 api 伺服器去決定讀 Cache 還是 DB，而對於應用程式來說並不需要知道到底打了誰或是有沒有緩存，他只要知道可以透過 DAL 快速得到資料就好。</p></blockquote><h5 id="快取模式-Write-through"># 快取模式 - Write through :</h5><blockquote><p><img src="/images/cacheReadThrough.png" alt=""></p><ul><li>讀：無所謂，通常結合 Read Through 使用。</li><li>寫：只更新 Cache，並<strong>由 Cache 去更新 DB</strong>。</li></ul><p>注意跟 Read through 一樣，<strong>由 Cache 去更新 DB</strong> 的實現 Redis 並不支援，NCache 則是需要收費。<br>所以一樣可以藉由實作 Data Access Layer(DAL)來實現。</p><p>也就是說，當你使用 Read through + Write through 來實作快取架構，相當於你都只對 DAL 操作，這樣的優點是可以解決 Read Aside 的問題，但也引發了新的問題 :</p><ol><li>速度慢，因為你同時要寫完 Cache 和 DB 才算完成。</li><li>如果你不是用 DAL 而是原生支援 DB 連線的 Cache 的話，如果在 Cache 未寫入 DB 前就斷電重啟的話，那筆尚未更新到 DB 的資料就會永久遺失。</li></ol></blockquote><h5 id="快取模式-Write-Ahead-Behind-Back"># 快取模式 - Write Ahead (Behind)(Back) :</h5><blockquote><p><img src="/images/cacheWriteAhead.png" alt=""></p><ul><li>讀：無所謂，通常結合 Read Through 使用。</li><li>寫：需實作 DAL，並<strong>由 DAL 去更新 Cache 和 DB</strong>。</li></ul><p>和 Write through 不一樣需實作 DAL，並且會使用 Message Queue 來管理請求，這樣就可以避免 Cache 永久遺失資料的問題，也可以進一步實現對資料庫的批次寫入以減少寫入次數(Write Back)，但這樣的架構不好實現，需要處理非常多的細節，除非你真的需要這樣的可靠性，不然直接實作 Read Aside 是最簡單的。</p></blockquote><h5 id="小結"># 小結 :</h5><blockquote><p>介紹了這麼多不同做法，我們應該可以深刻體會一致性的難題有多複雜，以及這些架構背後可能會需要付出的成本，所以在決定你要如何實現快取架構前，你應該先考慮 :</p><ol><li>你的情境為何？為什麼要使用快取？</li><li>你的快取機器要求會有多高？會不會需要分散式？</li><li>比較看重的是一致性還是可用性？</li><li>哪些動作的延遲是可以接受的？哪些不行？讀跟寫的需求那個比較重？</li><li>你的快取需要多高的一致性保證？例如 Meta 可以保證 99.99999999% 的快取寫入一致性。</li></ol><p>在之後的文章裡，我們會探討阿里巴巴和 Meta 是如何設計快取架構的，雖然絕大多數的公司都不需要實現如此高的一致性，但他們的架構還是值得了解。</p></blockquote><h5 id="參考"># 參考 :</h5><ul><li><a href="https://web.ntnu.edu.tw/~algo/AlgorithmDesign.html#11">I/O-efficient Algorithm</a></li><li><a href="https://hackmd.io/@drwQtdGASN2n-vt_4poKnw/H1U6NgK3Z">CPU Cache 原理探討</a></li><li><a href="https://www.cs.pu.edu.tw/~bcc/93course/ch18.pdf">計算機組織與結構</a></li><li><a href="https://medium.com/starbugs/consistency-between-cache-and-database-part-1-f64f4a76720">Consistency between Cache and Database, Part 1</a></li><li><a href="https://medium.com/starbugs/consistency-between-cache-and-database-part-2-e28fc7f8a7c3">Consistency between Cache and Database, Part 2</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10224938">資料緩存失效問題</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/default.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;快取是什麼&quot;&gt;# 快取是什麼 :&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;我們都知道電腦的核心運算是由 CPU 負責的，而我們的主要的資料儲存單元是硬碟，由於要在硬碟裡面</summary>
      
    
    
    
    <category term="快取" scheme="https://koufuchi.github.io/categories/%E5%BF%AB%E5%8F%96/"/>
    
    
    <category term="Cache" scheme="https://koufuchi.github.io/tags/Cache/"/>
    
    <category term="系統架構" scheme="https://koufuchi.github.io/tags/%E7%B3%BB%E7%B5%B1%E6%9E%B6%E6%A7%8B/"/>
    
    <category term="Consistency" scheme="https://koufuchi.github.io/tags/Consistency/"/>
    
    <category term="計算機組織" scheme="https://koufuchi.github.io/tags/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%B5%84%E7%B9%94/"/>
    
    <category term="Message queue" scheme="https://koufuchi.github.io/tags/Message-queue/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 49. Group Anagrams</title>
    <link href="https://koufuchi.github.io/2023/05/05/LeetCode/GroupAnagrams/"/>
    <id>https://koufuchi.github.io/2023/05/05/LeetCode/GroupAnagrams/</id>
    <published>2023-05-05T14:35:31.000Z</published>
    <updated>2023-09-01T06:37:51.621Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/leetCode.png" alt=""></p><h5 id="題目："># 題目：</h5><p><a href="https://leetcode.com/problems/group-anagrams/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給定一個字串陣列 strs，需要把每個字串依據 anagram 做分類放進不同的陣列後回傳。<br>相同 anagram 定義 : 若字串 s 的字元出現頻率與字串 t 相同，則他們為同一個 anagram。</p><p>例如輸入 strs=[“eat”,“tea”,“tan”,“ate”,“nat”,“bat”]，應回傳 [[“bat”],[“nat”,“tan”],[“ate”,“eat”,“tea”]]，不看順序。</p><ul><li>1 &lt;= strs.length &lt;= 10^4</li><li>0 &lt;= strs[i].length &lt;= 100</li><li>strs 裡的每個字串都只由小寫英文字組成</li></ul></blockquote><h5 id="解法："># 解法：</h5><blockquote><p>原本想到的作法是每個字串做一個<strong>字符出現次數表</strong>，但這樣的時間複雜度就會變成「字串總數 * (每個字串的最大長度 * 當下有的出現次數表(最大等於字串總數) * 當下有的出現次數表最大長度)，光看就不可行。</p><p>後來想說既然存出現次數陣列沒比較快，那就改成<strong>存排序後的不重複字串</strong>，也就是對每個字串做排序後去比較我們存過的不重複字串，時間複雜度會變成「字串總數 * 最大字串排序的時間複雜度」。而因為基本上排序演算法最快也要 O(MlogM)，所以當字串總數 N 且最大字串長度 M 時，時間複雜度會是 O(N * MlogM)。</p><p>最後是參考別人的答案 : 方法一之所以慢是因為你沒有辦法在 O(K) 的時間複雜度內找到他是否有符合已找過的 K 個 anagram 種類之一，而方法二雖然成功讓其降到 O(K)，卻因為需要做排序導致變成 O(MlogM)，所以最後這個方法三就是讓你不需排序也能達到 O(K) 甚至更快。</p><p>具體來說，我們可以發現題目確保每個字串都是小寫字母，也就是說他們本來就有順序的關係性在，由於 a 的 ASCII 值是 97，而 b 是 98，以此類推到 z，所以可以將每個小寫字母(a~z)減去 a 的值當作索引，剛好就會是索引從 0 開始排到 25 的陣列，你就可以用這個陣列當作有序的字符出現次數表，之後將這個陣列轉成字串當作陣列索引，你就能在 O(1) 的時間複雜度內找到他是否有符合已找過的 anagram 種類之一。</p><p>需要注意的陷阱是每個字母出現的次數有可能超過十位數，就代表如果你將陣列轉成字串的作法是直接把次數串在一起就會錯，例如下圖的第二個範例 :</p><p><img src="/images/GroupAnagramsExample1.jpg" alt=""></p><p>所以說我們在串聯時可以加上特殊標記來區分，例如 :</p><p><img src="/images/GroupAnagramsExample2.jpg" alt=""></p><p>這樣就不會搞混了。</p><ul><li>時間複雜度 O(N * M)，N 為字串總數，M 為最大字串長度</li><li>空間複雜度 O(N)</li></ul></blockquote><h5 id="PHP-程式碼："># PHP 程式碼：</h5><ul><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/app/LeetCode/Blind75/Array/GroupAnagrams.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/tests/Unit/LeetCode/Blind75/Array/GroupAnagramsTest.php">單元測試</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/leetCode.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;題目：&quot;&gt;# 題目：&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/group-anagrams/&quot;&gt;官網題目連結&lt;/a&gt;</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://koufuchi.github.io/categories/LeetCode/"/>
    
    
    <category term="PHP" scheme="https://koufuchi.github.io/tags/PHP/"/>
    
    <category term="Array" scheme="https://koufuchi.github.io/tags/Array/"/>
    
    <category term="HashTable" scheme="https://koufuchi.github.io/tags/HashTable/"/>
    
    <category term="演算法" scheme="https://koufuchi.github.io/tags/%E6%BC%94%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://koufuchi.github.io/tags/LeetCode/"/>
    
    <category term="Blind75" scheme="https://koufuchi.github.io/tags/Blind75/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 242. Valid Anagram</title>
    <link href="https://koufuchi.github.io/2023/05/03/LeetCode/ValidAnagram/"/>
    <id>https://koufuchi.github.io/2023/05/03/LeetCode/ValidAnagram/</id>
    <published>2023-05-03T13:48:38.000Z</published>
    <updated>2023-09-01T06:37:51.621Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/leetCode.png" alt=""></p><h5 id="題目："># 題目：</h5><p><a href="https://leetcode.com/problems/valid-anagram/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給定兩個字串 s 和 t，你必須判斷 s 是不是 t 的 anagram，若是則回傳 true，不是則回傳 false。</p><p>s 必須符合以下兩個條件才能算是 t 的 anagram :</p><ol><li>s 和 t 字串長度相同</li><li>s 和 t 有相同的字元數且各字元出現次數相同</li></ol><p>例如輸入 s = “anagram”, t = “nagaram”，應回傳 true。<br>輸入 s = “rat”, t = “car”，則回傳 false</p><ul><li>1 &lt;= s.length, t.length &lt;= 5*10^4</li><li>s 和 t 都只由小寫英文字組成。</li></ul></blockquote><h5 id="解法："># 解法：</h5><blockquote><p>原本想到的作法是遍歷 s 並記錄 s 中各字母出現次數，之後再遍歷 t 並用紀錄的陣列去減，如果有新字母或出現次數變成負數的情況就代表兩者不相同，但這樣做會導致最差情況(s 是 t 的 anagram)必須遍歷兩次 s 長度。</p><p>後來發現其實根本不需要分開遍歷，因為你可以<strong>從記錄 s 變成紀錄兩者差距</strong>，也就是 s 有的就加，t 有的就減，這樣你就只需要遍歷找完的字母出現次數差異陣列，發現有字母出現次數不等於 0 的時候就代表失敗。雖然最差情況(s 是 t 的 anagram 且字母出現次數不重複)也是遍歷兩次 s 長度，但這只會發生在剛好 26 個字母的時候，所以絕大情況下這個做法都是實際效能更高的。</p><ul><li>時間複雜度 O(N)，如何證明檢查存在鍵與拿取存放的時間複雜度請 <a href="/2022/10/19/PHPArray/">參考我的另一篇文章 - PHP Array</a></li><li>空間複雜度 O(N)</li></ul></blockquote><h5 id="PHP-程式碼："># PHP 程式碼：</h5><ul><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/app/LeetCode/Blind75/Array/ValidAnagram.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/tests/Unit/LeetCode/Blind75/Array/ValidAnagramTest.php">單元測試</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/leetCode.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;題目：&quot;&gt;# 題目：&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/valid-anagram/&quot;&gt;官網題目連結&lt;/a&gt;&lt;</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://koufuchi.github.io/categories/LeetCode/"/>
    
    
    <category term="PHP" scheme="https://koufuchi.github.io/tags/PHP/"/>
    
    <category term="Array" scheme="https://koufuchi.github.io/tags/Array/"/>
    
    <category term="HashTable" scheme="https://koufuchi.github.io/tags/HashTable/"/>
    
    <category term="演算法" scheme="https://koufuchi.github.io/tags/%E6%BC%94%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://koufuchi.github.io/tags/LeetCode/"/>
    
    <category term="Blind75" scheme="https://koufuchi.github.io/tags/Blind75/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 217. Contains Duplicate</title>
    <link href="https://koufuchi.github.io/2023/05/02/LeetCode/ContainsDuplicate/"/>
    <id>https://koufuchi.github.io/2023/05/02/LeetCode/ContainsDuplicate/</id>
    <published>2023-05-02T14:49:56.000Z</published>
    <updated>2023-09-01T06:37:51.621Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/leetCode.png" alt=""></p><h5 id="題目："># 題目：</h5><p><a href="https://leetcode.com/problems/contains-duplicate/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給定一個整數陣列 nums，你必須判斷 nums 中是否有元素值是重複出現的，若有則回傳 true，沒有則回傳 false。</p><p>例如輸入 nums=[1, 2, 3, 1]，由於元素值 1 重複出現，所以回傳 true。<br>而若輸入 nums=[1, 2, 3, 4]，由於元素值都沒有重複出現，所以回傳 false。</p><ul><li>1 &lt;= nums.length &lt;= 10^5</li><li>-10^9 &lt;= nums[i] &lt;= 10^9</li></ul></blockquote><h5 id="解法："># 解法：</h5><blockquote><p>這題比 <a href="/2023/05/02/LeetCode/TwoSum/">TwoSum</a> 更簡單，因為我們不需要知道重複的元素分別在哪裡，只需要知道當檢查到重複元素值時就回傳 true 就好。</p><p>所以一樣可以花一點空間來換時間，也就是用另一個陣列來邊找邊記錄我們已找過的值，當發現 nums[i] 已經有找過時，就代表要回傳 true。</p><ul><li>時間複雜度 O(N)，如何證明檢查存在鍵與拿取存放的時間複雜度請 <a href="/2022/10/19/PHPArray/">參考我的另一篇文章 - PHP Array</a></li><li>空間複雜度 O(N)</li></ul></blockquote><h5 id="PHP-程式碼："># PHP 程式碼：</h5><ul><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/app/LeetCode/Blind75/Array/ContainsDuplicate.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/tests/Unit/LeetCode/Blind75/Array/ContainsDuplicateTest.php">單元測試</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/leetCode.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;題目：&quot;&gt;# 題目：&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/contains-duplicate/&quot;&gt;官網題目連結</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://koufuchi.github.io/categories/LeetCode/"/>
    
    
    <category term="PHP" scheme="https://koufuchi.github.io/tags/PHP/"/>
    
    <category term="Array" scheme="https://koufuchi.github.io/tags/Array/"/>
    
    <category term="HashTable" scheme="https://koufuchi.github.io/tags/HashTable/"/>
    
    <category term="演算法" scheme="https://koufuchi.github.io/tags/%E6%BC%94%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://koufuchi.github.io/tags/LeetCode/"/>
    
    <category term="Blind75" scheme="https://koufuchi.github.io/tags/Blind75/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1. Two Sum</title>
    <link href="https://koufuchi.github.io/2023/05/02/LeetCode/TwoSum/"/>
    <id>https://koufuchi.github.io/2023/05/02/LeetCode/TwoSum/</id>
    <published>2023-05-02T13:41:05.000Z</published>
    <updated>2023-09-01T06:37:51.621Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/leetCode.png" alt=""></p><h5 id="題目："># 題目：</h5><p><a href="https://leetcode.com/problems/two-sum/">官網題目連結</a></p><blockquote><p>最經典的 LeetCode 第一題，求兩數之和！</p><p>根據題目敘述，會給定一個整數陣列 nums，還有一個整數 target，你必須找出 nums 中哪兩個元素相加會等於 target，用陣列回傳他們的索引。</p><p>例如輸入 nums=[2, 7, 11, 15], target=9，由於前兩個元素 2+7=9 剛好就是答案，所以回傳 [0 ,1]，題目特別說<strong>不看順序</strong>所以你要回傳 [1, 0] 也可以。</p><ul><li>2 &lt;= nums.length &lt;= 10^4</li><li>-10^9 &lt;= nums[i] &lt;= 10^9</li><li>-10^9 &lt;= target &lt;= 10^9</li></ul></blockquote><h5 id="解法："># 解法：</h5><blockquote><p>沒碰過演算法的人可能一開始都會想到用暴力解，也就是先用第 1 個去對剩下 N-1，再用第 2 個去對剩下 N-2 個，但這樣的做法會導致運算次數變成等差數列總和，也就是時間複雜度 O(N^2)。</p><p>我們可以花一點空間來換時間，也就是用另一個陣列來邊找邊記錄我們已找過的值，當發現 target - nums[i] 已經有找過時，就代表這是答案。</p><ul><li>時間複雜度 O(N)，如何證明檢查存在鍵與拿取存放的時間複雜度請 <a href="/2022/10/19/PHPArray/">參考我的另一篇文章 - PHP Array</a></li><li>空間複雜度 O(N)</li></ul></blockquote><h5 id="PHP-程式碼："># PHP 程式碼：</h5><ul><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/app/LeetCode/Blind75/Array/TwoSum.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/tests/Unit/LeetCode/Blind75/Array/TwoSumTest.php">單元測試</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/leetCode.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;題目：&quot;&gt;# 題目：&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/two-sum/&quot;&gt;官網題目連結&lt;/a&gt;&lt;/p&gt;
&lt;b</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://koufuchi.github.io/categories/LeetCode/"/>
    
    
    <category term="PHP" scheme="https://koufuchi.github.io/tags/PHP/"/>
    
    <category term="Array" scheme="https://koufuchi.github.io/tags/Array/"/>
    
    <category term="HashTable" scheme="https://koufuchi.github.io/tags/HashTable/"/>
    
    <category term="演算法" scheme="https://koufuchi.github.io/tags/%E6%BC%94%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://koufuchi.github.io/tags/LeetCode/"/>
    
    <category term="Blind75" scheme="https://koufuchi.github.io/tags/Blind75/"/>
    
  </entry>
  
  <entry>
    <title>用 Linux 的 systemd 來保持你的服務吧 !</title>
    <link href="https://koufuchi.github.io/2023/05/01/SystemdToKeepAlive/"/>
    <id>https://koufuchi.github.io/2023/05/01/SystemdToKeepAlive/</id>
    <published>2023-05-01T05:45:27.000Z</published>
    <updated>2023-09-01T06:37:51.622Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/default.png" alt=""></p><h5 id="簡介"># 簡介 :</h5><blockquote><p>systemd 基於一個事件驅動的機制，它可以同時啟動並管理多個服務，並在服務失敗或系統崩潰時自動重啟服務。它還提供了各種管理命令和工具，用於管理系統日誌、網絡配置、作業系統時間等等…。</p></blockquote><h5 id="首先，移動到系統單位檔案的存放位置"># 首先，移動到系統單位檔案的存放位置 :</h5><pre><code class="language-sh">cd /etc/systemd/system   # 我是用 ubuntu 22.04 版本，如果你路徑不一樣請自己找</code></pre><h5 id="建立系統單位檔案"># 建立系統單位檔案 :</h5><pre><code class="language-sh">touch &lt;your service name&gt;.service</code></pre><h5 id="打開你建立的檔案並寫入設定"># 打開你建立的檔案並寫入設定 :</h5><pre><code class="language-sh">[Unit]Description=&lt;write your description&gt;[Service]# 讓 systemd 知道編譯器和啟動檔案在哪，以及啟動方式，一般來說你怎麼啟動的就直接貼過來，不過他不吃你的 $PATH 所以要給完整路徑ExecStart=/usr/bin/python3 -u /home/ubuntu/projects/DiscordBot/main.py  WorkingDirectory=/home/ubuntu/projects/DiscordBot/User=ubuntu  # 要記得確保有權限讀取和執行 WorkingDirectory 底下所有檔案Group=ubuntu  # 要記得確保有權限讀取和執行 WorkingDirectory 底下所有檔案Restart=on-failure[Install]WantedBy=multi-user.target</code></pre><h5 id="開始執行"># 開始執行 :</h5><pre><code class="language-sh">sudo systemctl start &lt;your service name&gt;.service</code></pre><h5 id="查看服務狀態"># 查看服務狀態 :</h5><pre><code class="language-sh">sudo systemctl status &lt;your service name&gt;.service</code></pre><h5 id="當你有變更你的-service-內容時，需要先-reload"># 當你有變更你的 .service 內容時，需要先 reload :</h5><pre><code class="language-sh">sudo systemctl daemon-reload</code></pre><h5 id="其他語法"># 其他語法 :</h5><ul><li>設定為啟動系統時就自動啟動 :</li></ul><pre><code class="language-sh">sudo systemctl enable &lt;your service name&gt;.service</code></pre><ul><li>停止服務 :</li></ul><pre><code class="language-sh">sudo systemctl stop &lt;your service name&gt;.service</code></pre><ul><li>重啟服務 :</li></ul><pre><code class="language-sh">sudo systemctl restart &lt;your service name&gt;.service</code></pre><ul><li>查看錯誤日誌 :</li></ul><pre><code class="language-sh">journalctl -u &lt;your service name&gt;.service</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/default.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;簡介&quot;&gt;# 簡介 :&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;systemd 基於一個事件驅動的機制，它可以同時啟動並管理多個服務，並在服務失敗或系統崩潰時自動重啟服務。</summary>
      
    
    
    
    <category term="Linux" scheme="https://koufuchi.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://koufuchi.github.io/tags/Linux/"/>
    
    <category term="systemd" scheme="https://koufuchi.github.io/tags/systemd/"/>
    
  </entry>
  
  <entry>
    <title>用 Postman 實現 api 自動測試吧 !</title>
    <link href="https://koufuchi.github.io/2023/04/30/PostMan/PostmanTest/"/>
    <id>https://koufuchi.github.io/2023/04/30/PostMan/PostmanTest/</id>
    <published>2023-04-30T02:21:41.000Z</published>
    <updated>2023-09-01T06:37:51.622Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/default.png" alt=""></p><h5 id="Postman-工作區目錄架構"># Postman 工作區目錄架構 :</h5><blockquote><p>Postman 的工作區目錄架構為 Collection、Folder、Request、Example，如下圖 :</p><p><img src="/images/postmanStructure.png" alt=""></p><p>注意只有 Folder 可以自己包自己。</p><p>我們可以寫測試的範圍有 Collection、Folder、Request，不包含 Example，原因為 Example 只是把一些參數取出來單獨設定而已，他要執行時會將這些參數覆寫到繼承的 Request 並執行，但終究還是歸附於 Request，所以也會執行 Request 寫好的測試。</p></blockquote><h5 id="自動測試的執行順序"># 自動測試的執行順序 :</h5><blockquote><p>在 Collection、Folder、Request 界面中我們都可找到和設定「Pre-request Script」以及「Tests」，顧名思義就是一個是先跑的腳本、另一個是最後才跑的腳本，我們假設範例為 Collection 包 Folder 包 Request，且都有設定「Pre-request Script」以及「Tests」，那麼當你按下 Send Request 後的執行順序就是 :</p><ol><li>Collection Pre-request Script</li><li>Folder Pre-request Script</li><li>Request Pre-request Script</li><li>Request 本身</li><li>Request Tests</li><li>Folder Tests</li><li>Collection Tests</li></ol><p>從這樣的順序也很明顯可以看出 :</p><ul><li>Pre-request Script 在打 api 前就執行了，可以做的事有檢查參數、預打其他 api 拿 token 等等…。</li><li>Tests 是在打 api 後執行的，可以做的事有檢查回傳狀態、檢查回傳內容等等…。</li></ul></blockquote><h5 id="如何撰寫測試"># 如何撰寫測試 :</h5><blockquote><p>Postman 的腳本撰寫語法是基於 JavaScript，並提供物件 pm 以供操作，至於詳細有哪些用法官網已經寫得很清楚了，參考 :</p><ul><li><a href="https://learning.postman.com/docs/writing-scripts/pre-request-scripts/">Writing pre-request scripts</a></li><li><a href="https://learning.postman.com/docs/writing-scripts/test-scripts/">Writing tests</a></li></ul></blockquote><h5 id="範例一，打-api-前檢查當前用的-Postman-環境變數"># 範例一，打 api 前檢查當前用的 Postman 環境變數 :</h5><blockquote><p>情境 : 因為有時候打不同台伺服器或本地時忘了切換環境變數，會導致我對應的 domain 值壞掉。</p></blockquote><pre><code class="language-JavaScript">pm.test(&quot;檢查環境變數&quot;, function () &#123;     pm.expect(pm.environment.get(&quot;domain&quot;)).to.be.oneOf([        &quot;打卡系統正式機&quot;,        &quot;打卡系統測試機&quot;    ]); &#125;);</code></pre><blockquote><p>像這個範例你就可以寫在 Collection 的 Pre-request Script，因為通常一個 Collection 就對應一個系統、服務，其底下的 Request 應該都是吃同一種環境變數。</p></blockquote><h5 id="範例二，檢查-api-response-的狀態"># 範例二，檢查 api response 的狀態 :</h5><blockquote><p>情境 : 我希望知道此次回傳是否成功(這範例其實蠻雞肋的啦，因為本來界面就會顯示了)。</p></blockquote><pre><code class="language-JavaScript">pm.test(&quot;檢查回傳狀態&quot;, function () &#123;    pm.response.to.have.status(200);&#125;);</code></pre><h5 id="範例三，檢查-api-request-的-JSON-Schema"># 範例三，檢查 api request 的 JSON Schema :</h5><blockquote><p>情境 : 有時候你邊寫邊打就忘了有些 request 參數忘了改，這時候就能檢查。<br>注意 : Postman 用的 jsonSchema 是最新版的，你需要注意自己使用的版本是否有落差，因為寫法會變。<br>以筆者撰寫這篇文章的時間點來說是 3.1 或以上。</p></blockquote><pre><code class="language-JavaScript">// 定義期望的 JSON Schemalet schema = &#123;    &quot;type&quot;: &quot;object&quot;,    &quot;properties&quot;: &#123;        &quot;orderId&quot;: &#123;            &quot;type&quot;: [&quot;integer&quot;, &quot;null&quot;],        &#125;,        &quot;isVoid&quot;: &#123;            &quot;type&quot;: [&quot;boolean&quot;, &quot;null&quot;],        &#125;    &#125;&#125;// 檢查pm.test(&quot;檢查請求 json 是否符合期望的 jsonSchema&quot;, function () &#123;     pm.request.to.have.jsonSchema(schema);&#125;);</code></pre><h5 id="範例四，檢查-api-response-的-JSON-Schema"># 範例四，檢查 api response 的 JSON Schema :</h5><blockquote><p>情境 : 我希望回傳的 key 都符合我的期望，例如期望是整數那就不能回傳字串。<br>用法跟上面幾乎一樣，只是你要改從 response 拿而已。</p></blockquote><pre><code class="language-JavaScript">// 定義期望的 JSON Schemalet schema = &#123;    &quot;type&quot;: &quot;object&quot;,    &quot;properties&quot;: &#123;        &quot;typeId&quot;: &#123;            &quot;type&quot;: [&quot;integer&quot;, &quot;null&quot;],        &#125;,        &quot;statusId&quot;: &#123;            &quot;type&quot;: [&quot;integer&quot;, &quot;null&quot;],        &#125;,        &quot;supplierCode&quot;: &#123;            &quot;type&quot;: [&quot;integer&quot;, &quot;null&quot;],        &#125;,        &quot;customerName&quot;: &#123;            &quot;type&quot;: [&quot;string&quot;, &quot;null&quot;],        &#125;    &#125;&#125;;// 檢查pm.test(&quot;檢查回傳 json 是否符合期望的 jsonSchema&quot;, function () &#123;     pm.response.to.have.jsonSchema(schema);&#125;);</code></pre><blockquote><p>你可能會覺得定義 jsonSchema 很麻煩，沒錯！因為我也這樣覺得，所以在這邊提供方法 :</p><ol><li><p>一般來說都會有寫 swagger 給前端對接用，那你就直接拿這個用就好了，簡單粗暴，像 Laravel 框架可以使用 : php artisan l5-swagger:generate 的指令快速產出。</p></li><li><p>你的 request 或 response 在 Postman 上都有完整 JSON 了，所以你可以使用 <a href="https://jsonschema.net/app/schemas">JSON Schema – json 轉 jsonschema</a> 快速轉換，但最麻煩的就是 nullable 你要自己加。</p></li></ol><p><a href="/2023/04/29/ThirdParty/">參考我的另一篇文章 - 常用的第三方工具</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/default.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;Postman-工作區目錄架構&quot;&gt;# Postman 工作區目錄架構 :&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;Postman 的工作區目錄架構為 Collection</summary>
      
    
    
    
    <category term="Postman" scheme="https://koufuchi.github.io/categories/Postman/"/>
    
    
    <category term="Postman" scheme="https://koufuchi.github.io/tags/Postman/"/>
    
    <category term="自動化測試" scheme="https://koufuchi.github.io/tags/%E8%87%AA%E5%8B%95%E5%8C%96%E6%B8%AC%E8%A9%A6/"/>
    
    <category term="JavaScript" scheme="https://koufuchi.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>常用的第三方工具</title>
    <link href="https://koufuchi.github.io/2023/04/29/ThirdParty/"/>
    <id>https://koufuchi.github.io/2023/04/29/ThirdParty/</id>
    <published>2023-04-29T12:25:54.000Z</published>
    <updated>2023-09-01T06:37:51.622Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/default.png" alt=""></p><h5 id="工作中用過的一些第三方工具："># 工作中用過的一些第三方工具：</h5><ul><li><p><a href="https://regex101.com/">regex101 – 線上測試正規表達式工具</a></p></li><li><p><a href="https://crontab.guru/">crontab guru – 線上測試 corntab 語法工具</a></p></li><li><p><a href="https://sequencediagram.org/">sequencediagram – 畫時序圖工具</a></p></li><li><p><a href="https://app.diagrams.net/">Draw.io – 畫圖工具</a></p></li><li><p><a href="http://sqlfiddle.com/">SQL Fiddle – 線上資料庫工具</a></p></li><li><p><a href="https://dbdiagram.io/home">dbdiagram – 資料庫工具</a></p></li><li><p><a href="https://dbschema.com/">dbSchema – 資料庫工具</a></p></li><li><p><a href="https://jsoneditoronline.org/#left=local.ranopi&amp;right=local.vosuzi">json editor – JSON 比對工具</a></p></li><li><p><a href="https://jsonschema.net/app/schemas">JSON Schema – json 轉 jsonschema</a></p></li><li><p><a href="https://shancarter.github.io/mr-data-converter/">Mr. Data Converter – CSV 轉其他格式</a></p></li><li><p><a href="https://slack.com/intl/zh-tw">Slack – 團隊溝通</a></p></li><li><p><a href="https://www.invisionapp.com/">InVision – 前端畫面工具</a></p></li><li><p><a href="https://www.figma.com/">figma – UI 設計工具</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/default.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;工作中用過的一些第三方工具：&quot;&gt;# 工作中用過的一些第三方工具：&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://regex101.com/&quot;&gt;reg</summary>
      
    
    
    
    <category term="第三方工具" scheme="https://koufuchi.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="第三方工具" scheme="https://koufuchi.github.io/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>讓你的 git commit message 更容易閱讀</title>
    <link href="https://koufuchi.github.io/2023/04/29/git/GitCommitMessage/"/>
    <id>https://koufuchi.github.io/2023/04/29/git/GitCommitMessage/</id>
    <published>2023-04-29T07:42:07.000Z</published>
    <updated>2023-09-01T06:37:51.622Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/default.png" alt=""></p><h5 id="讓版控更加容易追蹤"># 讓版控更加容易追蹤 :</h5><blockquote><p>習慣上會將每個 commit 的內容盡量限縮在<strong>單一單元或一件事</strong>上，以讓你的 commit message 和異動處能夠簡潔的對應，對於自己或團隊成員在追蹤進度、回顧異動上都能提高效率。</p><p>在這之上能更快表達此次 commit 意義的做法，就是在 commit message 開頭加上<strong>前綴字</strong>，常見的有 :</p><ul><li>feat : 新增/修改功能 (feature)。</li><li>fix : 修補 bug (bug fix)。</li><li>docs : 文件 (documentation)。</li><li>style : 格式 (不影響程式碼運行的變動 white-space, formatting, missing semi colons, etc)。</li><li>refactor : 重構 (既不是新增功能，也不是修補 bug 的程式碼變動)。</li><li>perf : 改善效能 (A code change that improves performance)。</li><li>test : 增加測試 (when adding missing tests)。</li><li>chore : 建構程序或輔助工具的變動 (maintain)。</li><li>revert : 撤銷回覆先前的 commit 例如：revert: type(scope): subject (回覆版本：xxxx)。</li></ul><p>加上前綴字之後一看就能先猜到在做什麼，之後再閱讀你改動的訊息就能更快進入狀況。</p></blockquote><h5 id="參考"># 參考</h5><ul><li><a href="https://wadehuanglearning.blogspot.com/2019/05/commit-commit-commit-why-what-commit.html">Git Commit Message 這樣寫會更好，替專案引入規範與範例</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/default.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;讓版控更加容易追蹤&quot;&gt;# 讓版控更加容易追蹤 :&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;習慣上會將每個 commit 的內容盡量限縮在&lt;strong&gt;單一單元或一件事&lt;</summary>
      
    
    
    
    <category term="git" scheme="https://koufuchi.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://koufuchi.github.io/tags/git/"/>
    
    <category term="style" scheme="https://koufuchi.github.io/tags/style/"/>
    
  </entry>
  
  <entry>
    <title>Codility Lesson MissingInteger</title>
    <link href="https://koufuchi.github.io/2023/04/27/Codility/CodilityLessonMissingInteger/"/>
    <id>https://koufuchi.github.io/2023/04/27/Codility/CodilityLessonMissingInteger/</id>
    <published>2023-04-27T12:35:52.000Z</published>
    <updated>2023-09-01T06:37:51.620Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/codility.png" alt=""></p><h5 id="題目："># 題目：</h5><p><a href="https://app.codility.com/programmers/lessons/4-counting_elements/missing_integer/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給一個由 N 個整數組成的陣列 A。需找出 A 中沒有出現且大於 0 的最小正整數。<br>例如輸入 A=[1, 3, 6, 4, 1, 2]，答案應為 5。<br>A=[1, 2, 3]，答案應為 4。<br>A=[-1, -3]，答案應為 1。</p><ul><li>N 是範圍 [1~100000] 的整數。</li><li>陣列 A 裡的元素都是範圍 [−1000000~1000000] 的整數。</li></ul></blockquote><h5 id="解法："># 解法：</h5><blockquote><p>第一時間還是想到了記憶法，先遍歷 A 記錄走過的不重複合法值，之後再遍歷記錄到的合法值來找出第一個 合法總數+1 的範圍內沒有記錄到的合法值。</p><p>總覺得還有機會想出跟 <a href="/2023/04/25/Codility/CodilityLessonMaxCounters/">MaxCounters</a> 一樣將當前最小值與合法最小值分開存的方法，就不用分兩次遍歷，但目前仍未想到。</p><ul><li>時間複雜度 O(N)</li><li>空間複雜度 O(N)</li></ul></blockquote><h5 id="PHP-程式碼："># PHP 程式碼：</h5><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/CountingElements/MissingInteger.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/CountingElements/MissingIntegerTest.php">單元測試</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/codility.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;題目：&quot;&gt;# 題目：&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;https://app.codility.com/programmers/lessons/4-counting_e</summary>
      
    
    
    
    <category term="Codility" scheme="https://koufuchi.github.io/categories/Codility/"/>
    
    
    <category term="PHP" scheme="https://koufuchi.github.io/tags/PHP/"/>
    
    <category term="演算法" scheme="https://koufuchi.github.io/tags/%E6%BC%94%E7%AE%97%E6%B3%95/"/>
    
    <category term="Codility" scheme="https://koufuchi.github.io/tags/Codility/"/>
    
  </entry>
  
  <entry>
    <title>Codility Lesson MaxCounters</title>
    <link href="https://koufuchi.github.io/2023/04/25/Codility/CodilityLessonMaxCounters/"/>
    <id>https://koufuchi.github.io/2023/04/25/Codility/CodilityLessonMaxCounters/</id>
    <published>2023-04-25T15:03:41.000Z</published>
    <updated>2023-09-01T06:37:51.620Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/codility.png" alt=""></p><h5 id="題目："># 題目：</h5><p><a href="https://app.codility.com/programmers/lessons/4-counting_elements/max_counters/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給一個由 N 個整數組成的陣列 A 以及一個整數 M，你必須照順序遍歷 A 並執行以下判斷，之後返回結果陣列 R (包含 M 個整數) :</p><ul><li>當遍歷到 A[K]=X，且 1 ≤ X ≤ N 時，結果陣列 R[K-1] 的值要加 1。</li><li>當遍歷到的 A[K]=N+1，則 R 中所有元素值都必須統一成當前 R 的最大元素值。</li></ul><p>例如輸入 A=[3, 4, 4, 6, 1, 4, 4]，M=5 :</p><ol><li>當 K=0，A[K]=3，R[3-1] 要加 1，R 就變成 [0, 0, 1, 0, 0]</li><li>當 K=1，A[K]=4，R[4-1] 要加 1，R 就變成 [0, 0, 1, 1, 0]</li><li>當 K=2，A[K]=4，R[4-1] 要加 1，R 就變成 [0, 0, 1, 2, 0]</li><li>當 K=3，A[K]=6，R[6-1] 等於 M+1，R 所有元素要等於當前最大元素 2，所以 R 就變成 [2, 2, 2, 2, 2]</li><li>當 K=4，A[K]=1，R[1-1] 要加 1，R 就變成 [3, 2, 2, 2, 2]</li><li>當 K=5，A[K]=4，R[4-1] 要加 1，R 就變成 [3, 2, 2, 3, 2]</li><li>當 K=6，A[K]=4，R[4-1] 要加 1，R 就變成 [3, 2, 2, 4, 2]，因為遍歷完了，所以 R 已是答案。</li></ol><p>其實題目沒有要你遍歷，只是講計數規則，但這題不遍歷不能解，我覺得這樣寫題目說明應該比較好懂，如果你有想到不遍歷的方法歡迎在下方留言討論。</p><ul><li>N 和 M 都是範圍 [1~100000] 的整數。</li><li>陣列 A 裡的元素都是範圍 [1~N+1] 的整數。</li></ul></blockquote><h5 id="解法："># 解法：</h5><blockquote><p>最棘手的部分就在於「當 A[K]=N+1，R 中所有元素值都必須統一成當前 R 的最大元素值」，因為如果你要將 R 所有數字都即時更新成最大值的話，你的時間複雜度就會變成 O(N*M)，而這顯然不是最好的答案。</p><p>那麼如果我不要即時統一，而是只紀錄這個觸發要統一的事實，並在之後的點替換成最大值呢 ?<br>感覺是可行的方向，但要如何實現需要思考一下，我們會發現當你觸發統一時，假設當前 R 最大元素是 3，代表之後如果遇到小於 3 的元素就是尚未統一過的元素，而如果之後又觸發統一，且當前 R 最大元素變成 5，那麼之後遇到小於 5 的元素就是尚未統一過的元素，我們並不需要擔心他到底有沒有統一成 3 過了，因為反正他都比 5 小，我們不需要記錄他的所有歷程。</p><p>具體來說我們除了需要紀錄 R 的最大元素值 max 之外，還需要知道要統一的目標數字是多少，所以會需要另一個變數 needToAdd 來處理，有點像雙指標的概念，max 永遠紀錄最大值，而當觸發統一時 needToAdd 會即時跟上 max。</p><p>最後，因為有可能有 M 中的元素完全沒被加過，你沒辦法幫他處理統一，所以你還需要遍歷一次 M，將 M 沒被統一的值做統一，因此所需的時間複雜度就是 N 和 M 個只遍歷一次，為 O(N+M)。</p><p>這題在 Codility 算 medium，感覺確實比起其他 Lesson 更有挑戰一點，不過以體感來說應該還是只有 LeetCode 的 easy 難度而已。</p><ul><li>時間複雜度 O(N+M)</li><li>空間複雜度 O(M)</li></ul></blockquote><h5 id="PHP-程式碼："># PHP 程式碼：</h5><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/CountingElements/MaxCounters.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/CountingElements/MaxCountersTest.php">單元測試</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/codility.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;題目：&quot;&gt;# 題目：&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;https://app.codility.com/programmers/lessons/4-counting_e</summary>
      
    
    
    
    <category term="Codility" scheme="https://koufuchi.github.io/categories/Codility/"/>
    
    
    <category term="PHP" scheme="https://koufuchi.github.io/tags/PHP/"/>
    
    <category term="演算法" scheme="https://koufuchi.github.io/tags/%E6%BC%94%E7%AE%97%E6%B3%95/"/>
    
    <category term="Codility" scheme="https://koufuchi.github.io/tags/Codility/"/>
    
  </entry>
  
  <entry>
    <title>Codility Lesson PermCheck</title>
    <link href="https://koufuchi.github.io/2023/04/24/Codility/CodilityLessonPermCheck/"/>
    <id>https://koufuchi.github.io/2023/04/24/Codility/CodilityLessonPermCheck/</id>
    <published>2023-04-24T12:59:03.000Z</published>
    <updated>2023-09-01T06:37:51.620Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/codility.png" alt=""></p><h5 id="題目："># 題目：</h5><p><a href="https://app.codility.com/programmers/lessons/4-counting_elements/perm_check/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給一個包含 N 個元素的<strong>非空</strong>陣列 A。你必須檢查 A 中是否包含所有 1~N 的整數值且不重複(其實這有點廢話，因為當滿足包含所有 1~N 的整數時本來就不可能有重複)</p><p>例如輸入 A=[4, 1, 3, 2]，滿足所有 1~4 且不重複，所以回傳 1。<br>而如果輸入 A=[4, 1, 3]，不滿足所有 1~3 且不重複，所以回傳 0。</p><ul><li>N 是範圍 [1~100000] 的整數。</li><li>陣列 A 裡的所有元素都是範圍 [1~1000000000] 的整數</li></ul></blockquote><h5 id="解法："># 解法：</h5><blockquote><p>這邊容易疏忽的點應該是並不保證餵進來的陣列其值都不重複，所以你不能用等差數列來解，依然需要紀錄走了哪些合法值，所以空間複雜度只能 O(N)。</p><p>再來由於一樣要追求遍歷一次就做完，所以我們需要找到規律，能先檢查的就是當發生重複(也就是當前遍歷值是已記錄過得合法值)時可以直接回傳 0，也就表示如果成功遍歷完一次 A ，就能確保 A 是<strong>元素不重複</strong>的陣列，也就能確保當我們紀錄的<strong>不重複合法值陣列總數等同於其內部的最大元素值</strong>時，就代表符合需求。</p><p>因為有點饒舌所以用範例說明，當輸入 A=[4, 1, 3, 2] 時，我們遍歷一遍<strong>確保都不重複</strong>，並且會得到另一個不重複合法值陣列 B=[4, 1, 3, 2]，然後當 B 的元素總數 4 剛好等於他最大的元素 B[0]=4 時，就代表是正確的。</p><p>由於你邊遍歷就可以邊收集最大元素值了，所以總共只要遍歷一次就好。</p><ul><li>時間複雜度 O(N)</li><li>空間複雜度 O(N)</li></ul></blockquote><h5 id="PHP-程式碼："># PHP 程式碼：</h5><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/CountingElements/PermCheck.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/CountingElements/PermCheckTest.php">單元測試</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/codility.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;題目：&quot;&gt;# 題目：&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;https://app.codility.com/programmers/lessons/4-counting_e</summary>
      
    
    
    
    <category term="Codility" scheme="https://koufuchi.github.io/categories/Codility/"/>
    
    
    <category term="PHP" scheme="https://koufuchi.github.io/tags/PHP/"/>
    
    <category term="演算法" scheme="https://koufuchi.github.io/tags/%E6%BC%94%E7%AE%97%E6%B3%95/"/>
    
    <category term="Codility" scheme="https://koufuchi.github.io/tags/Codility/"/>
    
  </entry>
  
  <entry>
    <title>Codility Lesson FrogRiverOne</title>
    <link href="https://koufuchi.github.io/2023/04/24/Codility/CodilityLessonFrogRiverOne/"/>
    <id>https://koufuchi.github.io/2023/04/24/Codility/CodilityLessonFrogRiverOne/</id>
    <published>2023-04-24T12:23:10.000Z</published>
    <updated>2023-09-01T06:37:51.620Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/codility.png" alt=""></p><h5 id="題目："># 題目：</h5><p><a href="https://app.codility.com/programmers/lessons/4-counting_elements/frog_river_one/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給一個鍵為 N，值為 K 的<strong>非空</strong>陣列 A。其中 N 表示秒數，K 表示位置，也就是第 N 秒時會有樹葉掉落到位置 K 上。</p><p>題目還會給一個整數 X 表示終點，你必須找出最少第幾秒時 1~X 的位置上都會有落葉。</p><p>例如輸入 A=[1, 3, 1, 4, 2, 3, <strong>5</strong>, 4]， X=5。<br>最少在第 6 秒時會有樹葉掉落到位置 5，且位置 1~5 都有樹葉，所以答案為 6。</p><p>如果 1~X 永遠不可能都有樹葉的話，你必須回傳 -1。</p><ul><li>N 是範圍 [1~100000] 的整數。</li><li>陣列 A 裡的所有元素都是範圍 [1~X] 的整數</li></ul></blockquote><h5 id="解法："># 解法：</h5><blockquote><p>這題不像 <a href="/2023/04/14/Codility/CodilityLessonPermMissingElem/">PermMissingElem</a> 一樣可以用等差數列去減，因為樹葉掉落的位置可能會出現重複的，所以始終是必須記錄走過的不重複合法位置有哪些，空間複雜度最低只能 O(N)。</p><p>而由於我們有紀錄走過的不重複合法位置，所以可以得知當你剛好找到第 X 個不重複合法值時，他的時間就會是答案，總共只需遍歷一次。</p><ul><li>時間複雜度 O(N)</li><li>空間複雜度 O(N)</li></ul></blockquote><h5 id="PHP-程式碼："># PHP 程式碼：</h5><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/CountingElements/FrogRiverOne.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/CountingElements/FrogRiverOneTest.php">單元測試</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/codility.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;題目：&quot;&gt;# 題目：&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;https://app.codility.com/programmers/lessons/4-counting_e</summary>
      
    
    
    
    <category term="Codility" scheme="https://koufuchi.github.io/categories/Codility/"/>
    
    
    <category term="PHP" scheme="https://koufuchi.github.io/tags/PHP/"/>
    
    <category term="演算法" scheme="https://koufuchi.github.io/tags/%E6%BC%94%E7%AE%97%E6%B3%95/"/>
    
    <category term="Codility" scheme="https://koufuchi.github.io/tags/Codility/"/>
    
  </entry>
  
  <entry>
    <title>用 Homebrew 懶人切換 php 版本</title>
    <link href="https://koufuchi.github.io/2023/04/19/%E7%94%A8brew%E6%87%B6%E4%BA%BA%E5%88%87%E6%8F%9Bphp%E7%89%88%E6%9C%AC/"/>
    <id>https://koufuchi.github.io/2023/04/19/%E7%94%A8brew%E6%87%B6%E4%BA%BA%E5%88%87%E6%8F%9Bphp%E7%89%88%E6%9C%AC/</id>
    <published>2023-04-19T14:42:07.000Z</published>
    <updated>2023-09-01T06:37:51.622Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/default.png" alt=""></p><hr><aside>💡 適用於 mac os 且使用 Homebrew 管理 php 環境</aside><hr><h5 id="核心為以下兩行"># 核心為以下兩行 :</h5><pre><code class="language-bash">brew unlink php@7.3 brew link -f php@8.1</code></pre><h5 id="每次都要記很煩所以寫了個簡單-script"># 每次都要記很煩所以寫了個簡單 script :</h5><p><a href="https://github.com/Koufuchi/php_version_switcher">GitHub - Koufuchi/php_version_switcher</a></p><h5 id="用命令行移動到-script-所在目錄，執行以下語法並指定版本即可切換："># 用命令行移動到 script 所在目錄，執行以下語法並指定版本即可切換：</h5><pre><code class="language-bash">. ~/ps.sh 7.3  # 檔名自己取，執行時後面餵版本參數，如果參數錯誤則會列出你本機安裝的所有版本</code></pre><h5 id="或是真的超懶，就在-zshrc-中加入"># 或是真的超懶，就在 ~/.zshrc 中加入 :</h5><pre><code class="language-bash">export PATH=&quot;$PATH:/&lt;your script path&gt;/&quot;  # script 所在目錄</code></pre><h5 id="之後打開-terminal-後就直接輸入以下就好"># 之後打開 terminal 後就直接輸入以下就好 :</h5><pre><code class="language-bash"> ps.sh 7.3 </code></pre><p>注意所有指令都會跑去你指定的目錄對，所以其實不太推薦這樣玩</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/default.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;aside&gt;
💡 適用於 mac os 且使用 Homebrew 管理 php 環境
&lt;/aside&gt;
&lt;hr&gt;
&lt;h5 id=&quot;核心為以下兩行&quot;&gt;# 核心為以下兩行 :&lt;/</summary>
      
    
    
    
    <category term="自製工具" scheme="https://koufuchi.github.io/categories/%E8%87%AA%E8%A3%BD%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="PHP" scheme="https://koufuchi.github.io/tags/PHP/"/>
    
    <category term="Shell" scheme="https://koufuchi.github.io/tags/Shell/"/>
    
    <category term="Homebrew" scheme="https://koufuchi.github.io/tags/Homebrew/"/>
    
    <category term="macOS" scheme="https://koufuchi.github.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Codility Lesson PermMissingElem</title>
    <link href="https://koufuchi.github.io/2023/04/14/Codility/CodilityLessonPermMissingElem/"/>
    <id>https://koufuchi.github.io/2023/04/14/Codility/CodilityLessonPermMissingElem/</id>
    <published>2023-04-14T11:25:12.000Z</published>
    <updated>2023-09-01T06:37:51.621Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/codility.png" alt=""></p><h5 id="題目："># 題目：</h5><p><a href="https://app.codility.com/programmers/lessons/3-time_complexity/perm_missing_elem/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給一個由 N 個不同整數組成的陣列 A。該陣列包含 [1~(N+1)] 範圍內的整數，這表示正好缺少一個 [1~(N+1)] 的元素，你必須找出他。<br>例如輸入 A=[2, 3, 1, 5] ，答案應為 4。</p><ul><li>N 是範圍 [1~100000] 的整數。</li><li>陣列 A 裡的元素都是不重複的。</li><li>陣列 A 裡的元素都是範圍 [1~(N+1)] 的整數</li></ul></blockquote><h5 id="解法："># 解法：</h5><blockquote><p>也許你一開始會想到排序後遍歷，但排序需要 O(Nlog N)，所以顯然應該有更好的解法。</p><p>再來也許會想到定義一個鍵為 1~(N+1) 的結果陣列，只要遍歷到就從結果陣列中刪除，那麼最後剩下的那個就是答案，這樣的時間複雜度似乎已達標，但是空間是否能用得更少呢?</p><p>觀察題目可以發現 1~(N+1) 其實就是等差為 1 的等差數列，那麼我們其實一開始就可以預期他們的總和是多少了，只要用預期總和去減 A 的所有元素就能求解。<br>這邊需要注意的是公式不要套錯，因為題目其實有少給你 1 個元素，所以正確的長度和高度應是 A 的元素數量再 +1。</p><p>像這樣用公式解就能降低空間複雜度到 O(1)。<br><s>雖然題目主旨是時間複雜度</s></p><ul><li>時間複雜度 O(N)</li><li>空間複雜度 O(1)</li></ul></blockquote><h5 id="PHP-程式碼："># PHP 程式碼：</h5><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/TimeComplexity/PermMissingElem.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/TimeComplexity/PermMissingElemTest.php">單元測試</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/codility.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;題目：&quot;&gt;# 題目：&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;https://app.codility.com/programmers/lessons/3-time_compl</summary>
      
    
    
    
    <category term="Codility" scheme="https://koufuchi.github.io/categories/Codility/"/>
    
    
    <category term="PHP" scheme="https://koufuchi.github.io/tags/PHP/"/>
    
    <category term="演算法" scheme="https://koufuchi.github.io/tags/%E6%BC%94%E7%AE%97%E6%B3%95/"/>
    
    <category term="Codility" scheme="https://koufuchi.github.io/tags/Codility/"/>
    
  </entry>
  
  <entry>
    <title>Codility Lesson TapeEquilibrium</title>
    <link href="https://koufuchi.github.io/2023/04/14/Codility/CodilityLessonTapeEquilibrium/"/>
    <id>https://koufuchi.github.io/2023/04/14/Codility/CodilityLessonTapeEquilibrium/</id>
    <published>2023-04-14T11:25:12.000Z</published>
    <updated>2023-09-01T06:37:51.621Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/codility.png" alt=""></p><h5 id="題目："># 題目：</h5><p><a href="https://app.codility.com/programmers/lessons/3-time_complexity/tape_equilibrium/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給一個由 N 個不同整數組成的<strong>非空</strong>陣列 A。遍歷到 A 的任一非 0 索引 P 時，會將陣列分成 A[1], A[2],…, A[P−1] 以及 A[P]、A[P+1],…, A[N−1] 兩個部分，其<strong>差異</strong>指的就是這兩部分<strong>各自加總</strong>後相減的絕對值。</p><p>例如輸入 A=[3, 1, 2, 4, 3] 時，可能的 P 值就會是 1~4，且他們的差異會是:</p><ol><li>P = 1，差異 = |3 − 10| = 7   (3 vs 1+2+4+3)</li><li>P = 2，差異 = |4 − 9| = 5    (3+1 vs 2+4+3)</li><li>P = 3，差異 = |6 − 7| = 1</li><li>P = 4，差異 = |10 − 3| = 7</li></ol><p>你的方法必須能吃這個陣列，並返回其中最小的差異，以上述例子來看就是 1</p><ul><li>N 是範圍 [2~100000] 的整數。</li><li>陣列 A 裡的元素都是範圍 [-1000~1000] 的整數</li></ul></blockquote><h5 id="解法："># 解法：</h5><blockquote><p>這題敘述挺長的，有可能會一時不知道怎麼下手，但其實原則很簡單，就是一樣想辦法遍歷一次就做完。<br>我們會發現從 P 到 P+1 時，相當於右邊減去 A[P]，而左邊加上 A[P]，所以你能遍歷一次就找出所有差異值，<br>那麼只需要多一個變數來存最小差異值就好。</p><p>陷阱在於 [1000, -1000]，你如果沒處理好的話就會算出 0，但其實答案應該是 2000。</p><ul><li>時間複雜度 O(N)</li><li>空間複雜度 O(1)</li></ul></blockquote><h5 id="PHP-程式碼："># PHP 程式碼：</h5><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/TimeComplexity/TapeEquilibrium.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/TimeComplexity/TapeEquilibriumTest.php">單元測試</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/codility.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;題目：&quot;&gt;# 題目：&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;https://app.codility.com/programmers/lessons/3-time_compl</summary>
      
    
    
    
    <category term="Codility" scheme="https://koufuchi.github.io/categories/Codility/"/>
    
    
    <category term="PHP" scheme="https://koufuchi.github.io/tags/PHP/"/>
    
    <category term="演算法" scheme="https://koufuchi.github.io/tags/%E6%BC%94%E7%AE%97%E6%B3%95/"/>
    
    <category term="Codility" scheme="https://koufuchi.github.io/tags/Codility/"/>
    
  </entry>
  
  <entry>
    <title>Codility Lesson FrogJmp</title>
    <link href="https://koufuchi.github.io/2023/04/13/Codility/CodilityLessonFrogJmp/"/>
    <id>https://koufuchi.github.io/2023/04/13/Codility/CodilityLessonFrogJmp/</id>
    <published>2023-04-13T11:30:55.000Z</published>
    <updated>2023-09-01T06:37:51.620Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/codility.png" alt=""></p><h5 id="題目："># 題目：</h5><p><a href="https://app.codility.com/programmers/lessons/3-time_complexity/frog_jmp/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給三個變數，起點是 X，終點是 Y，每次移動距離是 D，需求出最少需要幾次 D 才能剛好抵達或超過終點。<br><s>題外話，為甚麼官方是寫 FrogJmp 而不是 FrogJump 啊。</s><br>例如輸入 X=10, Y=85, D=30，答案應為 3。</p><ul><li>X, Y, D 都是範圍 [1~1000000000] 的整數。</li><li>X &lt;= Y。</li></ul></blockquote><h5 id="解法："># 解法：</h5><blockquote><p>既然題目都歸類在 TimeComplexity 裡了，感覺就是注重效能的題目。<br>實際上也沒錯，看起來就是想騙人去用迴圈去每次減 D，因為這樣在 D 為 1 的時候你的時間複雜度就會提高到 Y-X。<br>而其實你根本只需要用 (Y-X)/D 再無條件進位就能達到答案，時間複雜度 O(1)。<br><s>根本就是小學數學題。</s></p><p>以前在面試時有遇過類似題目，面試官是說希望知道你在看起來秒殺的題目下會不會忽略掉甚麼才是最佳解。</p><ul><li>時間複雜度 O(1)</li><li>空間複雜度 O(1)</li></ul></blockquote><h5 id="PHP-程式碼："># PHP 程式碼：</h5><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/TimeComplexity/FrogJump.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/TimeComplexity/FrogJumpTest.php">單元測試</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/codility.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;題目：&quot;&gt;# 題目：&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;https://app.codility.com/programmers/lessons/3-time_compl</summary>
      
    
    
    
    <category term="Codility" scheme="https://koufuchi.github.io/categories/Codility/"/>
    
    
    <category term="PHP" scheme="https://koufuchi.github.io/tags/PHP/"/>
    
    <category term="演算法" scheme="https://koufuchi.github.io/tags/%E6%BC%94%E7%AE%97%E6%B3%95/"/>
    
    <category term="Codility" scheme="https://koufuchi.github.io/tags/Codility/"/>
    
  </entry>
  
  <entry>
    <title>Codility Lesson OddOccurrencesInArray</title>
    <link href="https://koufuchi.github.io/2023/04/12/Codility/CodilityLessonOddOccurrencesInArray/"/>
    <id>https://koufuchi.github.io/2023/04/12/Codility/CodilityLessonOddOccurrencesInArray/</id>
    <published>2023-04-12T12:05:32.000Z</published>
    <updated>2023-09-01T06:37:51.620Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/codility.png" alt=""></p><h5 id="題目："># 題目：</h5><p><a href="https://app.codility.com/programmers/lessons/2-arrays/odd_occurrences_in_array/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給一個非空陣列 A，包含了 N 個整數，索引從 0 開始。N 為奇數，其中除了唯一一個元素之外，其他每個元素都可以與陣列中另一個有相同值的元素配對，目的就是找出這個無法配對的元素。<br>例如輸入 A=[9, 3, 9, 3, 9, 7, 9]，答案應為 7。</p><ul><li>N 為範圍 [1~1000000] 的奇數。</li><li>陣列 A 的每個元素都是 [1~1000000000] 範圍內的整數。</li></ul></blockquote><h5 id="解法："># 解法：</h5><blockquote><p>光看題目第一時間其實想到 LeetCode 的 <a href="https://leetcode.com/problems/valid-parentheses/">20. Valid Parentheses</a>，那時是用 stack 解的，不過這題並沒有那麼複雜，不需要考慮開關符號的問題。</p><p>再來會想到的是記憶法，用數字種類當索引，用出現次數當值。當初會這樣想是因為題目的範例暗示了同個數字是可以出現超過 2 次的，於是潛意識想要知道每種數字出現幾次，這樣的優點是可以在時間和複雜度 O(N) 的情況下獲得完整資訊。</p><p>寫到一半才想到，目的只是要回傳那個沒有重複的值啊，我多做那麼沒用的事情幹嘛!</p><p>於是目標會希望改成只對 A 遍歷 1 次，且減少空間的用量，這時候就會發現我並不需要紀錄每種數字出現幾次，反正出現重複的就刪掉就好，因此空間用量值只會需要一個回傳陣列。<br>由於會需要知道回傳陣列是否已包含當前遍歷到的值，你仍需要以數字種類當索引才能保持每次查找的時間複雜度是 O(N)。<br>可以複習一下我的另一篇文章 : <a href="/2022/10/19/PHPArray/">PHP Array</a></p><p>時間和空間複雜度是一個<strong>估算</strong>用的參考，所以不管有沒有記憶數字出現幾次都是 O(N)，但身為工程師你應該會很清楚實際上到底程式執行的細節是什麼，以及當我的<strong>函式/方法已定義好要做 X，就不要浪費資源去多做用不到的 Y</strong>。</p><ul><li>時間複雜度 O(N)</li><li>空間複雜度 O(N) – 實際上最多存到 (N/2)+1，因為已保證只有一個元素不重複</li></ul></blockquote><h5 id="PHP-程式碼："># PHP 程式碼：</h5><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/Arrays/OddOccurrencesInArray.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/Arrays/OddOccurrencesInArrayTest.php">單元測試</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/codility.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;題目：&quot;&gt;# 題目：&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;https://app.codility.com/programmers/lessons/2-arrays/odd</summary>
      
    
    
    
    <category term="Codility" scheme="https://koufuchi.github.io/categories/Codility/"/>
    
    
    <category term="PHP" scheme="https://koufuchi.github.io/tags/PHP/"/>
    
    <category term="演算法" scheme="https://koufuchi.github.io/tags/%E6%BC%94%E7%AE%97%E6%B3%95/"/>
    
    <category term="Codility" scheme="https://koufuchi.github.io/tags/Codility/"/>
    
  </entry>
  
  <entry>
    <title>Codility Lesson CyclicRotation</title>
    <link href="https://koufuchi.github.io/2023/04/11/Codility/CodilityLessonCyclicRotation/"/>
    <id>https://koufuchi.github.io/2023/04/11/Codility/CodilityLessonCyclicRotation/</id>
    <published>2023-04-11T12:32:12.000Z</published>
    <updated>2023-09-01T06:37:51.620Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/codility.png" alt=""></p><h5 id="題目："># 題目：</h5><p><a href="https://app.codility.com/programmers/lessons/2-arrays/cyclic_rotation/">官網題目連結</a></p><blockquote><p>根據題目敘述，輸入整數陣列 A 和一個整數 K ，將<strong>每個</strong>陣列元素<strong>往右移</strong> K 次。<br>例如輸入 A=[3, 8, 9, 7, 6], K=3，答案應為 [9, 7, 6, 3, 8]。</p><ul><li>N 和 K 都是範圍 [0~100] 的整數。</li><li>陣列 A 的每個元素都是 [−1000~1000] 範圍內的整數。</li></ul><p>題目特別說專注在正確性而不是效能。</p></blockquote><h5 id="解法："># 解法：</h5><blockquote><p>共做 K 次，每次將陣列的最後一個元素改放到最前面即可。</p><p>由於 php array 的特性，用 array_pop() 取出最後一個元素為時間複雜度 O(1)，<br>但使用 array_unshift() 將元素放到最前面時，需要時間複雜度 O(N) 來保持索引順序，其中 N 為陣列元素數量。<br>可以複習一下我的另一篇文章 : <a href="/2022/10/19/PHPArray/">PHP Array</a></p><ul><li>時間複雜度 O(N * K)</li><li>空間複雜度 O(N) / O(N * K) – 我不確定重複的 array_unshift() 會不會用到相同的空間來搬移陣列，之後可以實驗</li></ul></blockquote><h5 id="PHP-程式碼："># PHP 程式碼：</h5><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/Arrays/CyclicRotation.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/Arrays/CyclicRotationTest.php">單元測試</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/codility.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;題目：&quot;&gt;# 題目：&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;https://app.codility.com/programmers/lessons/2-arrays/cyc</summary>
      
    
    
    
    <category term="Codility" scheme="https://koufuchi.github.io/categories/Codility/"/>
    
    
    <category term="PHP" scheme="https://koufuchi.github.io/tags/PHP/"/>
    
    <category term="演算法" scheme="https://koufuchi.github.io/tags/%E6%BC%94%E7%AE%97%E6%B3%95/"/>
    
    <category term="Codility" scheme="https://koufuchi.github.io/tags/Codility/"/>
    
  </entry>
  
</feed>
