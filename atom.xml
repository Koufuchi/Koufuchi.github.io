<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Koufuchi&#39;s blog</title>
  
  
  <link href="https://koufuchi.com/atom.xml" rel="self"/>
  
  <link href="https://koufuchi.com/"/>
  <updated>2023-12-27T06:04:38.407Z</updated>
  <id>https://koufuchi.com/</id>
  
  <author>
    <name>Koufuchi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用 Multipass 和 K3s 建立 K8s 集群</title>
    <link href="https://koufuchi.com/Kubernetes/MultipassK3sK8s/"/>
    <id>https://koufuchi.com/Kubernetes/MultipassK3sK8s/</id>
    <published>2023-12-26T12:31:11.000Z</published>
    <updated>2023-12-27T06:04:38.407Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言：">前言：</h3><p>本文的目標為在 macOS 上開兩個 ubuntu 虛擬機並將他們納入 Kubernetes 環境，且可從 macOS 本機連接。</p><ul><li>Multipass : 在 macOS 快速建立 ubuntu 虛擬機。</li><li>K3s : 輕量化的 K8s(Kubernetes)。</li></ul><h3 id="安裝-kubectl：">安裝 kubectl：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install kubectl</span><br></pre></td></tr></table></figure><h3 id="安裝-Multipass：">安裝 Multipass：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install multipass --cask</span><br></pre></td></tr></table></figure><h3 id="創建兩台虛擬機：">創建兩台虛擬機：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multipass launch --name k8s-server --mem 1G --disk 5G --cpus 1</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multipass launch --name k8s-worker --mem 1G --disk 5G --cpus 1</span><br></pre></td></tr></table></figure><h3 id="檢查虛擬機狀態順便記下-IP-後面會用到：">檢查虛擬機狀態順便記下 IP 後面會用到：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multipass list</span><br></pre></td></tr></table></figure><h3 id="在-server-虛擬機上安裝-k3s：">在 server 虛擬機上安裝 k3s：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multipass shell k8s-server</span><br><span class="line"></span><br><span class="line">curl -sfL https://get.k3s.io | sh -</span><br></pre></td></tr></table></figure><h3 id="複製-server-虛擬機上的設定：">複製 server 虛擬機上的設定：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/rancher/k3s/k3s.yaml</span><br></pre></td></tr></table></figure><h3 id="回到本機，將剛剛複製完的設定貼進本機設定檔：">回到本機，將剛剛複製完的設定貼進本機設定檔：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.kube/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或是</span></span><br><span class="line">vim /Users/&lt;userName&gt;/.kube/config</span><br></pre></td></tr></table></figure><h3 id="貼上之後記得將本機設定檔裡的-cluster-的-server-位置改成-server-虛擬機-IP：">貼上之後記得將本機設定檔裡的 cluster 的 server 位置改成 server 虛擬機 IP：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意要 s 和指定 6443 port</span></span><br><span class="line">server: https://&lt;your_server_node_ip&gt;:6443</span><br></pre></td></tr></table></figure><h3 id="本機輸指令確認是否成功：">本機輸指令確認是否成功：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line">kubectl cluster-info</span><br></pre></td></tr></table></figure><h3 id="印出-server-虛擬機的-node-token，待會用到：">印出 server 虛擬機的 node-token，待會用到：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multipass <span class="built_in">exec</span> k8s-server sudo <span class="built_in">cat</span> /var/lib/rancher/k3s/server/node-token</span><br></pre></td></tr></table></figure><h3 id="在-worker-虛擬機上安裝-K3s-並加入集群：">在 worker 虛擬機上安裝 K3s 並加入集群：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multipass shell k8s-worker</span><br><span class="line"></span><br><span class="line">curl -sfL https://get.k3s.io | K3S_URL=https://&lt;your_server_node_ip&gt;:6443 K3S_TOKEN=<span class="string">&quot;&lt;your_server_node_token&gt;&quot;</span> sh -</span><br></pre></td></tr></table></figure><h3 id="回到本機輸指令確認是否成功：">回到本機輸指令確認是否成功：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes -owide</span><br></pre></td></tr></table></figure><p>參考：<br><a href="https://geekhour.net/2023/12/23/kubernetes/">Kubernetes一小時入門課程</a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言：&quot;&gt;前言：&lt;/h3&gt;
&lt;p&gt;本文的目標為在 macOS 上開兩個 ubuntu 虛擬機並將他們納入 Kubernetes 環境，且可從 macOS 本機連接。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Multipass : 在 macOS 快速建立 ubuntu 虛擬機。</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://koufuchi.com/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="https://koufuchi.com/tags/Kubernetes/"/>
    
    <category term="K8s" scheme="https://koufuchi.com/tags/K8s/"/>
    
    <category term="Multipass" scheme="https://koufuchi.com/tags/Multipass/"/>
    
  </entry>
  
  <entry>
    <title>使用 conda 管理 python 開發環境</title>
    <link href="https://koufuchi.com/Python/conda/"/>
    <id>https://koufuchi.com/Python/conda/</id>
    <published>2023-11-22T12:02:41.000Z</published>
    <updated>2023-12-27T06:02:18.520Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言：">前言：</h3><p>我過往在開發自製小工具的時候都會採用 python，因為語法簡潔，也有很多別人寫好的套件可以用，但為了快速所以本機環境都沒認真管控。由於最近接手公司的 python 專案，覺得要認真建置一下開發環境了。</p><blockquote><p>本文的範例都是基於 macOS 的。</p></blockquote><h3 id="安裝-conda：">安裝 conda：</h3><p>conda 是一個與語言無關的跨平台環境管理器，定位會類似於 apt 或 yum，可以方便管理各種包。<br>要安裝 conda 可以使用 Anaconda 或 Miniconda 來輕鬆安裝，由於後者比較輕量，所以我是用後者:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install --cask miniconda</span><br></pre></td></tr></table></figure><p>安裝完後可以用 <code>conda -V</code> 確認一下。<br><img src="/images/checkCondaVision.png" alt=""></p><h3 id="使用-conda-管理虛擬環境：">使用 conda 管理虛擬環境：</h3><p>虛擬環境的好處在於你可以切出不同的語言版本和不同的套件，而不需要擔心不同專案間的環境衝突或冗余套件。<br>在虛擬環境中可以自由使用 pip 安裝套件，作用範圍僅限當下的虛擬環境。</p><ol><li>創建虛擬環境: <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name &lt;env_name&gt; python=&lt;version&gt;</span><br></pre></td></tr></table></figure></li><li>查看虛擬環境列表: <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="built_in">env</span> list</span><br></pre></td></tr></table></figure></li><li>啟動虛擬環境: <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> activate &lt;env_name&gt;</span><br></pre></td></tr></table></figure></li><li>離開虛擬環境: <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> deactivate</span><br></pre></td></tr></table></figure></li><li>刪除虛擬環境: <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="built_in">env</span> remove --name &lt;env_name&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="在-VSCode-中使用-conda-虛擬環境：">在 VSCode 中使用 conda 虛擬環境：</h3><ol><li>選取解譯器：<ul><li>在 VSCode 中按下快捷鍵 <code>⌘ + Shift + P</code> 開啟「命令選擇區」，然後輸入 Select Interpreter，就可以在列表中選擇 conda 的虛擬環境。</li><li>如果已經開啟 python 專案，則也可以在右下角的工具列直接找到。</li></ul></li><li>開啟終端機：<ul><li>在 VSCode 中按下快捷鍵 <code>ctrl + ~</code> 叫出終端機，如果前面有選擇過解譯器的話就會直接進入該虛擬環境中囉。如果發現還是 base 的話可以按 Enter 或叫一個新的終端機自動進入。</li></ul></li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言：&quot;&gt;前言：&lt;/h3&gt;
&lt;p&gt;我過往在開發自製小工具的時候都會採用 python，因為語法簡潔，也有很多別人寫好的套件可以用，但為了快速所以本機環境都沒認真管控。由於最近接手公司的 python 專案，覺得要認真建置一下開發環境了。&lt;/p&gt;
&lt;blockquo</summary>
      
    
    
    
    <category term="Python" scheme="https://koufuchi.com/categories/Python/"/>
    
    
    <category term="Python" scheme="https://koufuchi.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>禁用 Linux 的密碼登入改用 ssh 憑證連線</title>
    <link href="https://koufuchi.com/Linux/ReplacePasswordWithSSH/"/>
    <id>https://koufuchi.com/Linux/ReplacePasswordWithSSH/</id>
    <published>2023-11-21T07:51:39.000Z</published>
    <updated>2023-11-21T09:44:18.632Z</updated>
    
    <content type="html"><![CDATA[<h2 id="緣由">緣由 :</h2><p>用密碼登入代表有可能會有洩漏或被暴力破解等等的隱憂，所以可以改用<a href="https://zh.wikipedia.org/zh-tw/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86">非對稱式加密</a>的 ssh 來保證安全，<s>也可以幫助懶人不用每次都要打密碼</s>。</p><h2 id="作法">作法 :</h2><h3 id="1-本機產生-ssh-金鑰對：">1. 本機產生 ssh 金鑰對：</h3><p>如果你是 Unix/Linux 或 macOS，可以直接使用以下指令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></table></figure><p>如果你是 Ubuntu 或 Debian 又缺少這個工具，則需要先用指令安裝套件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openssh-client</span><br></pre></td></tr></table></figure><p>如果成功會在你的帳戶家目錄下產生 <code>.ssh</code> 目錄，裡面有私鑰 <code>id_rsa</code> 和公鑰 <code>id_rsa.pub</code>，請記住私鑰絕對不要外洩。</p><h3 id="2-推送金鑰到你的機器上：">2. 推送金鑰到你的機器上：</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id &lt;username&gt;@&lt;remote_ip&gt; </span><br></pre></td></tr></table></figure><p>如果成功則會在你的機器的該帳號家目錄下產生 <code>.ssh/authorized_keys</code>。<br>或你也可以手動創建該目錄檔案並貼入公鑰 <code>id_rsa.pub</code> 的內容。<br>成功後記得確保 .ssh 和 authorized_keys 都是 <code>755</code> 權限。</p><h3 id="3-修改你的機器設定：">3. 修改你的機器設定：</h3><p>先打開設定檔案：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ssh/ssfd_config</span><br></pre></td></tr></table></figure><p>在裡面找到以下設定並修改其值:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">port 22  <span class="comment"># ssh 監聽端口，你可以改成自己喜歡的，但要注意防火墻不能擋。</span></span><br><span class="line">PubkeyAuthentication <span class="built_in">yes</span></span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys</span><br><span class="line">PasswordAuthentication No  <span class="comment"># 設為 No 後會禁止用密碼登入</span></span><br></pre></td></tr></table></figure><p>修改完設定後要重啟 ssh 服務:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart sshd</span><br></pre></td></tr></table></figure><p>通常這些做完就可以免密碼用 ssh 連線了。</p><h2 id="意外">意外 :</h2><p>如果你的機器是用雲端伺服器代理商的話，很有可能上面步驟都做完後還是有問題。<br>以 <code>Vultr</code> 為例，發現登入時他還是會要你輸入密碼。<br>使用以下指令檢查:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sshd -T |grep pass</span><br></pre></td></tr></table></figure><p>發現 <code>passwordauthentication</code> 還是 <code>yes</code>，代表系統並沒有吃到剛剛的設定。<br>原因是 Vultr 另外有 <code>sshd_config.d/50-cloud-init.conf</code>，裡面就有 <code>PubkeyAuthentication yes</code> 的內容，<br>而系統在執行時會先讀取 <code>ssfd_config</code> 後才讀取 <code>50-cloud-init.conf</code>，就導致你的設定被覆蓋掉了，解決方法就是直接修改 <code>50-cloud-init.conf</code> 再重啟服務。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;緣由&quot;&gt;緣由 :&lt;/h2&gt;
&lt;p&gt;用密碼登入代表有可能會有洩漏或被暴力破解等等的隱憂，所以可以改用&lt;a href=&quot;https://zh.wikipedia.org/zh-tw/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%</summary>
      
    
    
    
    <category term="Linux" scheme="https://koufuchi.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://koufuchi.com/tags/Linux/"/>
    
    <category term="ssh" scheme="https://koufuchi.com/tags/ssh/"/>
    
    <category term="security" scheme="https://koufuchi.com/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>用 Certbot 來自動幫你的網站申請 &amp; 更新免費的 Let&#39;s Encrypt SSL 憑證吧 !</title>
    <link href="https://koufuchi.com/Nginx/nginxCertbotLetsencrypt/"/>
    <id>https://koufuchi.com/Nginx/nginxCertbotLetsencrypt/</id>
    <published>2023-09-05T02:21:41.000Z</published>
    <updated>2023-11-21T09:41:20.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="為何需要-SSL-憑證">為何需要 SSL 憑證 :</h2><p>你是否有注意過網址有分成 <code>http</code> 和 <code>https</code> 呢？</p><ul><li>HTTP (HyperText Transfer Protocol)</li><li>HTTPS (HyperText Transfer Protocol <mark class="hl-label orange">Secure</mark> )</li></ul><p>很明顯的，他們的差距就在於<code>安全性</code>，當你訪問 http 的網站時，瀏覽器會跳出非安全連線的提示，這是因為 http 封包是用明文傳遞資訊，很容易被截取，所以需要用 SSL/TLS 這樣的非對稱式加密來保證資訊安全，這些協議使用公開密鑰和私有密鑰來加密通信，確保只有發送方和接收方能夠解密和讀取數據。</p><p>不過這樣還不夠，瀏覽器只信任第三方機構（Certificate Authority，簡稱CA）發布的數位憑證，如果你使用了自簽名的憑證，瀏覽器仍會跳出非安全連線的提示。</p><p>那麼，為什麼瀏覽器只信任 CA 頒發的憑證呢？這是因為 CA 在頒發數位憑證前會驗證該網站的身份，他會核實網站所有者的身份和控制權，這樣可以有效防止<a href="https://zh.wikipedia.org/zh-tw/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB">中間人攻擊</a>。</p><h2 id="什麼是-Let’s-Encrypt">什麼是 Let’s Encrypt :</h2><p>如同前面提到的，我們需要向 CA 請求頒發數位憑證，而其中一間最知名又免費的 CA 機構就是 <a href="https://letsencrypt.org/zh-tw/">Let’s Encrypt</a>，可以通過 ACME 協議自動化的完成證書申請和更新，且幾乎所有主要網頁瀏覽器和操作系統都信任 Let’s Encrypt 的證書。</p><p>可以參考<a href="https://letsencrypt.org/docs/certificate-compatibility/">官方列出的可相容系統</a>。</p><h2 id="什麼是-Certbot">什麼是 Certbot :</h2><p>Certbot 是一個免費且開源的工具，用於自動化管理 SSL/TLS 證書的申請、安裝、更新和配置。他是 Let’s Encrypt 計畫的官方客戶端，旨在簡化網站擁有者獲取和管理 HTTPS 加密的過程。</p><p>簡單來說，你可以透過 Certbot 來申請和更新 Let’s Encrypt 憑證。</p><p>Certbot 有提供很多做法來取得憑證：</p><table><thead><tr><th>作法</th><th>指令</th></tr></thead><tbody><tr><td>全自動 (自備 HTTP 伺服器)</td><td>– certbot</td></tr><tr><td>半自動（自備 HTTP 伺服器，不調整 HTTP 伺服器設定）</td><td>– certbot certonly</td></tr><tr><td>webroot（自備 HTTP 伺服器，自行設定 acme-challenge 部分）</td><td>– certbot certonly --webroot</td></tr><tr><td>手動（自備 HTTP 伺服器 、其他主機）</td><td>– certbot certonly --manual</td></tr><tr><td>DNS 套件</td><td>– certbot certonly --dns-PLUGIN</td></tr><tr><td>Standalone（Certbot 提供獨立 HTTP 伺服器部分）</td><td>– certbot certonly --standalone</td></tr></tbody></table><h2 id="什麼是-nginx">什麼是 nginx :</h2><p>nginx 是一個輕量級的<code>反向代理伺服器</code>，你可以用它來監聽你的指定 port，並將來源請求導向至你對應設定的地方。<br>例如你可以在 <mark class="hl-label orange">A機器</mark>  上設定一個 server 區塊來監聽 80 port + <a href="http://test.com">test.com</a>，則所有打到 <mark class="hl-label orange">A機器</mark>  的 80 port 且 domain 為 <a href="http://test.com">test.com</a> 的請求都會適用於這個區塊的設定，你可以做些不同的動作，然後導向至 A 機器其他地方抑或是其他 BCD 機器。</p><p>詳細教學會需要另外開一篇文章，此篇僅簡單概述。</p><h2 id="使用教學">使用教學 :</h2><p>本次範例中我只會示範用 webroot 的做法，並且都採用 docker 來設定。</p><p>前置作業：</p><ul><li>你需要在你的機器上自行下載 docker 和 docker-compose。</li><li>你需要有一個自己的域名，且 DNS 設定是對應到你當前要跑 certbot 的機器上。</li></ul><p>以結論來說，我們會定義兩個容器，一個是 nginx，一個是 certbot，certbot 只有在取得和更新憑證時啟動，nginx 則是永遠保持運作並使用 ssl 憑證來轉向給背後指定的服務。</p><h3 id="1-nginx-conf">1. nginx.conf</h3><p>首先，在你的專案根目錄新增一個 config 目錄，並在裡面新增一個 nginx.conf 後寫入以下內容：<br>有關 nginx 的目錄結構和語法就不多贅述了。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx worker process 的數量，通常設定為 CPU 的核心數量</span></span><br><span class="line"><span class="attribute">worker_processes</span> <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">512</span>;  <span class="comment"># 每個 worker process 所能處理的連線數量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">1M</span>;  <span class="comment"># 單次 request 超過指定用量則中斷連線</span></span><br><span class="line">    <span class="attribute">server_tokens</span> <span class="literal">off</span>;  <span class="comment"># 關閉 nginx 的版本資訊</span></span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;  <span class="comment"># listen port</span></span><br><span class="line">        <span class="attribute">listen</span> [::]:<span class="number">80</span>;  <span class="comment"># listen Ipv6 port</span></span><br><span class="line">        <span class="attribute">server_name</span> your.domain.com  <span class="comment"># listen domain name，為了好理解才加.com，你要填你自己的</span></span><br><span class="line"></span><br><span class="line">        location /.well-known/acme-challenge/ &#123;  <span class="comment"># Let&#x27;s Encrypt 驗證用</span></span><br><span class="line">            <span class="attribute">allow</span> all;</span><br><span class="line">            <span class="attribute">root</span> /tmp/acme-challenge;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>;  <span class="comment"># 其餘的把 http 轉成 https</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 這裡是有憑證之後要導向指定服務的設定，但一開始還沒有憑證 nginx 會報錯所以先註解掉。</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">        <span class="comment">#listen 443 ssl;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#server_name your.domain.com; </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#ssl_certificate /etc/letsencrypt/live/your.domain.com/fullchain.pem;  # 指定伺服器所使用的 SSL/TLS 憑證</span></span><br><span class="line">        <span class="comment">#ssl_certificate_key /etc/letsencrypt/live/your.domain.com/privkey.pem;  # SSL/TLS 憑證的私鑰</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#location / &#123;</span></span><br><span class="line">            <span class="comment">#proxy_pass https://ip.address  # 指定服務的 ip</span></span><br><span class="line">            <span class="comment">#proxy_set_header Host $host;</span></span><br><span class="line">            <span class="comment">#proxy_set_header X-Real-IP $remote_addr;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Dockerfile">2. Dockerfile</h3><p>在你的 config 目錄下新增 Dockerfile 並寫入以下內容。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx:<span class="number">1.24</span>.<span class="number">0</span>-alpine  <span class="comment"># 使用 docker hub 的官方映像檔</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">rm</span> /etc/nginx/conf.d/default.conf  <span class="comment"># 刪除原本的預設檔</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./nginx.conf /etc/nginx/nginx.conf  <span class="comment"># 將剛剛創建的 nginx.conf 檔案複製到容器對應的目錄</span></span></span><br></pre></td></tr></table></figure><h3 id="3-docker-compose-yml">3. docker-compose.yml</h3><p>回到你的專案根目錄，新增 docker-compose.yml 檔案並寫入以下內容 :</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span> <span class="comment"># 不同版本有不同語法規範，請參考官網</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">&quot;nginx_server&quot;</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">./config</span>  <span class="comment"># 設定用剛剛創建的 Dcokerfile 來啟動</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">443</span><span class="string">:443</span></span><br><span class="line">    <span class="attr">volumes:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config:/config</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/letsencrypt:/etc/letsencrypt:ro</span>  <span class="comment"># 等 certbot 拿完憑證會放這裡，所以要讓容器共用。</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/tmp/acme-challenge:/tmp/acme-challenge</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">letsencrypt:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">&quot;certbot&quot;</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">certbot/certbot:v2.6.0</span>  <span class="comment"># 指定用官方映像檔</span></span><br><span class="line">    <span class="comment"># 拿 SSL 憑證，注意替換 domain 和 email</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">-c</span> <span class="string">&quot;certbot certonly --webroot -w /tmp/acme-challenge/ </span></span><br><span class="line"><span class="string">                    -d &quot;</span><span class="string">your.domain.com&quot;</span> <span class="string">--text</span> <span class="string">--agree-tos</span> </span><br><span class="line">                    <span class="string">--email</span> <span class="string">your@email</span> <span class="string">--rsa-key-size</span> <span class="number">4096</span> <span class="string">--verbose</span> </span><br><span class="line">                    <span class="string">--keep-until-expiring</span> <span class="string">--preferred-challenges=http&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/etc/letsencrypt:/etc/letsencrypt&quot;</span>  <span class="comment"># 等 certbot 拿完憑證會放這裡，所以要讓容器共用。</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/tmp/acme-challenge:/tmp/acme-challenge&quot;</span></span><br><span class="line">    <span class="attr">environment:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">TERM=xterm</span>  <span class="comment"># 讓容器內的程式或命令知道如何與終端機互動，例如 vim 或變色等等。</span></span><br></pre></td></tr></table></figure><h3 id="4-啟動-nginx-容器">4. 啟動 nginx 容器</h3><p>CA 會打到 DNS 對應 IP 進行審核，所以要先啟動 nginx 容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up --build -d nginx </span><br></pre></td></tr></table></figure><h3 id="5-啟動-certbot-容器來拿憑證">5. 啟動 certbot 容器來拿憑證</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up --build letsencrypt</span><br></pre></td></tr></table></figure><h3 id="6-配置你的憑證檔案">6. 配置你的憑證檔案</h3><p>回到你的 config/nginx.conf，把剛剛因為沒有憑證會報錯而註解掉的地方取消註解。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up --build -d nginx</span><br></pre></td></tr></table></figure><p>如此一來就大功告成了，之後要更新憑證就啟動 certbot 容器就好。</p><h2 id="自動化腳本">自動化腳本 :</h2><p><s>作為懶人工程師當然要自動化啊，誰會想每次都記得手動跑更新！</s><br>到你的專案根目錄下新增 <a href="http://getSSL.sh">getSSL.sh</a> 並寫入以下內容 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定專案路徑</span></span><br><span class="line">PROJECT_PATH=<span class="string">&quot;/your/project/path&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定日誌文件的路徑和名稱 </span></span><br><span class="line">LOG_FILE=<span class="string">&quot;<span class="variable">$PROJECT_PATH</span>/log/getSSL.log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fn：給訊息，寫入日誌文件</span></span><br><span class="line"><span class="function"><span class="title">log_message</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> message=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">    <span class="built_in">local</span> timestamp=<span class="string">&quot;<span class="subst">$(date +&#x27;%Y-%m-%d %H:%M:%S&#x27;)</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    sudo <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$timestamp</span>: <span class="variable">$message</span>&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$LOG_FILE</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log_message <span class="string">&quot;Starting letsencrypt container&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拿 SSL 憑證</span></span><br><span class="line">sudo docker-compose run --<span class="built_in">rm</span> letsencrypt &gt;&gt; <span class="string">&quot;<span class="variable">$LOG_FILE</span>&quot;</span> 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有帶關鍵字就多設定排程</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;--schedule&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    log_message <span class="string">&quot;Setting up crontab job&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 設定腳本路徑和排程時間</span></span><br><span class="line">    CRON_SCHEDULE=<span class="string">&quot;0 0 * * 1&quot;</span></span><br><span class="line">    CRON_FILENAME=<span class="string">&quot;getSSL.sh&quot;</span></span><br><span class="line">    (crontab -l ; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$CRON_SCHEDULE</span> cd <span class="variable">$PROJECT_PATH</span>; ./<span class="variable">$CRON_FILENAME</span> &quot;</span>) | sudo crontab -</span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">log_message <span class="string">&quot;Stopping letsencrypt container&quot;</span></span><br></pre></td></tr></table></figure><p><code>記得把檔案權限設為可執行</code>，然後到專案目錄執行以下：</p><div class="tabs" id="getssh"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#getssh-1">單次更新</button></li><li class="tab"><button type="button" data-href="#getssh-2">設定排程</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="getssh-1"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./getSSL.sh</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="getssh-2"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./getSSL.sh --schedule</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p><s>啊如果你是 windows 或其他有的沒有 OS 我也懶得一個一個找，就照這個概念去換語法就好。</s></p><h2 id="參考">參考</h2><ul><li><a href="https://dev.to/mrshanas/https-on-docker-containers-using-nginx-and-letsencrypt-3nfa">HTTPS on Docker Containers using Nginx and LetsEncrypt</a></li><li><a href="https://yowlab.idv.tw/wordpress/?p=1390">使用 Certbot 來為網站申請 Let’s Encrtpt 憑證 (CentOS 7)</a></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;為何需要-SSL-憑證&quot;&gt;為何需要 SSL 憑證 :&lt;/h2&gt;
&lt;p&gt;你是否有注意過網址有分成 &lt;code&gt;http&lt;/code&gt; 和 &lt;code&gt;https&lt;/code&gt; 呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP (HyperText Transfer Prot</summary>
      
    
    
    
    <category term="Nginx" scheme="https://koufuchi.com/categories/Nginx/"/>
    
    
    <category term="Shell" scheme="https://koufuchi.com/tags/Shell/"/>
    
    <category term="Nginx" scheme="https://koufuchi.com/tags/Nginx/"/>
    
    <category term="Certbot" scheme="https://koufuchi.com/tags/Certbot/"/>
    
    <category term="Let&#39;s Encrypt" scheme="https://koufuchi.com/tags/Let-s-Encrypt/"/>
    
    <category term="Docker" scheme="https://koufuchi.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>快取的一致性難題與架構模式 (下)</title>
    <link href="https://koufuchi.com/Cache/CacheConsistencyMeta/"/>
    <id>https://koufuchi.com/Cache/CacheConsistencyMeta/</id>
    <published>2023-09-03T15:38:54.000Z</published>
    <updated>2023-11-21T09:49:21.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Meta-是怎麼做的？">Meta 是怎麼做的？</h2><blockquote><ul><li>讀：和 Read aside 一樣。先從 Cache 讀，讀到就回，沒讀到就從 DB 讀然後寫回 Cache。</li><li>寫：先寫回 DB，接著清掉 Cache</li></ul><p>讀寫和 Read aside 一樣，但對 Cache 的操作採用版本控制及 Polaris 系統實作</p></blockquote><h2 id="版本控制">版本控制 :</h2><blockquote><p>所有對 Cache 寫入的請求字段要附加版本資訊</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 依收到請求的時間排序</span><br><span class="line">SET x=1 @VERSION=1 </span><br><span class="line">SET x=12345 @VERSION=3 (先到，所以先寫入) </span><br><span class="line">SET x=45678 @VERSION=2 (無效，因為剛剛已經先寫版本3了，所以版本2比較低視為無效） </span><br></pre></td></tr></table></figure><p>缺點：若在 v2 的請求到達之前 v3 的資料就先被清除，v2 就會被成功寫入</p></blockquote><h2 id="Polaris">Polaris :</h2><blockquote><p>是一個基於 Multi-Paxos 演算法實作的系統。</p><p><img src="/images/polaris.webp" alt=""></p><p>Polaris 是獨立的監控服務。<br>如上圖，當 DB 某資料更新成 x=4 後，會發請求告訴所有 Cache “x=4 @version 4” 的失效事件(invalidation event)，表示跟 “x=4 @version 4” 不同的快取已失效，而這時 Polaris 會和其他 Cache 一起收到同樣的請求。</p><p>接著，Polaris 會去查詢其他 Cache 以便確認他們是否已經更新完成。</p><p>假如其中一台 Cache 返回 “x=3 @version 3”， 則 Polaris 會將這台 Cache 標記為不一致，並將這次檢查重新排隊，以便待會再重新檢查一次。<br>有個特別的地方在於 Polaris 的不一致回報會有 1, 5, 10分鐘內的不同時間尺度，當發現某個 cache 持續 1 分鐘以上不一致後，Polaris 會將此報告歸類為 5 分鐘內的不一致。</p><p>以 Polaris 的角度來看，當收到不一致的回報時，可能會有不同的情況，例如：<br>Polaris 收到 “x=4 @version 4” 的失效事件，但是當它查詢 Cache A 時，A 的回覆是 “x” 不存在 。</p><ul><li>狀況1：x 的 v3 是不可視(invisible)，而 v4 是對 x 的最新寫入，所以 Cache A 為不一致。</li><li>狀況2：x 的 v5 是刪除 x，所以 Polaris 在 v4 還沒檢查完的情況下，Cache A 就已經同步了 v5， 但並不是不一致。</li></ul><p>由於兩種狀況互斥，必須查詢 DB 才能區分是狀況1還是狀況2，但是對 DB 的操作成本是非常高的，所以這時候 Polaris 的時間尺度設計就派上用場。<br>由於真正的緩存不一致和對同一鍵的競速寫操作很少見，對 Cache 重新多做幾次確認就能過濾掉並非真正不一致的情況，而可以彈性設定成例如當 5 分鐘內都還是有不一致的狀況時，才對 DB 做查詢。</p><p>根據官方使用 Polaris 監測的數據，有 99.99999999% 的緩存寫入在五分鐘內是一致的。而在五分鐘後，100 億次緩存寫入中只有不到 1 次會出現不一致，這個有點饒舌的數據也是因為前面提到的時間尺度設計。</p></blockquote><h2 id="小結">小結 :</h2><blockquote><p>Meta 的部落格講了很多架構原理，也因此更能感受到一個高可用性的系統是如何的複雜且高成本，以一般小公司來說可能簡單的 Read Aside 就永遠不會遇到不一致的狀況了，所以終歸是需要依照尖峰的 QPS 和系統能力來判斷是否需要更進一步的拓展，這也是工程師經驗的價值所在。</p></blockquote><h2 id="參考">參考 :</h2><ul><li><a href="https://engineering.fb.com/2022/06/08/core-data/cache-invalidation/">官方技術部落格 Cache made consistent</a></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Meta-是怎麼做的？&quot;&gt;Meta 是怎麼做的？&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;讀：和 Read aside 一樣。先從 Cache 讀，讀到就回，沒讀到就從 DB 讀然後寫回 Cache。&lt;/li&gt;
&lt;li&gt;寫：先寫回 DB，接著清掉 C</summary>
      
    
    
    
    <category term="快取" scheme="https://koufuchi.com/categories/%E5%BF%AB%E5%8F%96/"/>
    
    
    <category term="Cache" scheme="https://koufuchi.com/tags/Cache/"/>
    
    <category term="系統架構" scheme="https://koufuchi.com/tags/%E7%B3%BB%E7%B5%B1%E6%9E%B6%E6%A7%8B/"/>
    
    <category term="Consistency" scheme="https://koufuchi.com/tags/Consistency/"/>
    
    <category term="MySQL" scheme="https://koufuchi.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>快取的一致性難題與架構模式 (中)</title>
    <link href="https://koufuchi.com/Cache/CacheConsistencyCanal/"/>
    <id>https://koufuchi.com/Cache/CacheConsistencyCanal/</id>
    <published>2023-05-07T12:58:29.000Z</published>
    <updated>2023-11-21T09:49:15.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阿里巴巴的開源專案-canal">阿里巴巴的開源專案 canal :</h2><blockquote><ul><li>讀：和 Read Aside 一樣。先從 Cache 讀，讀到就回，沒讀到就從 DB 讀然後寫回 Cache。</li><li>寫：只寫回 DB，canal 會從 DB 的 binlog 複製到 Cache (canal 扮演 Slave 的角色去監聽 binlog)。</li></ul><p>補充 : binlog 是 MySQL 二進位制格式的日誌，只要資料庫有操作，就會寫入 binlog。</p></blockquote><h2 id="MySQL-主從複製">MySQL 主從複製 :</h2><blockquote><p>在探討 canal 如何運作之前，我們必須先了解 MySQL 是如何達到主從複製的 :</p><p><img src="/images/MySQLMasterSlave.jpeg" alt=""></p><ol><li>Slave 產生 I/O thread 向 Master 請求 binlog。</li><li>Master 會產生一個 log dump thread，負責傳 binlog 給 Slave 的 I/O thread，而在讀取和發送<br>給 Slave 的過程中會將 binlog 上鎖。</li><li>Slave I/O thread 將得到的 binlog 日志<strong>寫入</strong> Relay log(中繼日誌) 文件中。</li><li>Slave 產生 SQL thread 讀取 Relay log 文件中的日誌，並<strong>解析</strong>成具體操作，這樣就能保證主從操作一致，即達成資料一致。</li></ol><p>你可能已經發現了他實際上還是會存在不一致的時間，至於具體是多久，可能的影響因素很多，包括網路如何連接、有多少個從機、採用什麼樣的主從架構和同步方式等等…。</p><p>大部分人給出的答案都是在同個 lan 下是瞬時的，因為採用獨立的 thread 和 socket 連接，且 binlog 是二進制文件，但是具體的數據官方也沒有提供，可能需要自己測試，可以架好環境後用 SHOW SLAVE STATUS 看 seconds_behind_master 的值。</p></blockquote><h2 id="canal-工作原理">canal 工作原理 :</h2><blockquote><p>如同上面提到的，MySQL 主從複製是一個成熟且使用者眾多的架構，他的目的也是為了解決分散式架構造成的一致性問題，所以如果我們能讓一個服務偽裝成 Slave 加入這個架構，就能直接沿用這個可靠的架構。</p><p><img src="/images/canal.png" alt=""></p><p>如上圖，canal 模擬 MySQL Slave 的交互協議，讓自己偽裝成 MySQL Slave，並向 MySQL Master 發送 dump 協議，之後 MySQL Master 收到 dump 請求，開始推送 binlog 给 Slave (即 canal)，之後 canal 再解析 binlog，就能再去同步到快取或是做其他事情。</p></blockquote><h2 id="小結">小結 :</h2><blockquote><p>canal 其實是基於 MySQL 解決一致性的方法作延伸來達成快取架構，但也代表其綁定了 MySQL，如果你是使用其他關聯式資料庫就不適用，可能需要另外找解法。</p><p>在之後的文章裡，我們會探討 Meta 是如何設計快取架構的，由於不是基於單一資料庫的延伸，他的架構會更加的複雜，以達到 99.99999999% 的快取寫入一致性。</p></blockquote><h2 id="參考">參考 :</h2><ul><li><a href="https://github.com/alibaba/canal">canal 官方開源</a></li><li><a href="https://github.com/xingwenge/canal-php">canal-php(基於 canal)</a></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;阿里巴巴的開源專案-canal&quot;&gt;阿里巴巴的開源專案 canal :&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;讀：和 Read Aside 一樣。先從 Cache 讀，讀到就回，沒讀到就從 DB 讀然後寫回 Cache。&lt;/li&gt;
&lt;li&gt;寫：只寫回</summary>
      
    
    
    
    <category term="快取" scheme="https://koufuchi.com/categories/%E5%BF%AB%E5%8F%96/"/>
    
    
    <category term="Cache" scheme="https://koufuchi.com/tags/Cache/"/>
    
    <category term="系統架構" scheme="https://koufuchi.com/tags/%E7%B3%BB%E7%B5%B1%E6%9E%B6%E6%A7%8B/"/>
    
    <category term="Consistency" scheme="https://koufuchi.com/tags/Consistency/"/>
    
    <category term="MySQL" scheme="https://koufuchi.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>快取的一致性難題與架構模式 (上)</title>
    <link href="https://koufuchi.com/Cache/CacheConsistency/"/>
    <id>https://koufuchi.com/Cache/CacheConsistency/</id>
    <published>2023-05-07T04:42:32.000Z</published>
    <updated>2023-11-21T09:49:09.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快取是什麼">快取是什麼 :</h2><blockquote><p>我們都知道電腦的核心運算是由 CPU 負責的，而我們的主要的資料儲存單元是硬碟，由於要在硬碟裡面搜尋資料並帶回來是一件時間成本極高的事，所以就有了<strong>將找過的資料暫存起來</strong>的概念，如下圖 :</p><p><img src="/images/cacheIO.png" alt=""></p><p>CPU 會先在 CPU Cache 裡尋找資料，當發現沒有之後就會去 main memory(DRAM) 找，再沒有才會去硬碟找。<br>找到之後就會一路寫回來，這樣你下次要找同樣資料時就不用再跑這麼遠去硬碟找。</p><p>我們之後會探討的快取就是 main memory(DRAM) 與硬碟的這一塊。</p></blockquote><h2 id="為什麼要使用快取">為什麼要使用快取 :</h2><blockquote><ol><li>DB 很慢 : 因為 RDBMS 需要保證 <a href="https://zh.wikipedia.org/zh-tw/ACID">ACID</a>，所以必須等待整個流程跑完。</li><li>DB 很貴 : 由於 RDBMS 的資料儲存在硬碟，會需要更多次 IO，上面已說明過。</li><li>DB 很遠 : 當你的 DB 建在新加坡，對於台灣用戶來說網路距離增加，傳輸速度也慢。</li></ol></blockquote><h2 id="為什麼快取會有一致性難題">為什麼快取會有一致性難題 :</h2><blockquote><p>如果你是分散式系統，那就一定逃不過 <a href="https://zh.wikipedia.org/zh-tw/CAP%E5%AE%9A%E7%90%86">CAP 定理</a>，但如果我只在單一台電腦上同時裝 Cache(ex. Redis) 和 DB(ex. MySQL)，還會有一致性難題嗎？讓我們接著以實作方式來探討。</p></blockquote><h2 id="快取模式-Read-Aside">快取模式 - Read Aside :</h2><blockquote><p><img src="/images/cacheReadAside.png" alt=""></p><ul><li>讀：先從 Cache 讀，讀到就回，沒讀到就從 DB 讀然後寫回 Cache。</li><li>寫：先寫回 DB，接著清掉 Cache。</li></ul><p>大部分情況都會正常，因為架構很簡單所以是常見的做法。<br>缺點為極端情況下不符合一致性，因為先對 DB 做事再去同步 Cache，所以同步前的時間差會導致非一致性。</p><ul><li>問題一 : A 寫了新資料，但還沒同步到 Cache 前 B 就去讀 Cache 的資料，導致不一致。</li></ul><p><img src="/images/cacheReadAsideProblem1.png" alt=""></p><ul><li>問題二 : A 寫了新資料，但要去同步到 Cache 時出了狀況，導致 DB 和 Cache 不一致。</li></ul><p><img src="/images/cacheReadAsideProblem2.png" alt=""></p><ul><li>問題三 : A 讀資料時發現 Cache 沒資料，所以去 DB 讀，但在寫回 Cache 前 B 就已經更新此資料並清掉Cache 了，這時候 A 才將舊資料寫回 Cache，導致不一致。</li></ul><p><img src="/images/cacheReadAsideProblem3.png" alt=""></p></blockquote><h2 id="快取模式-Double-Delete">快取模式 - Double Delete :</h2><blockquote><p><img src="/images/cacheReadAside.png" alt=""></p><ul><li>讀：先從 Cache 讀，讀到就回，沒讀到就從 DB 讀然後寫回 Cache。</li><li>寫：先清掉 Cache 再寫回 DB，接著<strong>等一下</strong>(依需求調整，例如 0.5s) 再清掉 Cache。</li></ul><p>我們可以發現他和 Read Aside 只差在寫的部分，原理是先避免其他人讀到舊資料，之後寫入 DB，先等一下再清掉 Cache 的過程則是為了減少 Read Aside 的問題三發生機率，所以雖然一致的機率提高了，但終究是會在極端情況下不符合一致性。</p></blockquote><h2 id="快取模式-Read-through">快取模式 - Read through :</h2><blockquote><p><img src="/images/cacheReadThrough.png" alt=""></p><ul><li>讀：先從 Cache 讀，讀到就回，沒讀到就<strong>由 Cache 從 DB 讀</strong>。</li><li>寫：無所謂，通常結合 Write Through 或 Write Behind 使用。</li></ul><p>注意<strong>由 Cache 從 DB 讀</strong>的實現 Redis 並不支援，NCache 則是需要收費。<br>可以自己實作 Data Access Layer(DAL)，在 DAL 裡用內部 api 伺服器去決定讀 Cache 還是 DB，而對於應用程式來說並不需要知道到底打了誰或是有沒有緩存，他只要知道可以透過 DAL 快速得到資料就好。</p></blockquote><h2 id="快取模式-Write-through">快取模式 - Write through :</h2><blockquote><p><img src="/images/cacheReadThrough.png" alt=""></p><ul><li>讀：無所謂，通常結合 Read Through 使用。</li><li>寫：只更新 Cache，並<strong>由 Cache 去更新 DB</strong>。</li></ul><p>注意跟 Read through 一樣，<strong>由 Cache 去更新 DB</strong> 的實現 Redis 並不支援，NCache 則是需要收費。<br>所以一樣可以藉由實作 Data Access Layer(DAL)來實現。</p><p>也就是說，當你使用 Read through + Write through 來實作快取架構，相當於你都只對 DAL 操作，這樣的優點是可以解決 Read Aside 的問題，但也引發了新的問題 :</p><ol><li>速度慢，因為你同時要寫完 Cache 和 DB 才算完成。</li><li>如果你不是用 DAL 而是原生支援 DB 連線的 Cache 的話，如果在 Cache 未寫入 DB 前就斷電重啟的話，那筆尚未更新到 DB 的資料就會永久遺失。</li></ol></blockquote><h2 id="快取模式-Write-Ahead-Behind-Back">快取模式 - Write Ahead (Behind)(Back) :</h2><blockquote><p><img src="/images/cacheWriteAhead.png" alt=""></p><ul><li>讀：無所謂，通常結合 Read Through 使用。</li><li>寫：需實作 DAL，並<strong>由 DAL 去更新 Cache 和 DB</strong>。</li></ul><p>和 Write through 不一樣需實作 DAL，並且會使用 Message Queue 來管理請求，這樣就可以避免 Cache 永久遺失資料的問題，也可以進一步實現對資料庫的批次寫入以減少寫入次數(Write Back)，但這樣的架構不好實現，需要處理非常多的細節，除非你真的需要這樣的可靠性，不然直接實作 Read Aside 是最簡單的。</p></blockquote><h2 id="小結">小結 :</h2><blockquote><p>介紹了這麼多不同做法，我們應該可以深刻體會一致性的難題有多複雜，以及這些架構背後可能會需要付出的成本，所以在決定你要如何實現快取架構前，你應該先考慮 :</p><ol><li>你的情境為何？為什麼要使用快取？</li><li>你的快取機器要求會有多高？會不會需要分散式？</li><li>比較看重的是一致性還是可用性？</li><li>哪些動作的延遲是可以接受的？哪些不行？讀跟寫的需求那個比較重？</li><li>你的快取需要多高的一致性保證？例如 Meta 可以保證 99.99999999% 的快取寫入一致性。</li></ol><p>在之後的文章裡，我們會探討阿里巴巴和 Meta 是如何設計快取架構的，雖然絕大多數的公司都不需要實現如此高的一致性，但他們的架構還是值得了解。</p></blockquote><h2 id="參考">參考 :</h2><ul><li><a href="https://web.ntnu.edu.tw/~algo/AlgorithmDesign.html#11">I/O-efficient Algorithm</a></li><li><a href="https://hackmd.io/@drwQtdGASN2n-vt_4poKnw/H1U6NgK3Z">CPU Cache 原理探討</a></li><li><a href="https://www.cs.pu.edu.tw/~bcc/93course/ch18.pdf">計算機組織與結構</a></li><li><a href="https://medium.com/starbugs/consistency-between-cache-and-database-part-1-f64f4a76720">Consistency between Cache and Database, Part 1</a></li><li><a href="https://medium.com/starbugs/consistency-between-cache-and-database-part-2-e28fc7f8a7c3">Consistency between Cache and Database, Part 2</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10224938">資料緩存失效問題</a></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;快取是什麼&quot;&gt;快取是什麼 :&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;我們都知道電腦的核心運算是由 CPU 負責的，而我們的主要的資料儲存單元是硬碟，由於要在硬碟裡面搜尋資料並帶回來是一件時間成本極高的事，所以就有了&lt;strong&gt;將找過的資料暫存起來&lt;/str</summary>
      
    
    
    
    <category term="快取" scheme="https://koufuchi.com/categories/%E5%BF%AB%E5%8F%96/"/>
    
    
    <category term="Cache" scheme="https://koufuchi.com/tags/Cache/"/>
    
    <category term="計算機組織" scheme="https://koufuchi.com/tags/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%B5%84%E7%B9%94/"/>
    
    <category term="系統架構" scheme="https://koufuchi.com/tags/%E7%B3%BB%E7%B5%B1%E6%9E%B6%E6%A7%8B/"/>
    
    <category term="Message queue" scheme="https://koufuchi.com/tags/Message-queue/"/>
    
    <category term="Consistency" scheme="https://koufuchi.com/tags/Consistency/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 49. Group Anagrams</title>
    <link href="https://koufuchi.com/LeetCode/GroupAnagrams/"/>
    <id>https://koufuchi.com/LeetCode/GroupAnagrams/</id>
    <published>2023-05-05T14:35:31.000Z</published>
    <updated>2023-11-21T09:52:27.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://leetcode.com/problems/group-anagrams/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給定一個字串陣列 strs，需要把每個字串依據 anagram 做分類放進不同的陣列後回傳。<br>相同 anagram 定義 : 若字串 s 的字元出現頻率與字串 t 相同，則他們為同一個 anagram。</p><p>例如輸入 strs=[“eat”,“tea”,“tan”,“ate”,“nat”,“bat”]，應回傳 [[“bat”],[“nat”,“tan”],[“ate”,“eat”,“tea”]]，不看順序。</p><ul><li>1 &lt;= strs.length &lt;= 10^4</li><li>0 &lt;= strs[i].length &lt;= 100</li><li>strs 裡的每個字串都只由小寫英文字組成</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>原本想到的作法是每個字串做一個<strong>字符出現次數表</strong>，但這樣的時間複雜度就會變成「字串總數 * (每個字串的最大長度 * 當下有的出現次數表(最大等於字串總數) * 當下有的出現次數表最大長度)，光看就不可行。</p><p>後來想說既然存出現次數陣列沒比較快，那就改成<strong>存排序後的不重複字串</strong>，也就是對每個字串做排序後去比較我們存過的不重複字串，時間複雜度會變成「字串總數 * 最大字串排序的時間複雜度」。而因為基本上排序演算法最快也要 O(MlogM)，所以當字串總數 N 且最大字串長度 M 時，時間複雜度會是 O(N * MlogM)。</p><p>最後是參考別人的答案 : 方法一之所以慢是因為你沒有辦法在 O(K) 的時間複雜度內找到他是否有符合已找過的 K 個 anagram 種類之一，而方法二雖然成功讓其降到 O(K)，卻因為需要做排序導致變成 O(MlogM)，所以最後這個方法三就是讓你不需排序也能達到 O(K) 甚至更快。</p><p>具體來說，我們可以發現題目確保每個字串都是小寫字母，也就是說他們本來就有順序的關係性在，由於 a 的 ASCII 值是 97，而 b 是 98，以此類推到 z，所以可以將每個小寫字母(a~z)減去 a 的值當作索引，剛好就會是索引從 0 開始排到 25 的陣列，你就可以用這個陣列當作有序的字符出現次數表，之後將這個陣列轉成字串當作陣列索引，你就能在 O(1) 的時間複雜度內找到他是否有符合已找過的 anagram 種類之一。</p><p>需要注意的陷阱是每個字母出現的次數有可能超過十位數，就代表如果你將陣列轉成字串的作法是直接把次數串在一起就會錯，例如下圖的第二個範例 :</p><p><img src="/images/GroupAnagramsExample1.jpg" alt=""></p><p>所以說我們在串聯時可以加上特殊標記來區分，例如 :</p><p><img src="/images/GroupAnagramsExample2.jpg" alt=""></p><p>這樣就不會搞混了。</p><ul><li>時間複雜度 O(N * M)，N 為字串總數，M 為最大字串長度</li><li>空間複雜度 O(N)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/app/LeetCode/Blind75/Array/GroupAnagrams.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/tests/Unit/LeetCode/Blind75/Array/GroupAnagramsTest.php">單元測試</a></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;題目：&quot;&gt;題目：&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/group-anagrams/&quot;&gt;官網題目連結&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;根據題目敘述，會給定一個字串陣列 strs，需要把每個字</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://koufuchi.com/categories/LeetCode/"/>
    
    
    <category term="PHP" scheme="https://koufuchi.com/tags/PHP/"/>
    
    <category term="Array" scheme="https://koufuchi.com/tags/Array/"/>
    
    <category term="HashTable" scheme="https://koufuchi.com/tags/HashTable/"/>
    
    <category term="演算法" scheme="https://koufuchi.com/tags/%E6%BC%94%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://koufuchi.com/tags/LeetCode/"/>
    
    <category term="Blind75" scheme="https://koufuchi.com/tags/Blind75/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 242. Valid Anagram</title>
    <link href="https://koufuchi.com/LeetCode/ValidAnagram/"/>
    <id>https://koufuchi.com/LeetCode/ValidAnagram/</id>
    <published>2023-05-03T13:48:38.000Z</published>
    <updated>2023-11-21T09:52:36.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://leetcode.com/problems/valid-anagram/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給定兩個字串 s 和 t，你必須判斷 s 是不是 t 的 anagram，若是則回傳 true，不是則回傳 false。</p><p>s 必須符合以下兩個條件才能算是 t 的 anagram :</p><ol><li>s 和 t 字串長度相同</li><li>s 和 t 有相同的字元數且各字元出現次數相同</li></ol><p>例如輸入 s = “anagram”, t = “nagaram”，應回傳 true。<br>輸入 s = “rat”, t = “car”，則回傳 false</p><ul><li>1 &lt;= s.length, t.length &lt;= 5*10^4</li><li>s 和 t 都只由小寫英文字組成。</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>原本想到的作法是遍歷 s 並記錄 s 中各字母出現次數，之後再遍歷 t 並用紀錄的陣列去減，如果有新字母或出現次數變成負數的情況就代表兩者不相同，但這樣做會導致最差情況(s 是 t 的 anagram)必須遍歷兩次 s 長度。</p><p>後來發現其實根本不需要分開遍歷，因為你可以<strong>從記錄 s 變成紀錄兩者差距</strong>，也就是 s 有的就加，t 有的就減，這樣你就只需要遍歷找完的字母出現次數差異陣列，發現有字母出現次數不等於 0 的時候就代表失敗。雖然最差情況(s 是 t 的 anagram 且字母出現次數不重複)也是遍歷兩次 s 長度，但這只會發生在剛好 26 個字母的時候，所以絕大情況下這個做法都是實際效能更高的。</p><ul><li>時間複雜度 O(N)，如何證明檢查存在鍵與拿取存放的時間複雜度請 <a href="/2022/10/19/PHPArray/">參考我的另一篇文章 - PHP Array</a></li><li>空間複雜度 O(N)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/app/LeetCode/Blind75/Array/ValidAnagram.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/tests/Unit/LeetCode/Blind75/Array/ValidAnagramTest.php">單元測試</a></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;題目：&quot;&gt;題目：&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/valid-anagram/&quot;&gt;官網題目連結&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;根據題目敘述，會給定兩個字串 s 和 t，你必須判斷 s </summary>
      
    
    
    
    <category term="LeetCode" scheme="https://koufuchi.com/categories/LeetCode/"/>
    
    
    <category term="PHP" scheme="https://koufuchi.com/tags/PHP/"/>
    
    <category term="Array" scheme="https://koufuchi.com/tags/Array/"/>
    
    <category term="HashTable" scheme="https://koufuchi.com/tags/HashTable/"/>
    
    <category term="演算法" scheme="https://koufuchi.com/tags/%E6%BC%94%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://koufuchi.com/tags/LeetCode/"/>
    
    <category term="Blind75" scheme="https://koufuchi.com/tags/Blind75/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 217. Contains Duplicate</title>
    <link href="https://koufuchi.com/LeetCode/ContainsDuplicate/"/>
    <id>https://koufuchi.com/LeetCode/ContainsDuplicate/</id>
    <published>2023-05-02T14:49:56.000Z</published>
    <updated>2023-11-21T09:52:23.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://leetcode.com/problems/contains-duplicate/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給定一個整數陣列 nums，你必須判斷 nums 中是否有元素值是重複出現的，若有則回傳 true，沒有則回傳 false。</p><p>例如輸入 nums=[1, 2, 3, 1]，由於元素值 1 重複出現，所以回傳 true。<br>而若輸入 nums=[1, 2, 3, 4]，由於元素值都沒有重複出現，所以回傳 false。</p><ul><li>1 &lt;= nums.length &lt;= 10^5</li><li>-10^9 &lt;= nums[i] &lt;= 10^9</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>這題比 <a href="/2023/05/02/LeetCode/TwoSum/">TwoSum</a> 更簡單，因為我們不需要知道重複的元素分別在哪裡，只需要知道當檢查到重複元素值時就回傳 true 就好。</p><p>所以一樣可以花一點空間來換時間，也就是用另一個陣列來邊找邊記錄我們已找過的值，當發現 nums[i] 已經有找過時，就代表要回傳 true。</p><ul><li>時間複雜度 O(N)，如何證明檢查存在鍵與拿取存放的時間複雜度請 <a href="/2022/10/19/PHPArray/">參考我的另一篇文章 - PHP Array</a></li><li>空間複雜度 O(N)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/app/LeetCode/Blind75/Array/ContainsDuplicate.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/tests/Unit/LeetCode/Blind75/Array/ContainsDuplicateTest.php">單元測試</a></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;題目：&quot;&gt;題目：&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/contains-duplicate/&quot;&gt;官網題目連結&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;根據題目敘述，會給定一個整數陣列 nums，你必</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://koufuchi.com/categories/LeetCode/"/>
    
    
    <category term="PHP" scheme="https://koufuchi.com/tags/PHP/"/>
    
    <category term="Array" scheme="https://koufuchi.com/tags/Array/"/>
    
    <category term="HashTable" scheme="https://koufuchi.com/tags/HashTable/"/>
    
    <category term="演算法" scheme="https://koufuchi.com/tags/%E6%BC%94%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://koufuchi.com/tags/LeetCode/"/>
    
    <category term="Blind75" scheme="https://koufuchi.com/tags/Blind75/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1. Two Sum</title>
    <link href="https://koufuchi.com/LeetCode/TwoSum/"/>
    <id>https://koufuchi.com/LeetCode/TwoSum/</id>
    <published>2023-05-02T13:41:05.000Z</published>
    <updated>2023-11-21T09:52:32.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://leetcode.com/problems/two-sum/">官網題目連結</a></p><blockquote><p>最經典的 LeetCode 第一題，求兩數之和！</p><p>根據題目敘述，會給定一個整數陣列 nums，還有一個整數 target，你必須找出 nums 中哪兩個元素相加會等於 target，用陣列回傳他們的索引。</p><p>例如輸入 nums=[2, 7, 11, 15], target=9，由於前兩個元素 2+7=9 剛好就是答案，所以回傳 [0 ,1]，題目特別說<strong>不看順序</strong>所以你要回傳 [1, 0] 也可以。</p><ul><li>2 &lt;= nums.length &lt;= 10^4</li><li>-10^9 &lt;= nums[i] &lt;= 10^9</li><li>-10^9 &lt;= target &lt;= 10^9</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>沒碰過演算法的人可能一開始都會想到用暴力解，也就是先用第 1 個去對剩下 N-1，再用第 2 個去對剩下 N-2 個，但這樣的做法會導致運算次數變成等差數列總和，也就是時間複雜度 O(N^2)。</p><p>我們可以花一點空間來換時間，也就是用另一個陣列來邊找邊記錄我們已找過的值，當發現 target - nums[i] 已經有找過時，就代表這是答案。</p><ul><li>時間複雜度 O(N)，如何證明檢查存在鍵與拿取存放的時間複雜度請 <a href="/2022/10/19/PHPArray/">參考我的另一篇文章 - PHP Array</a></li><li>空間複雜度 O(N)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/app/LeetCode/Blind75/Array/TwoSum.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/tests/Unit/LeetCode/Blind75/Array/TwoSumTest.php">單元測試</a></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;題目：&quot;&gt;題目：&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/two-sum/&quot;&gt;官網題目連結&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最經典的 LeetCode 第一題，求兩數之和！&lt;/p&gt;
&lt;p&gt;根據題</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://koufuchi.com/categories/LeetCode/"/>
    
    
    <category term="PHP" scheme="https://koufuchi.com/tags/PHP/"/>
    
    <category term="Array" scheme="https://koufuchi.com/tags/Array/"/>
    
    <category term="HashTable" scheme="https://koufuchi.com/tags/HashTable/"/>
    
    <category term="演算法" scheme="https://koufuchi.com/tags/%E6%BC%94%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://koufuchi.com/tags/LeetCode/"/>
    
    <category term="Blind75" scheme="https://koufuchi.com/tags/Blind75/"/>
    
  </entry>
  
  <entry>
    <title>用 Linux 的 systemd 來保持你的服務吧 !</title>
    <link href="https://koufuchi.com/SystemdToKeepAlive/"/>
    <id>https://koufuchi.com/SystemdToKeepAlive/</id>
    <published>2023-05-01T05:45:27.000Z</published>
    <updated>2023-11-21T09:53:04.310Z</updated>
    
    <content type="html"><![CDATA[<h2 id="簡介">簡介 :</h2><blockquote><p>systemd 基於一個事件驅動的機制，它可以同時啟動並管理多個服務，並在服務失敗或系統崩潰時自動重啟服務。它還提供了各種管理命令和工具，用於管理系統日誌、網絡配置、作業系統時間等等…。</p></blockquote><h2 id="首先，移動到系統單位檔案的存放位置">首先，移動到系統單位檔案的存放位置 :</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/systemd/system   <span class="comment"># 我是用 ubuntu 22.04 版本，如果你路徑不一樣請自己找</span></span><br></pre></td></tr></table></figure><h2 id="建立系統單位檔案">建立系統單位檔案 :</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> &lt;your service name&gt;.service</span><br></pre></td></tr></table></figure><h2 id="打開你建立的檔案並寫入設定">打開你建立的檔案並寫入設定 :</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=&lt;write your description&gt;</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"><span class="comment"># 讓 systemd 知道編譯器和啟動檔案在哪，以及啟動方式，一般來說你怎麼啟動的就直接貼過來，不過他不吃你的 $PATH 所以要給完整路徑</span></span><br><span class="line">ExecStart=/usr/bin/python3 -u /home/ubuntu/projects/DiscordBot/main.py  </span><br><span class="line">WorkingDirectory=/home/ubuntu/projects/DiscordBot/</span><br><span class="line">User=ubuntu  <span class="comment"># 要記得確保有權限讀取和執行 WorkingDirectory 底下所有檔案</span></span><br><span class="line">Group=ubuntu  <span class="comment"># 要記得確保有權限讀取和執行 WorkingDirectory 底下所有檔案</span></span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><h2 id="開始執行">開始執行 :</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start &lt;your service name&gt;.service</span><br></pre></td></tr></table></figure><h2 id="查看服務狀態">查看服務狀態 :</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status &lt;your service name&gt;.service</span><br></pre></td></tr></table></figure><h2 id="當你有變更你的-service-內容時，需要先-reload">當你有變更你的 .service 內容時，需要先 reload :</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure><h2 id="其他語法">其他語法 :</h2><ul><li>設定為啟動系統時就自動啟動 :</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> &lt;your service name&gt;.service</span><br></pre></td></tr></table></figure><ul><li>停止服務 :</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop &lt;your service name&gt;.service</span><br></pre></td></tr></table></figure><ul><li>重啟服務 :</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart &lt;your service name&gt;.service</span><br></pre></td></tr></table></figure><ul><li>查看錯誤日誌 :</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -u &lt;your service name&gt;.service</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;簡介&quot;&gt;簡介 :&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;systemd 基於一個事件驅動的機制，它可以同時啟動並管理多個服務，並在服務失敗或系統崩潰時自動重啟服務。它還提供了各種管理命令和工具，用於管理系統日誌、網絡配置、作業系統時間等等…。&lt;/p&gt;
&lt;/bl</summary>
      
    
    
    
    <category term="Linux" scheme="https://koufuchi.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://koufuchi.com/tags/Linux/"/>
    
    <category term="systemd" scheme="https://koufuchi.com/tags/systemd/"/>
    
  </entry>
  
  <entry>
    <title>用 Postman 實現 api 自動測試吧 !</title>
    <link href="https://koufuchi.com/PostMan/PostmanTest/"/>
    <id>https://koufuchi.com/PostMan/PostmanTest/</id>
    <published>2023-04-30T02:21:41.000Z</published>
    <updated>2023-11-21T09:52:46.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Postman-工作區目錄架構">Postman 工作區目錄架構 :</h2><blockquote><p>Postman 的工作區目錄架構為 Collection、Folder、Request、Example，如下圖 :</p><p><img src="/images/postmanStructure.png" alt=""></p><p>注意只有 Folder 可以自己包自己。</p><p>我們可以寫測試的範圍有 Collection、Folder、Request，不包含 Example，原因為 Example 只是把一些參數取出來單獨設定而已，他要執行時會將這些參數覆寫到繼承的 Request 並執行，但終究還是歸附於 Request，所以也會執行 Request 寫好的測試。</p></blockquote><h2 id="自動測試的執行順序">自動測試的執行順序 :</h2><blockquote><p>在 Collection、Folder、Request 界面中我們都可找到和設定「Pre-request Script」以及「Tests」，顧名思義就是一個是先跑的腳本、另一個是最後才跑的腳本，我們假設範例為 Collection 包 Folder 包 Request，且都有設定「Pre-request Script」以及「Tests」，那麼當你按下 Send Request 後的執行順序就是 :</p><ol><li>Collection Pre-request Script</li><li>Folder Pre-request Script</li><li>Request Pre-request Script</li><li>Request 本身</li><li>Request Tests</li><li>Folder Tests</li><li>Collection Tests</li></ol><p>從這樣的順序也很明顯可以看出 :</p><ul><li>Pre-request Script 在打 api 前就執行了，可以做的事有檢查參數、預打其他 api 拿 token 等等…。</li><li>Tests 是在打 api 後執行的，可以做的事有檢查回傳狀態、檢查回傳內容等等…。</li></ul></blockquote><h2 id="如何撰寫測試">如何撰寫測試 :</h2><blockquote><p>Postman 的腳本撰寫語法是基於 JavaScript，並提供物件 pm 以供操作，至於詳細有哪些用法官網已經寫得很清楚了，參考 :</p><ul><li><a href="https://learning.postman.com/docs/writing-scripts/pre-request-scripts/">Writing pre-request scripts</a></li><li><a href="https://learning.postman.com/docs/writing-scripts/test-scripts/">Writing tests</a></li></ul></blockquote><h2 id="範例一，打-api-前檢查當前用的-Postman-環境變數">範例一，打 api 前檢查當前用的 Postman 環境變數 :</h2><blockquote><p>情境 : 因為有時候打不同台伺服器或本地時忘了切換環境變數，會導致我對應的 domain 值壞掉。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;檢查環境變數&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123; </span><br><span class="line">    pm.<span class="title function_">expect</span>(pm.<span class="property">environment</span>.<span class="title function_">get</span>(<span class="string">&quot;domain&quot;</span>)).<span class="property">to</span>.<span class="property">be</span>.<span class="title function_">oneOf</span>([</span><br><span class="line">        <span class="string">&quot;打卡系統正式機&quot;</span>,</span><br><span class="line">        <span class="string">&quot;打卡系統測試機&quot;</span></span><br><span class="line">    ]); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>像這個範例你就可以寫在 Collection 的 Pre-request Script，因為通常一個 Collection 就對應一個系統、服務，其底下的 Request 應該都是吃同一種環境變數。</p></blockquote><h2 id="範例二，檢查-api-response-的狀態">範例二，檢查 api response 的狀態 :</h2><blockquote><p>情境 : 我希望知道此次回傳是否成功(這範例其實蠻雞肋的啦，因為本來界面就會顯示了)。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;檢查回傳狀態&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    pm.<span class="property">response</span>.<span class="property">to</span>.<span class="property">have</span>.<span class="title function_">status</span>(<span class="number">200</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="範例三，檢查-api-request-的-JSON-Schema">範例三，檢查 api request 的 JSON Schema :</h2><blockquote><p>情境 : 有時候你邊寫邊打就忘了有些 request 參數忘了改，這時候就能檢查。<br>注意 : Postman 用的 jsonSchema 是最新版的，你需要注意自己使用的版本是否有落差，因為寫法會變。<br>以筆者撰寫這篇文章的時間點來說是 3.1 或以上。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定義期望的 JSON Schema</span></span><br><span class="line"><span class="keyword">let</span> schema = &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">    <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;orderId&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: [<span class="string">&quot;integer&quot;</span>, <span class="string">&quot;null&quot;</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;isVoid&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: [<span class="string">&quot;boolean&quot;</span>, <span class="string">&quot;null&quot;</span>],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 檢查</span></span><br><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;檢查請求 json 是否符合期望的 jsonSchema&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">     pm.<span class="property">request</span>.<span class="property">to</span>.<span class="property">have</span>.<span class="title function_">jsonSchema</span>(schema);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="範例四，檢查-api-response-的-JSON-Schema">範例四，檢查 api response 的 JSON Schema :</h2><blockquote><p>情境 : 我希望回傳的 key 都符合我的期望，例如期望是整數那就不能回傳字串。<br>用法跟上面幾乎一樣，只是你要改從 response 拿而已。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定義期望的 JSON Schema</span></span><br><span class="line"><span class="keyword">let</span> schema = &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">    <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;typeId&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: [<span class="string">&quot;integer&quot;</span>, <span class="string">&quot;null&quot;</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;statusId&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: [<span class="string">&quot;integer&quot;</span>, <span class="string">&quot;null&quot;</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;supplierCode&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: [<span class="string">&quot;integer&quot;</span>, <span class="string">&quot;null&quot;</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;customerName&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: [<span class="string">&quot;string&quot;</span>, <span class="string">&quot;null&quot;</span>],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 檢查</span></span><br><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;檢查回傳 json 是否符合期望的 jsonSchema&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">     pm.<span class="property">response</span>.<span class="property">to</span>.<span class="property">have</span>.<span class="title function_">jsonSchema</span>(schema);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>你可能會覺得定義 jsonSchema 很麻煩，沒錯！因為我也這樣覺得，所以在這邊提供方法 :</p><ol><li><p>一般來說都會有寫 swagger 給前端對接用，那你就直接拿這個用就好了，簡單粗暴，像 Laravel 框架可以使用 : php artisan l5-swagger:generate 的指令快速產出。</p></li><li><p>你的 request 或 response 在 Postman 上都有完整 JSON 了，所以你可以使用 <a href="https://jsonschema.net/app/schemas">JSON Schema – json 轉 jsonschema</a> 快速轉換，但最麻煩的就是 nullable 你要自己加。</p></li></ol><p><a href="/2023/04/29/ThirdParty/">參考我的另一篇文章 - 常用的第三方工具</a></p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Postman-工作區目錄架構&quot;&gt;Postman 工作區目錄架構 :&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Postman 的工作區目錄架構為 Collection、Folder、Request、Example，如下圖 :&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/</summary>
      
    
    
    
    <category term="Postman" scheme="https://koufuchi.com/categories/Postman/"/>
    
    
    <category term="Postman" scheme="https://koufuchi.com/tags/Postman/"/>
    
    <category term="自動化測試" scheme="https://koufuchi.com/tags/%E8%87%AA%E5%8B%95%E5%8C%96%E6%B8%AC%E8%A9%A6/"/>
    
    <category term="JavaScript" scheme="https://koufuchi.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>常用的第三方工具</title>
    <link href="https://koufuchi.com/ThirdParty/"/>
    <id>https://koufuchi.com/ThirdParty/</id>
    <published>2023-04-29T12:25:54.000Z</published>
    <updated>2023-11-21T09:53:10.423Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工作中用過的一些第三方工具：">工作中用過的一些第三方工具：</h2><ul><li><p><a href="https://regex101.com/">regex101 – 線上測試正規表達式工具</a></p></li><li><p><a href="https://crontab.guru/">crontab guru – 線上測試 corntab 語法工具</a></p></li><li><p><a href="https://sequencediagram.org/">sequencediagram – 畫時序圖工具</a></p></li><li><p><a href="https://app.diagrams.net/">Draw.io – 畫圖工具</a></p></li><li><p><a href="http://sqlfiddle.com/">SQL Fiddle – 線上資料庫工具</a></p></li><li><p><a href="https://dbdiagram.io/home">dbdiagram – 資料庫工具</a></p></li><li><p><a href="https://dbschema.com/">dbSchema – 資料庫工具</a></p></li><li><p><a href="https://jsoneditoronline.org/#left=local.ranopi&amp;right=local.vosuzi">json editor – JSON 比對工具</a></p></li><li><p><a href="https://jsonschema.net/app/schemas">JSON Schema – json 轉 jsonschema</a></p></li><li><p><a href="https://shancarter.github.io/mr-data-converter/">Mr. Data Converter – CSV 轉其他格式</a></p></li><li><p><a href="https://slack.com/intl/zh-tw">Slack – 團隊溝通</a></p></li><li><p><a href="https://www.invisionapp.com/">InVision – 前端畫面工具</a></p></li><li><p><a href="https://www.figma.com/">figma – UI 設計工具</a></p></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;工作中用過的一些第三方工具：&quot;&gt;工作中用過的一些第三方工具：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://regex101.com/&quot;&gt;regex101 – 線上測試正規表達式工具&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a hre</summary>
      
    
    
    
    <category term="第三方工具" scheme="https://koufuchi.com/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="第三方工具" scheme="https://koufuchi.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>讓你的 git commit message 更容易閱讀</title>
    <link href="https://koufuchi.com/git/GitCommitMessage/"/>
    <id>https://koufuchi.com/git/GitCommitMessage/</id>
    <published>2023-04-29T07:42:07.000Z</published>
    <updated>2023-11-21T09:52:13.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="讓版控更加容易追蹤">讓版控更加容易追蹤 :</h2><blockquote><p>習慣上會將每個 commit 的內容盡量限縮在<strong>單一單元或一件事</strong>上，以讓你的 commit message 和異動處能夠簡潔的對應，對於自己或團隊成員在追蹤進度、回顧異動上都能提高效率。</p><p>在這之上能更快表達此次 commit 意義的做法，就是在 commit message 開頭加上<strong>前綴字</strong>，常見的有 :</p><ul><li>feat : 新增/修改功能 (feature)。</li><li>fix : 修補 bug (bug fix)。</li><li>docs : 文件 (documentation)。</li><li>style : 格式 (不影響程式碼運行的變動 white-space, formatting, missing semi colons, etc)。</li><li>refactor : 重構 (既不是新增功能，也不是修補 bug 的程式碼變動)。</li><li>perf : 改善效能 (A code change that improves performance)。</li><li>test : 增加測試 (when adding missing tests)。</li><li>chore : 建構程序或輔助工具的變動 (maintain)。</li><li>revert : 撤銷回覆先前的 commit 例如：revert: type(scope): subject (回覆版本：xxxx)。</li></ul><p>加上前綴字之後一看就能先猜到在做什麼，之後再閱讀你改動的訊息就能更快進入狀況。</p></blockquote><h2 id="參考">參考</h2><ul><li><a href="https://wadehuanglearning.blogspot.com/2019/05/commit-commit-commit-why-what-commit.html">Git Commit Message 這樣寫會更好，替專案引入規範與範例</a></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;讓版控更加容易追蹤&quot;&gt;讓版控更加容易追蹤 :&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;習慣上會將每個 commit 的內容盡量限縮在&lt;strong&gt;單一單元或一件事&lt;/strong&gt;上，以讓你的 commit message 和異動處能夠簡潔的對應，對於自己或團</summary>
      
    
    
    
    <category term="git" scheme="https://koufuchi.com/categories/git/"/>
    
    
    <category term="git" scheme="https://koufuchi.com/tags/git/"/>
    
    <category term="style" scheme="https://koufuchi.com/tags/style/"/>
    
  </entry>
  
  <entry>
    <title>Codility Lesson MissingInteger</title>
    <link href="https://koufuchi.com/Codility/CodilityLessonMissingInteger/"/>
    <id>https://koufuchi.com/Codility/CodilityLessonMissingInteger/</id>
    <published>2023-04-27T12:35:52.000Z</published>
    <updated>2023-11-21T09:51:40.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://app.codility.com/programmers/lessons/4-counting_elements/missing_integer/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給一個由 N 個整數組成的陣列 A。需找出 A 中沒有出現且大於 0 的最小正整數。<br>例如輸入 A=[1, 3, 6, 4, 1, 2]，答案應為 5。<br>A=[1, 2, 3]，答案應為 4。<br>A=[-1, -3]，答案應為 1。</p><ul><li>N 是範圍 [1~100000] 的整數。</li><li>陣列 A 裡的元素都是範圍 [−1000000~1000000] 的整數。</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>第一時間還是想到了記憶法，先遍歷 A 記錄走過的不重複合法值，之後再遍歷記錄到的合法值來找出第一個 合法總數+1 的範圍內沒有記錄到的合法值。</p><p>總覺得還有機會想出跟 <a href="/2023/04/25/Codility/CodilityLessonMaxCounters/">MaxCounters</a> 一樣將當前最小值與合法最小值分開存的方法，就不用分兩次遍歷，但目前仍未想到。</p><ul><li>時間複雜度 O(N)</li><li>空間複雜度 O(N)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/CountingElements/MissingInteger.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/CountingElements/MissingIntegerTest.php">單元測試</a></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;題目：&quot;&gt;題目：&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://app.codility.com/programmers/lessons/4-counting_elements/missing_integer/&quot;&gt;官網題目連結&lt;/a&gt;&lt;/p&gt;
&lt;blockqu</summary>
      
    
    
    
    <category term="Codility" scheme="https://koufuchi.com/categories/Codility/"/>
    
    
    <category term="PHP" scheme="https://koufuchi.com/tags/PHP/"/>
    
    <category term="演算法" scheme="https://koufuchi.com/tags/%E6%BC%94%E7%AE%97%E6%B3%95/"/>
    
    <category term="Codility" scheme="https://koufuchi.com/tags/Codility/"/>
    
  </entry>
  
  <entry>
    <title>Codility Lesson MaxCounters</title>
    <link href="https://koufuchi.com/Codility/CodilityLessonMaxCounters/"/>
    <id>https://koufuchi.com/Codility/CodilityLessonMaxCounters/</id>
    <published>2023-04-25T15:03:41.000Z</published>
    <updated>2023-11-21T09:51:34.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://app.codility.com/programmers/lessons/4-counting_elements/max_counters/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給一個由 N 個整數組成的陣列 A 以及一個整數 M，你必須照順序遍歷 A 並執行以下判斷，之後返回結果陣列 R (包含 M 個整數) :</p><ul><li>當遍歷到 A[K]=X，且 1 ≤ X ≤ N 時，結果陣列 R[K-1] 的值要加 1。</li><li>當遍歷到的 A[K]=N+1，則 R 中所有元素值都必須統一成當前 R 的最大元素值。</li></ul><p>例如輸入 A=[3, 4, 4, 6, 1, 4, 4]，M=5 :</p><ol><li>當 K=0，A[K]=3，R[3-1] 要加 1，R 就變成 [0, 0, 1, 0, 0]</li><li>當 K=1，A[K]=4，R[4-1] 要加 1，R 就變成 [0, 0, 1, 1, 0]</li><li>當 K=2，A[K]=4，R[4-1] 要加 1，R 就變成 [0, 0, 1, 2, 0]</li><li>當 K=3，A[K]=6，R[6-1] 等於 M+1，R 所有元素要等於當前最大元素 2，所以 R 就變成 [2, 2, 2, 2, 2]</li><li>當 K=4，A[K]=1，R[1-1] 要加 1，R 就變成 [3, 2, 2, 2, 2]</li><li>當 K=5，A[K]=4，R[4-1] 要加 1，R 就變成 [3, 2, 2, 3, 2]</li><li>當 K=6，A[K]=4，R[4-1] 要加 1，R 就變成 [3, 2, 2, 4, 2]，因為遍歷完了，所以 R 已是答案。</li></ol><p>其實題目沒有要你遍歷，只是講計數規則，但這題不遍歷不能解，我覺得這樣寫題目說明應該比較好懂，如果你有想到不遍歷的方法歡迎在下方留言討論。</p><ul><li>N 和 M 都是範圍 [1~100000] 的整數。</li><li>陣列 A 裡的元素都是範圍 [1~N+1] 的整數。</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>最棘手的部分就在於「當 A[K]=N+1，R 中所有元素值都必須統一成當前 R 的最大元素值」，因為如果你要將 R 所有數字都即時更新成最大值的話，你的時間複雜度就會變成 O(N*M)，而這顯然不是最好的答案。</p><p>那麼如果我不要即時統一，而是只紀錄這個觸發要統一的事實，並在之後的點替換成最大值呢 ?<br>感覺是可行的方向，但要如何實現需要思考一下，我們會發現當你觸發統一時，假設當前 R 最大元素是 3，代表之後如果遇到小於 3 的元素就是尚未統一過的元素，而如果之後又觸發統一，且當前 R 最大元素變成 5，那麼之後遇到小於 5 的元素就是尚未統一過的元素，我們並不需要擔心他到底有沒有統一成 3 過了，因為反正他都比 5 小，我們不需要記錄他的所有歷程。</p><p>具體來說我們除了需要紀錄 R 的最大元素值 max 之外，還需要知道要統一的目標數字是多少，所以會需要另一個變數 needToAdd 來處理，有點像雙指標的概念，max 永遠紀錄最大值，而當觸發統一時 needToAdd 會即時跟上 max。</p><p>最後，因為有可能有 M 中的元素完全沒被加過，你沒辦法幫他處理統一，所以你還需要遍歷一次 M，將 M 沒被統一的值做統一，因此所需的時間複雜度就是 N 和 M 個只遍歷一次，為 O(N+M)。</p><p>這題在 Codility 算 medium，感覺確實比起其他 Lesson 更有挑戰一點，不過以體感來說應該還是只有 LeetCode 的 easy 難度而已。</p><ul><li>時間複雜度 O(N+M)</li><li>空間複雜度 O(M)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/CountingElements/MaxCounters.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/CountingElements/MaxCountersTest.php">單元測試</a></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;題目：&quot;&gt;題目：&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://app.codility.com/programmers/lessons/4-counting_elements/max_counters/&quot;&gt;官網題目連結&lt;/a&gt;&lt;/p&gt;
&lt;blockquote</summary>
      
    
    
    
    <category term="Codility" scheme="https://koufuchi.com/categories/Codility/"/>
    
    
    <category term="PHP" scheme="https://koufuchi.com/tags/PHP/"/>
    
    <category term="演算法" scheme="https://koufuchi.com/tags/%E6%BC%94%E7%AE%97%E6%B3%95/"/>
    
    <category term="Codility" scheme="https://koufuchi.com/tags/Codility/"/>
    
  </entry>
  
  <entry>
    <title>Codility Lesson PermCheck</title>
    <link href="https://koufuchi.com/Codility/CodilityLessonPermCheck/"/>
    <id>https://koufuchi.com/Codility/CodilityLessonPermCheck/</id>
    <published>2023-04-24T12:59:03.000Z</published>
    <updated>2023-11-21T09:51:52.490Z</updated>
    
    <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://app.codility.com/programmers/lessons/4-counting_elements/perm_check/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給一個包含 N 個元素的<strong>非空</strong>陣列 A。你必須檢查 A 中是否包含所有 1~N 的整數值且不重複(其實這有點廢話，因為當滿足包含所有 1~N 的整數時本來就不可能有重複)</p><p>例如輸入 A=[4, 1, 3, 2]，滿足所有 1~4 且不重複，所以回傳 1。<br>而如果輸入 A=[4, 1, 3]，不滿足所有 1~3 且不重複，所以回傳 0。</p><ul><li>N 是範圍 [1~100000] 的整數。</li><li>陣列 A 裡的所有元素都是範圍 [1~1000000000] 的整數</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>這邊容易疏忽的點應該是並不保證餵進來的陣列其值都不重複，所以你不能用等差數列來解，依然需要紀錄走了哪些合法值，所以空間複雜度只能 O(N)。</p><p>再來由於一樣要追求遍歷一次就做完，所以我們需要找到規律，能先檢查的就是當發生重複(也就是當前遍歷值是已記錄過得合法值)時可以直接回傳 0，也就表示如果成功遍歷完一次 A ，就能確保 A 是<strong>元素不重複</strong>的陣列，也就能確保當我們紀錄的<strong>不重複合法值陣列總數等同於其內部的最大元素值</strong>時，就代表符合需求。</p><p>因為有點饒舌所以用範例說明，當輸入 A=[4, 1, 3, 2] 時，我們遍歷一遍<strong>確保都不重複</strong>，並且會得到另一個不重複合法值陣列 B=[4, 1, 3, 2]，然後當 B 的元素總數 4 剛好等於他最大的元素 B[0]=4 時，就代表是正確的。</p><p>由於你邊遍歷就可以邊收集最大元素值了，所以總共只要遍歷一次就好。</p><ul><li>時間複雜度 O(N)</li><li>空間複雜度 O(N)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/CountingElements/PermCheck.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/CountingElements/PermCheckTest.php">單元測試</a></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;題目：&quot;&gt;題目：&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://app.codility.com/programmers/lessons/4-counting_elements/perm_check/&quot;&gt;官網題目連結&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
</summary>
      
    
    
    
    <category term="Codility" scheme="https://koufuchi.com/categories/Codility/"/>
    
    
    <category term="PHP" scheme="https://koufuchi.com/tags/PHP/"/>
    
    <category term="演算法" scheme="https://koufuchi.com/tags/%E6%BC%94%E7%AE%97%E6%B3%95/"/>
    
    <category term="Codility" scheme="https://koufuchi.com/tags/Codility/"/>
    
  </entry>
  
  <entry>
    <title>Codility Lesson FrogRiverOne</title>
    <link href="https://koufuchi.com/Codility/CodilityLessonFrogRiverOne/"/>
    <id>https://koufuchi.com/Codility/CodilityLessonFrogRiverOne/</id>
    <published>2023-04-24T12:23:10.000Z</published>
    <updated>2023-11-21T09:51:25.823Z</updated>
    
    <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://app.codility.com/programmers/lessons/4-counting_elements/frog_river_one/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給一個鍵為 N，值為 K 的<strong>非空</strong>陣列 A。其中 N 表示秒數，K 表示位置，也就是第 N 秒時會有樹葉掉落到位置 K 上。</p><p>題目還會給一個整數 X 表示終點，你必須找出最少第幾秒時 1~X 的位置上都會有落葉。</p><p>例如輸入 A=[1, 3, 1, 4, 2, 3, <strong>5</strong>, 4]， X=5。<br>最少在第 6 秒時會有樹葉掉落到位置 5，且位置 1~5 都有樹葉，所以答案為 6。</p><p>如果 1~X 永遠不可能都有樹葉的話，你必須回傳 -1。</p><ul><li>N 是範圍 [1~100000] 的整數。</li><li>陣列 A 裡的所有元素都是範圍 [1~X] 的整數</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>這題不像 <a href="/2023/04/14/Codility/CodilityLessonPermMissingElem/">PermMissingElem</a> 一樣可以用等差數列去減，因為樹葉掉落的位置可能會出現重複的，所以始終是必須記錄走過的不重複合法位置有哪些，空間複雜度最低只能 O(N)。</p><p>而由於我們有紀錄走過的不重複合法位置，所以可以得知當你剛好找到第 X 個不重複合法值時，他的時間就會是答案，總共只需遍歷一次。</p><ul><li>時間複雜度 O(N)</li><li>空間複雜度 O(N)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/CountingElements/FrogRiverOne.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/CountingElements/FrogRiverOneTest.php">單元測試</a></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;題目：&quot;&gt;題目：&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://app.codility.com/programmers/lessons/4-counting_elements/frog_river_one/&quot;&gt;官網題目連結&lt;/a&gt;&lt;/p&gt;
&lt;blockquo</summary>
      
    
    
    
    <category term="Codility" scheme="https://koufuchi.com/categories/Codility/"/>
    
    
    <category term="PHP" scheme="https://koufuchi.com/tags/PHP/"/>
    
    <category term="演算法" scheme="https://koufuchi.com/tags/%E6%BC%94%E7%AE%97%E6%B3%95/"/>
    
    <category term="Codility" scheme="https://koufuchi.com/tags/Codility/"/>
    
  </entry>
  
  <entry>
    <title>用 Homebrew 懶人切換 php 版本</title>
    <link href="https://koufuchi.com/%E7%94%A8brew%E6%87%B6%E4%BA%BA%E5%88%87%E6%8F%9Bphp%E7%89%88%E6%9C%AC/"/>
    <id>https://koufuchi.com/%E7%94%A8brew%E6%87%B6%E4%BA%BA%E5%88%87%E6%8F%9Bphp%E7%89%88%E6%9C%AC/</id>
    <published>2023-04-19T14:42:07.000Z</published>
    <updated>2023-11-21T09:52:52.224Z</updated>
    
    <content type="html"><![CDATA[<aside>💡 適用於 mac os 且使用 Homebrew 管理 php 環境</aside><hr><h2 id="核心為以下兩行">核心為以下兩行 :</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew <span class="built_in">unlink</span> php@7.3 </span><br><span class="line">brew <span class="built_in">link</span> -f php@8.1</span><br></pre></td></tr></table></figure><h2 id="每次都要記很煩所以寫了個簡單-script">每次都要記很煩所以寫了個簡單 script :</h2><p><a href="https://github.com/Koufuchi/php_version_switcher">GitHub - Koufuchi/php_version_switcher</a></p><h2 id="用命令行移動到-script-所在目錄，執行以下語法並指定版本即可切換：">用命令行移動到 script 所在目錄，執行以下語法並指定版本即可切換：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. ~/ps.sh 7.3  <span class="comment"># 檔名自己取，執行時後面餵版本參數，如果參數錯誤則會列出你本機安裝的所有版本</span></span><br></pre></td></tr></table></figure><h2 id="或是真的超懶，就在-zshrc-中加入">或是真的超懶，就在 ~/.zshrc 中加入 :</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$PATH</span>:/&lt;your script path&gt;/&quot;</span>  <span class="comment"># script 所在目錄</span></span><br></pre></td></tr></table></figure><h2 id="之後打開-terminal-後就直接輸入以下就好">之後打開 terminal 後就直接輸入以下就好 :</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps.sh 7.3 </span><br></pre></td></tr></table></figure><p>注意所有指令都會跑去你指定的目錄對，所以其實不太推薦這樣玩</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;aside&gt;
💡 適用於 mac os 且使用 Homebrew 管理 php 環境
&lt;/aside&gt;
&lt;hr&gt;
&lt;h2 id=&quot;核心為以下兩行&quot;&gt;核心為以下兩行 :&lt;/h2&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    <category term="自製工具" scheme="https://koufuchi.com/categories/%E8%87%AA%E8%A3%BD%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="PHP" scheme="https://koufuchi.com/tags/PHP/"/>
    
    <category term="Shell" scheme="https://koufuchi.com/tags/Shell/"/>
    
    <category term="Homebrew" scheme="https://koufuchi.com/tags/Homebrew/"/>
    
    <category term="macOS" scheme="https://koufuchi.com/tags/macOS/"/>
    
  </entry>
  
</feed>
