<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>快取的一致性難題與架構模式 (中)</title>
      <link href="/2023/05/07/Cache/CacheConsistencyCanal/"/>
      <url>/2023/05/07/Cache/CacheConsistencyCanal/</url>
      
        <content type="html"><![CDATA[<h2 id="阿里巴巴的開源專案-canal">阿里巴巴的開源專案 canal :</h2><blockquote><ul><li>讀：和 Read Aside 一樣。先從 Cache 讀，讀到就回，沒讀到就從 DB 讀然後寫回 Cache。</li><li>寫：只寫回 DB，canal 會從 DB 的 binlog 複製到 Cache (canal 扮演 Slave 的角色去監聽 binlog)。</li></ul><p>補充 : binlog 是 MySQL 二進位制格式的日誌，只要資料庫有操作，就會寫入 binlog。</p></blockquote><h2 id="MySQL-主從複製">MySQL 主從複製 :</h2><blockquote><p>在探討 canal 如何運作之前，我們必須先了解 MySQL 是如何達到主從複製的 :</p><p><img src="/images/MySQLMasterSlave.jpeg" alt=""></p><ol><li>Slave 產生 I/O thread 向 Master 請求 binlog。</li><li>Master 會產生一個 log dump thread，負責傳 binlog 給 Slave 的 I/O thread，而在讀取和發送<br>給 Slave 的過程中會將 binlog 上鎖。</li><li>Slave I/O thread 將得到的 binlog 日志<strong>寫入</strong> Relay log(中繼日誌) 文件中。</li><li>Slave 產生 SQL thread 讀取 Relay log 文件中的日誌，並<strong>解析</strong>成具體操作，這樣就能保證主從操作一致，即達成資料一致。</li></ol><p>你可能已經發現了他實際上還是會存在不一致的時間，至於具體是多久，可能的影響因素很多，包括網路如何連接、有多少個從機、採用什麼樣的主從架構和同步方式等等…。</p><p>大部分人給出的答案都是在同個 lan 下是瞬時的，因為採用獨立的 thread 和 socket 連接，且 binlog 是二進制文件，但是具體的數據官方也沒有提供，可能需要自己測試，可以架好環境後用 SHOW SLAVE STATUS 看 seconds_behind_master 的值。</p></blockquote><h2 id="canal-工作原理">canal 工作原理 :</h2><blockquote><p>如同上面提到的，MySQL 主從複製是一個成熟且使用者眾多的架構，他的目的也是為了解決分散式架構造成的一致性問題，所以如果我們能讓一個服務偽裝成 Slave 加入這個架構，就能直接沿用這個可靠的架構。</p><p><img src="/images/canal.png" alt=""></p><p>如上圖，canal 模擬 MySQL Slave 的交互協議，讓自己偽裝成 MySQL Slave，並向 MySQL Master 發送 dump 協議，之後 MySQL Master 收到 dump 請求，開始推送 binlog 给 Slave (即 canal)，之後 canal 再解析 binlog，就能再去同步到快取或是做其他事情。</p></blockquote><h2 id="小結">小結 :</h2><blockquote><p>canal 其實是基於 MySQL 解決一致性的方法作延伸來達成快取架構，但也代表其綁定了 MySQL，如果你是使用其他關聯式資料庫就不適用，可能需要另外找解法。</p><p>在之後的文章裡，我們會探討 Meta 是如何設計快取架構的，由於不是基於單一資料庫的延伸，他的架構會更加的複雜，以達到 99.99999999% 的快取寫入一致性。</p></blockquote><h2 id="參考">參考 :</h2><ul><li><a href="https://github.com/alibaba/canal">canal 官方開源</a></li><li><a href="https://github.com/xingwenge/canal-php">canal-php(基於 canal)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 快取 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cache </tag>
            
            <tag> 系統架構 </tag>
            
            <tag> Consistency </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快取的一致性難題與架構模式 (上)</title>
      <link href="/2023/05/07/Cache/CacheConsistency/"/>
      <url>/2023/05/07/Cache/CacheConsistency/</url>
      
        <content type="html"><![CDATA[<h2 id="快取是什麼">快取是什麼 :</h2><blockquote><p>我們都知道電腦的核心運算是由 CPU 負責的，而我們的主要的資料儲存單元是硬碟，由於要在硬碟裡面搜尋資料並帶回來是一件時間成本極高的事，所以就有了<strong>將找過的資料暫存起來</strong>的概念，如下圖 :</p><p><img src="/images/cacheIO.png" alt=""></p><p>CPU 會先在 CPU Cache 裡尋找資料，當發現沒有之後就會去 main memory(DRAM) 找，再沒有才會去硬碟找。<br>找到之後就會一路寫回來，這樣你下次要找同樣資料時就不用再跑這麼遠去硬碟找。</p><p>我們之後會探討的快取就是 main memory(DRAM) 與硬碟的這一塊。</p></blockquote><h2 id="為什麼要使用快取">為什麼要使用快取 :</h2><blockquote><ol><li>DB 很慢 : 因為 RDBMS 需要保證 <a href="https://zh.wikipedia.org/zh-tw/ACID">ACID</a>，所以必須等待整個流程跑完。</li><li>DB 很貴 : 由於 RDBMS 的資料儲存在硬碟，會需要更多次 IO，上面已說明過。</li><li>DB 很遠 : 當你的 DB 建在新加坡，對於台灣用戶來說網路距離增加，傳輸速度也慢。</li></ol></blockquote><h2 id="為什麼快取會有一致性難題">為什麼快取會有一致性難題 :</h2><blockquote><p>如果你是分散式系統，那就一定逃不過 <a href="https://zh.wikipedia.org/zh-tw/CAP%E5%AE%9A%E7%90%86">CAP 定理</a>，但如果我只在單一台電腦上同時裝 Cache(ex. Redis) 和 DB(ex. MySQL)，還會有一致性難題嗎？讓我們接著以實作方式來探討。</p></blockquote><h2 id="快取模式-Read-Aside">快取模式 - Read Aside :</h2><blockquote><p><img src="/images/cacheReadAside.png" alt=""></p><ul><li>讀：先從 Cache 讀，讀到就回，沒讀到就從 DB 讀然後寫回 Cache。</li><li>寫：先寫回 DB，接著清掉 Cache。</li></ul><p>大部分情況都會正常，因為架構很簡單所以是常見的做法。<br>缺點為極端情況下不符合一致性，因為先對 DB 做事再去同步 Cache，所以同步前的時間差會導致非一致性。</p><ul><li>問題一 : A 寫了新資料，但還沒同步到 Cache 前 B 就去讀 Cache 的資料，導致不一致。</li></ul><p><img src="/images/cacheReadAsideProblem1.png" alt=""></p><ul><li>問題二 : A 寫了新資料，但要去同步到 Cache 時出了狀況，導致 DB 和 Cache 不一致。</li></ul><p><img src="/images/cacheReadAsideProblem2.png" alt=""></p><ul><li>問題三 : A 讀資料時發現 Cache 沒資料，所以去 DB 讀，但在寫回 Cache 前 B 就已經更新此資料並清掉Cache 了，這時候 A 才將舊資料寫回 Cache，導致不一致。</li></ul><p><img src="/images/cacheReadAsideProblem3.png" alt=""></p></blockquote><h2 id="快取模式-Double-Delete">快取模式 - Double Delete :</h2><blockquote><p><img src="/images/cacheReadAside.png" alt=""></p><ul><li>讀：先從 Cache 讀，讀到就回，沒讀到就從 DB 讀然後寫回 Cache。</li><li>寫：先清掉 Cache 再寫回 DB，接著<strong>等一下</strong>(依需求調整，例如 0.5s) 再清掉 Cache。</li></ul><p>我們可以發現他和 Read Aside 只差在寫的部分，原理是先避免其他人讀到舊資料，之後寫入 DB，先等一下再清掉 Cache 的過程則是為了減少 Read Aside 的問題三發生機率，所以雖然一致的機率提高了，但終究是會在極端情況下不符合一致性。</p></blockquote><h2 id="快取模式-Read-through">快取模式 - Read through :</h2><blockquote><p><img src="/images/cacheReadThrough.png" alt=""></p><ul><li>讀：先從 Cache 讀，讀到就回，沒讀到就<strong>由 Cache 從 DB 讀</strong>。</li><li>寫：無所謂，通常結合 Write Through 或 Write Behind 使用。</li></ul><p>注意<strong>由 Cache 從 DB 讀</strong>的實現 Redis 並不支援，NCache 則是需要收費。<br>可以自己實作 Data Access Layer(DAL)，在 DAL 裡用內部 api 伺服器去決定讀 Cache 還是 DB，而對於應用程式來說並不需要知道到底打了誰或是有沒有緩存，他只要知道可以透過 DAL 快速得到資料就好。</p></blockquote><h2 id="快取模式-Write-through">快取模式 - Write through :</h2><blockquote><p><img src="/images/cacheReadThrough.png" alt=""></p><ul><li>讀：無所謂，通常結合 Read Through 使用。</li><li>寫：只更新 Cache，並<strong>由 Cache 去更新 DB</strong>。</li></ul><p>注意跟 Read through 一樣，<strong>由 Cache 去更新 DB</strong> 的實現 Redis 並不支援，NCache 則是需要收費。<br>所以一樣可以藉由實作 Data Access Layer(DAL)來實現。</p><p>也就是說，當你使用 Read through + Write through 來實作快取架構，相當於你都只對 DAL 操作，這樣的優點是可以解決 Read Aside 的問題，但也引發了新的問題 :</p><ol><li>速度慢，因為你同時要寫完 Cache 和 DB 才算完成。</li><li>如果你不是用 DAL 而是原生支援 DB 連線的 Cache 的話，如果在 Cache 未寫入 DB 前就斷電重啟的話，那筆尚未更新到 DB 的資料就會永久遺失。</li></ol></blockquote><h2 id="快取模式-Write-Ahead-Behind-Back">快取模式 - Write Ahead (Behind)(Back) :</h2><blockquote><p><img src="/images/cacheWriteAhead.png" alt=""></p><ul><li>讀：無所謂，通常結合 Read Through 使用。</li><li>寫：需實作 DAL，並<strong>由 DAL 去更新 Cache 和 DB</strong>。</li></ul><p>和 Write through 不一樣需實作 DAL，並且會使用 Message Queue 來管理請求，這樣就可以避免 Cache 永久遺失資料的問題，也可以進一步實現對資料庫的批次寫入以減少寫入次數(Write Back)，但這樣的架構不好實現，需要處理非常多的細節，除非你真的需要這樣的可靠性，不然直接實作 Read Aside 是最簡單的。</p></blockquote><h2 id="小結">小結 :</h2><blockquote><p>介紹了這麼多不同做法，我們應該可以深刻體會一致性的難題有多複雜，以及這些架構背後可能會需要付出的成本，所以在決定你要如何實現快取架構前，你應該先考慮 :</p><ol><li>你的情境為何？為什麼要使用快取？</li><li>你的快取機器要求會有多高？會不會需要分散式？</li><li>比較看重的是一致性還是可用性？</li><li>哪些動作的延遲是可以接受的？哪些不行？讀跟寫的需求那個比較重？</li><li>你的快取需要多高的一致性保證？例如 Meta 可以保證 99.99999999% 的快取寫入一致性。</li></ol><p>在之後的文章裡，我們會探討阿里巴巴和 Meta 是如何設計快取架構的，雖然絕大多數的公司都不需要實現如此高的一致性，但他們的架構還是值得了解。</p></blockquote><h2 id="參考">參考 :</h2><ul><li><a href="https://web.ntnu.edu.tw/~algo/AlgorithmDesign.html#11">I/O-efficient Algorithm</a></li><li><a href="https://hackmd.io/@drwQtdGASN2n-vt_4poKnw/H1U6NgK3Z">CPU Cache 原理探討</a></li><li><a href="https://www.cs.pu.edu.tw/~bcc/93course/ch18.pdf">計算機組織與結構</a></li><li><a href="https://medium.com/starbugs/consistency-between-cache-and-database-part-1-f64f4a76720">Consistency between Cache and Database, Part 1</a></li><li><a href="https://medium.com/starbugs/consistency-between-cache-and-database-part-2-e28fc7f8a7c3">Consistency between Cache and Database, Part 2</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10224938">資料緩存失效問題</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 快取 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cache </tag>
            
            <tag> 計算機組織 </tag>
            
            <tag> 系統架構 </tag>
            
            <tag> Message queue </tag>
            
            <tag> Consistency </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 49. Group Anagrams</title>
      <link href="/2023/05/05/LeetCode/GroupAnagrams/"/>
      <url>/2023/05/05/LeetCode/GroupAnagrams/</url>
      
        <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://leetcode.com/problems/group-anagrams/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給定一個字串陣列 strs，需要把每個字串依據 anagram 做分類放進不同的陣列後回傳。<br>相同 anagram 定義 : 若字串 s 的字元出現頻率與字串 t 相同，則他們為同一個 anagram。</p><p>例如輸入 strs=[“eat”,“tea”,“tan”,“ate”,“nat”,“bat”]，應回傳 [[“bat”],[“nat”,“tan”],[“ate”,“eat”,“tea”]]，不看順序。</p><ul><li>1 &lt;= strs.length &lt;= 10^4</li><li>0 &lt;= strs[i].length &lt;= 100</li><li>strs 裡的每個字串都只由小寫英文字組成</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>原本想到的作法是每個字串做一個<strong>字符出現次數表</strong>，但這樣的時間複雜度就會變成「字串總數 * (每個字串的最大長度 * 當下有的出現次數表(最大等於字串總數) * 當下有的出現次數表最大長度)，光看就不可行。</p><p>後來想說既然存出現次數陣列沒比較快，那就改成<strong>存排序後的不重複字串</strong>，也就是對每個字串做排序後去比較我們存過的不重複字串，時間複雜度會變成「字串總數 * 最大字串排序的時間複雜度」。而因為基本上排序演算法最快也要 O(MlogM)，所以當字串總數 N 且最大字串長度 M 時，時間複雜度會是 O(N * MlogM)。</p><p>最後是參考別人的答案 : 方法一之所以慢是因為你沒有辦法在 O(K) 的時間複雜度內找到他是否有符合已找過的 K 個 anagram 種類之一，而方法二雖然成功讓其降到 O(K)，卻因為需要做排序導致變成 O(MlogM)，所以最後這個方法三就是讓你不需排序也能達到 O(K) 甚至更快。</p><p>具體來說，我們可以發現題目確保每個字串都是小寫字母，也就是說他們本來就有順序的關係性在，由於 a 的 ASCII 值是 97，而 b 是 98，以此類推到 z，所以可以將每個小寫字母(a~z)減去 a 的值當作索引，剛好就會是索引從 0 開始排到 25 的陣列，你就可以用這個陣列當作有序的字符出現次數表，之後將這個陣列轉成字串當作陣列索引，你就能在 O(1) 的時間複雜度內找到他是否有符合已找過的 anagram 種類之一。</p><p>需要注意的陷阱是每個字母出現的次數有可能超過十位數，就代表如果你將陣列轉成字串的作法是直接把次數串在一起就會錯，例如下圖的第二個範例 :</p><p><img src="/images/GroupAnagramsExample1.jpg" alt=""></p><p>所以說我們在串聯時可以加上特殊標記來區分，例如 :</p><p><img src="/images/GroupAnagramsExample2.jpg" alt=""></p><p>這樣就不會搞混了。</p><ul><li>時間複雜度 O(N * M)，N 為字串總數，M 為最大字串長度</li><li>空間複雜度 O(N)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/app/LeetCode/Blind75/Array/GroupAnagrams.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/tests/Unit/LeetCode/Blind75/Array/GroupAnagramsTest.php">單元測試</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Array </tag>
            
            <tag> HashTable </tag>
            
            <tag> 演算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Blind75 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 242. Valid Anagram</title>
      <link href="/2023/05/03/LeetCode/ValidAnagram/"/>
      <url>/2023/05/03/LeetCode/ValidAnagram/</url>
      
        <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://leetcode.com/problems/valid-anagram/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給定兩個字串 s 和 t，你必須判斷 s 是不是 t 的 anagram，若是則回傳 true，不是則回傳 false。</p><p>s 必須符合以下兩個條件才能算是 t 的 anagram :</p><ol><li>s 和 t 字串長度相同</li><li>s 和 t 有相同的字元數且各字元出現次數相同</li></ol><p>例如輸入 s = “anagram”, t = “nagaram”，應回傳 true。<br>輸入 s = “rat”, t = “car”，則回傳 false</p><ul><li>1 &lt;= s.length, t.length &lt;= 5*10^4</li><li>s 和 t 都只由小寫英文字組成。</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>原本想到的作法是遍歷 s 並記錄 s 中各字母出現次數，之後再遍歷 t 並用紀錄的陣列去減，如果有新字母或出現次數變成負數的情況就代表兩者不相同，但這樣做會導致最差情況(s 是 t 的 anagram)必須遍歷兩次 s 長度。</p><p>後來發現其實根本不需要分開遍歷，因為你可以<strong>從記錄 s 變成紀錄兩者差距</strong>，也就是 s 有的就加，t 有的就減，這樣你就只需要遍歷找完的字母出現次數差異陣列，發現有字母出現次數不等於 0 的時候就代表失敗。雖然最差情況(s 是 t 的 anagram 且字母出現次數不重複)也是遍歷兩次 s 長度，但這只會發生在剛好 26 個字母的時候，所以絕大情況下這個做法都是實際效能更高的。</p><ul><li>時間複雜度 O(N)，如何證明檢查存在鍵與拿取存放的時間複雜度請 <a href="/2022/10/19/PHPArray/">參考我的另一篇文章 - PHP Array</a></li><li>空間複雜度 O(N)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/app/LeetCode/Blind75/Array/ValidAnagram.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/tests/Unit/LeetCode/Blind75/Array/ValidAnagramTest.php">單元測試</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Array </tag>
            
            <tag> HashTable </tag>
            
            <tag> 演算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Blind75 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 217. Contains Duplicate</title>
      <link href="/2023/05/02/LeetCode/ContainsDuplicate/"/>
      <url>/2023/05/02/LeetCode/ContainsDuplicate/</url>
      
        <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://leetcode.com/problems/contains-duplicate/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給定一個整數陣列 nums，你必須判斷 nums 中是否有元素值是重複出現的，若有則回傳 true，沒有則回傳 false。</p><p>例如輸入 nums=[1, 2, 3, 1]，由於元素值 1 重複出現，所以回傳 true。<br>而若輸入 nums=[1, 2, 3, 4]，由於元素值都沒有重複出現，所以回傳 false。</p><ul><li>1 &lt;= nums.length &lt;= 10^5</li><li>-10^9 &lt;= nums[i] &lt;= 10^9</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>這題比 <a href="/2023/05/02/LeetCode/TwoSum/">TwoSum</a> 更簡單，因為我們不需要知道重複的元素分別在哪裡，只需要知道當檢查到重複元素值時就回傳 true 就好。</p><p>所以一樣可以花一點空間來換時間，也就是用另一個陣列來邊找邊記錄我們已找過的值，當發現 nums[i] 已經有找過時，就代表要回傳 true。</p><ul><li>時間複雜度 O(N)，如何證明檢查存在鍵與拿取存放的時間複雜度請 <a href="/2022/10/19/PHPArray/">參考我的另一篇文章 - PHP Array</a></li><li>空間複雜度 O(N)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/app/LeetCode/Blind75/Array/ContainsDuplicate.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/tests/Unit/LeetCode/Blind75/Array/ContainsDuplicateTest.php">單元測試</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Array </tag>
            
            <tag> HashTable </tag>
            
            <tag> 演算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Blind75 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1. Two Sum</title>
      <link href="/2023/05/02/LeetCode/TwoSum/"/>
      <url>/2023/05/02/LeetCode/TwoSum/</url>
      
        <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://leetcode.com/problems/two-sum/">官網題目連結</a></p><blockquote><p>最經典的 LeetCode 第一題，求兩數之和！</p><p>根據題目敘述，會給定一個整數陣列 nums，還有一個整數 target，你必須找出 nums 中哪兩個元素相加會等於 target，用陣列回傳他們的索引。</p><p>例如輸入 nums=[2, 7, 11, 15], target=9，由於前兩個元素 2+7=9 剛好就是答案，所以回傳 [0 ,1]，題目特別說<strong>不看順序</strong>所以你要回傳 [1, 0] 也可以。</p><ul><li>2 &lt;= nums.length &lt;= 10^4</li><li>-10^9 &lt;= nums[i] &lt;= 10^9</li><li>-10^9 &lt;= target &lt;= 10^9</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>沒碰過演算法的人可能一開始都會想到用暴力解，也就是先用第 1 個去對剩下 N-1，再用第 2 個去對剩下 N-2 個，但這樣的做法會導致運算次數變成等差數列總和，也就是時間複雜度 O(N^2)。</p><p>我們可以花一點空間來換時間，也就是用另一個陣列來邊找邊記錄我們已找過的值，當發現 target - nums[i] 已經有找過時，就代表這是答案。</p><ul><li>時間複雜度 O(N)，如何證明檢查存在鍵與拿取存放的時間複雜度請 <a href="/2022/10/19/PHPArray/">參考我的另一篇文章 - PHP Array</a></li><li>空間複雜度 O(N)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/app/LeetCode/Blind75/Array/TwoSum.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/tests/Unit/LeetCode/Blind75/Array/TwoSumTest.php">單元測試</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Array </tag>
            
            <tag> HashTable </tag>
            
            <tag> 演算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Blind75 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Linux 的 systemd 來保持你的服務吧 !</title>
      <link href="/2023/05/01/SystemdToKeepAlive/"/>
      <url>/2023/05/01/SystemdToKeepAlive/</url>
      
        <content type="html"><![CDATA[<h2 id="簡介">簡介 :</h2><blockquote><p>systemd 基於一個事件驅動的機制，它可以同時啟動並管理多個服務，並在服務失敗或系統崩潰時自動重啟服務。它還提供了各種管理命令和工具，用於管理系統日誌、網絡配置、作業系統時間等等…。</p></blockquote><h2 id="首先，移動到系統單位檔案的存放位置">首先，移動到系統單位檔案的存放位置 :</h2><pre><code class="language-sh">cd /etc/systemd/system   # 我是用 ubuntu 22.04 版本，如果你路徑不一樣請自己找</code></pre><h2 id="建立系統單位檔案">建立系統單位檔案 :</h2><pre><code class="language-sh">touch &lt;your service name&gt;.service</code></pre><h2 id="打開你建立的檔案並寫入設定">打開你建立的檔案並寫入設定 :</h2><pre><code class="language-sh">[Unit]Description=&lt;write your description&gt;[Service]# 讓 systemd 知道編譯器和啟動檔案在哪，以及啟動方式，一般來說你怎麼啟動的就直接貼過來，不過他不吃你的 $PATH 所以要給完整路徑ExecStart=/usr/bin/python3 -u /home/ubuntu/projects/DiscordBot/main.py  WorkingDirectory=/home/ubuntu/projects/DiscordBot/User=ubuntu  # 要記得確保有權限讀取和執行 WorkingDirectory 底下所有檔案Group=ubuntu  # 要記得確保有權限讀取和執行 WorkingDirectory 底下所有檔案Restart=on-failure[Install]WantedBy=multi-user.target</code></pre><h2 id="開始執行">開始執行 :</h2><pre><code class="language-sh">sudo systemctl start &lt;your service name&gt;.service</code></pre><h2 id="查看服務狀態">查看服務狀態 :</h2><pre><code class="language-sh">sudo systemctl status &lt;your service name&gt;.service</code></pre><h2 id="當你有變更你的-service-內容時，需要先-reload">當你有變更你的 .service 內容時，需要先 reload :</h2><pre><code class="language-sh">sudo systemctl daemon-reload</code></pre><h2 id="其他語法">其他語法 :</h2><ul><li>設定為啟動系統時就自動啟動 :</li></ul><pre><code class="language-sh">sudo systemctl enable &lt;your service name&gt;.service</code></pre><ul><li>停止服務 :</li></ul><pre><code class="language-sh">sudo systemctl stop &lt;your service name&gt;.service</code></pre><ul><li>重啟服務 :</li></ul><pre><code class="language-sh">sudo systemctl restart &lt;your service name&gt;.service</code></pre><ul><li>查看錯誤日誌 :</li></ul><pre><code class="language-sh">journalctl -u &lt;your service name&gt;.service</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> systemd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Postman 實現 api 自動測試吧 !</title>
      <link href="/2023/04/30/PostMan/PostmanTest/"/>
      <url>/2023/04/30/PostMan/PostmanTest/</url>
      
        <content type="html"><![CDATA[<h2 id="Postman-工作區目錄架構">Postman 工作區目錄架構 :</h2><blockquote><p>Postman 的工作區目錄架構為 Collection、Folder、Request、Example，如下圖 :</p><p><img src="/images/postmanStructure.png" alt=""></p><p>注意只有 Folder 可以自己包自己。</p><p>我們可以寫測試的範圍有 Collection、Folder、Request，不包含 Example，原因為 Example 只是把一些參數取出來單獨設定而已，他要執行時會將這些參數覆寫到繼承的 Request 並執行，但終究還是歸附於 Request，所以也會執行 Request 寫好的測試。</p></blockquote><h2 id="自動測試的執行順序">自動測試的執行順序 :</h2><blockquote><p>在 Collection、Folder、Request 界面中我們都可找到和設定「Pre-request Script」以及「Tests」，顧名思義就是一個是先跑的腳本、另一個是最後才跑的腳本，我們假設範例為 Collection 包 Folder 包 Request，且都有設定「Pre-request Script」以及「Tests」，那麼當你按下 Send Request 後的執行順序就是 :</p><ol><li>Collection Pre-request Script</li><li>Folder Pre-request Script</li><li>Request Pre-request Script</li><li>Request 本身</li><li>Request Tests</li><li>Folder Tests</li><li>Collection Tests</li></ol><p>從這樣的順序也很明顯可以看出 :</p><ul><li>Pre-request Script 在打 api 前就執行了，可以做的事有檢查參數、預打其他 api 拿 token 等等…。</li><li>Tests 是在打 api 後執行的，可以做的事有檢查回傳狀態、檢查回傳內容等等…。</li></ul></blockquote><h2 id="如何撰寫測試">如何撰寫測試 :</h2><blockquote><p>Postman 的腳本撰寫語法是基於 JavaScript，並提供物件 pm 以供操作，至於詳細有哪些用法官網已經寫得很清楚了，參考 :</p><ul><li><a href="https://learning.postman.com/docs/writing-scripts/pre-request-scripts/">Writing pre-request scripts</a></li><li><a href="https://learning.postman.com/docs/writing-scripts/test-scripts/">Writing tests</a></li></ul></blockquote><h2 id="範例一，打-api-前檢查當前用的-Postman-環境變數">範例一，打 api 前檢查當前用的 Postman 環境變數 :</h2><blockquote><p>情境 : 因為有時候打不同台伺服器或本地時忘了切換環境變數，會導致我對應的 domain 值壞掉。</p></blockquote><pre><code class="language-JavaScript">pm.test(&quot;檢查環境變數&quot;, function () &#123;     pm.expect(pm.environment.get(&quot;domain&quot;)).to.be.oneOf([        &quot;打卡系統正式機&quot;,        &quot;打卡系統測試機&quot;    ]); &#125;);</code></pre><blockquote><p>像這個範例你就可以寫在 Collection 的 Pre-request Script，因為通常一個 Collection 就對應一個系統、服務，其底下的 Request 應該都是吃同一種環境變數。</p></blockquote><h2 id="範例二，檢查-api-response-的狀態">範例二，檢查 api response 的狀態 :</h2><blockquote><p>情境 : 我希望知道此次回傳是否成功(這範例其實蠻雞肋的啦，因為本來界面就會顯示了)。</p></blockquote><pre><code class="language-JavaScript">pm.test(&quot;檢查回傳狀態&quot;, function () &#123;    pm.response.to.have.status(200);&#125;);</code></pre><h2 id="範例三，檢查-api-request-的-JSON-Schema">範例三，檢查 api request 的 JSON Schema :</h2><blockquote><p>情境 : 有時候你邊寫邊打就忘了有些 request 參數忘了改，這時候就能檢查。<br>注意 : Postman 用的 jsonSchema 是最新版的，你需要注意自己使用的版本是否有落差，因為寫法會變。<br>以筆者撰寫這篇文章的時間點來說是 3.1 或以上。</p></blockquote><pre><code class="language-JavaScript">// 定義期望的 JSON Schemalet schema = &#123;    &quot;type&quot;: &quot;object&quot;,    &quot;properties&quot;: &#123;        &quot;orderId&quot;: &#123;            &quot;type&quot;: [&quot;integer&quot;, &quot;null&quot;],        &#125;,        &quot;isVoid&quot;: &#123;            &quot;type&quot;: [&quot;boolean&quot;, &quot;null&quot;],        &#125;    &#125;&#125;// 檢查pm.test(&quot;檢查請求 json 是否符合期望的 jsonSchema&quot;, function () &#123;     pm.request.to.have.jsonSchema(schema);&#125;);</code></pre><h2 id="範例四，檢查-api-response-的-JSON-Schema">範例四，檢查 api response 的 JSON Schema :</h2><blockquote><p>情境 : 我希望回傳的 key 都符合我的期望，例如期望是整數那就不能回傳字串。<br>用法跟上面幾乎一樣，只是你要改從 response 拿而已。</p></blockquote><pre><code class="language-JavaScript">// 定義期望的 JSON Schemalet schema = &#123;    &quot;type&quot;: &quot;object&quot;,    &quot;properties&quot;: &#123;        &quot;typeId&quot;: &#123;            &quot;type&quot;: [&quot;integer&quot;, &quot;null&quot;],        &#125;,        &quot;statusId&quot;: &#123;            &quot;type&quot;: [&quot;integer&quot;, &quot;null&quot;],        &#125;,        &quot;supplierCode&quot;: &#123;            &quot;type&quot;: [&quot;integer&quot;, &quot;null&quot;],        &#125;,        &quot;customerName&quot;: &#123;            &quot;type&quot;: [&quot;string&quot;, &quot;null&quot;],        &#125;    &#125;&#125;;// 檢查pm.test(&quot;檢查回傳 json 是否符合期望的 jsonSchema&quot;, function () &#123;     pm.response.to.have.jsonSchema(schema);&#125;);</code></pre><blockquote><p>你可能會覺得定義 jsonSchema 很麻煩，沒錯！因為我也這樣覺得，所以在這邊提供方法 :</p><ol><li><p>一般來說都會有寫 swagger 給前端對接用，那你就直接拿這個用就好了，簡單粗暴，像 Laravel 框架可以使用 : php artisan l5-swagger:generate 的指令快速產出。</p></li><li><p>你的 request 或 response 在 Postman 上都有完整 JSON 了，所以你可以使用 <a href="https://jsonschema.net/app/schemas">JSON Schema – json 轉 jsonschema</a> 快速轉換，但最麻煩的就是 nullable 你要自己加。</p></li></ol><p><a href="/2023/04/29/ThirdParty/">參考我的另一篇文章 - 常用的第三方工具</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Postman </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Postman </tag>
            
            <tag> 自動化測試 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的第三方工具</title>
      <link href="/2023/04/29/ThirdParty/"/>
      <url>/2023/04/29/ThirdParty/</url>
      
        <content type="html"><![CDATA[<h2 id="工作中用過的一些第三方工具：">工作中用過的一些第三方工具：</h2><ul><li><p><a href="https://regex101.com/">regex101 – 線上測試正規表達式工具</a></p></li><li><p><a href="https://crontab.guru/">crontab guru – 線上測試 corntab 語法工具</a></p></li><li><p><a href="https://sequencediagram.org/">sequencediagram – 畫時序圖工具</a></p></li><li><p><a href="https://app.diagrams.net/">Draw.io – 畫圖工具</a></p></li><li><p><a href="http://sqlfiddle.com/">SQL Fiddle – 線上資料庫工具</a></p></li><li><p><a href="https://dbdiagram.io/home">dbdiagram – 資料庫工具</a></p></li><li><p><a href="https://dbschema.com/">dbSchema – 資料庫工具</a></p></li><li><p><a href="https://jsoneditoronline.org/#left=local.ranopi&amp;right=local.vosuzi">json editor – JSON 比對工具</a></p></li><li><p><a href="https://jsonschema.net/app/schemas">JSON Schema – json 轉 jsonschema</a></p></li><li><p><a href="https://shancarter.github.io/mr-data-converter/">Mr. Data Converter – CSV 轉其他格式</a></p></li><li><p><a href="https://slack.com/intl/zh-tw">Slack – 團隊溝通</a></p></li><li><p><a href="https://www.invisionapp.com/">InVision – 前端畫面工具</a></p></li><li><p><a href="https://www.figma.com/">figma – UI 設計工具</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 第三方工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第三方工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>讓你的 git commit message 更容易閱讀</title>
      <link href="/2023/04/29/git/GitCommitMessage/"/>
      <url>/2023/04/29/git/GitCommitMessage/</url>
      
        <content type="html"><![CDATA[<h2 id="讓版控更加容易追蹤">讓版控更加容易追蹤 :</h2><blockquote><p>習慣上會將每個 commit 的內容盡量限縮在<strong>單一單元或一件事</strong>上，以讓你的 commit message 和異動處能夠簡潔的對應，對於自己或團隊成員在追蹤進度、回顧異動上都能提高效率。</p><p>在這之上能更快表達此次 commit 意義的做法，就是在 commit message 開頭加上<strong>前綴字</strong>，常見的有 :</p><ul><li>feat : 新增/修改功能 (feature)。</li><li>fix : 修補 bug (bug fix)。</li><li>docs : 文件 (documentation)。</li><li>style : 格式 (不影響程式碼運行的變動 white-space, formatting, missing semi colons, etc)。</li><li>refactor : 重構 (既不是新增功能，也不是修補 bug 的程式碼變動)。</li><li>perf : 改善效能 (A code change that improves performance)。</li><li>test : 增加測試 (when adding missing tests)。</li><li>chore : 建構程序或輔助工具的變動 (maintain)。</li><li>revert : 撤銷回覆先前的 commit 例如：revert: type(scope): subject (回覆版本：xxxx)。</li></ul><p>加上前綴字之後一看就能先猜到在做什麼，之後再閱讀你改動的訊息就能更快進入狀況。</p></blockquote><h2 id="參考">參考</h2><ul><li><a href="https://wadehuanglearning.blogspot.com/2019/05/commit-commit-commit-why-what-commit.html">Git Commit Message 這樣寫會更好，替專案引入規範與範例</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> style </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codility Lesson MissingInteger</title>
      <link href="/2023/04/27/Codility/CodilityLessonMissingInteger/"/>
      <url>/2023/04/27/Codility/CodilityLessonMissingInteger/</url>
      
        <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://app.codility.com/programmers/lessons/4-counting_elements/missing_integer/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給一個由 N 個整數組成的陣列 A。需找出 A 中沒有出現且大於 0 的最小正整數。<br>例如輸入 A=[1, 3, 6, 4, 1, 2]，答案應為 5。<br>A=[1, 2, 3]，答案應為 4。<br>A=[-1, -3]，答案應為 1。</p><ul><li>N 是範圍 [1~100000] 的整數。</li><li>陣列 A 裡的元素都是範圍 [−1000000~1000000] 的整數。</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>第一時間還是想到了記憶法，先遍歷 A 記錄走過的不重複合法值，之後再遍歷記錄到的合法值來找出第一個 合法總數+1 的範圍內沒有記錄到的合法值。</p><p>總覺得還有機會想出跟 <a href="/2023/04/25/Codility/CodilityLessonMaxCounters/">MaxCounters</a> 一樣將當前最小值與合法最小值分開存的方法，就不用分兩次遍歷，但目前仍未想到。</p><ul><li>時間複雜度 O(N)</li><li>空間複雜度 O(N)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/CountingElements/MissingInteger.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/CountingElements/MissingIntegerTest.php">單元測試</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Codility </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 演算法 </tag>
            
            <tag> Codility </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codility Lesson MaxCounters</title>
      <link href="/2023/04/25/Codility/CodilityLessonMaxCounters/"/>
      <url>/2023/04/25/Codility/CodilityLessonMaxCounters/</url>
      
        <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://app.codility.com/programmers/lessons/4-counting_elements/max_counters/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給一個由 N 個整數組成的陣列 A 以及一個整數 M，你必須照順序遍歷 A 並執行以下判斷，之後返回結果陣列 R (包含 M 個整數) :</p><ul><li>當遍歷到 A[K]=X，且 1 ≤ X ≤ N 時，結果陣列 R[K-1] 的值要加 1。</li><li>當遍歷到的 A[K]=N+1，則 R 中所有元素值都必須統一成當前 R 的最大元素值。</li></ul><p>例如輸入 A=[3, 4, 4, 6, 1, 4, 4]，M=5 :</p><ol><li>當 K=0，A[K]=3，R[3-1] 要加 1，R 就變成 [0, 0, 1, 0, 0]</li><li>當 K=1，A[K]=4，R[4-1] 要加 1，R 就變成 [0, 0, 1, 1, 0]</li><li>當 K=2，A[K]=4，R[4-1] 要加 1，R 就變成 [0, 0, 1, 2, 0]</li><li>當 K=3，A[K]=6，R[6-1] 等於 M+1，R 所有元素要等於當前最大元素 2，所以 R 就變成 [2, 2, 2, 2, 2]</li><li>當 K=4，A[K]=1，R[1-1] 要加 1，R 就變成 [3, 2, 2, 2, 2]</li><li>當 K=5，A[K]=4，R[4-1] 要加 1，R 就變成 [3, 2, 2, 3, 2]</li><li>當 K=6，A[K]=4，R[4-1] 要加 1，R 就變成 [3, 2, 2, 4, 2]，因為遍歷完了，所以 R 已是答案。</li></ol><p>其實題目沒有要你遍歷，只是講計數規則，但這題不遍歷不能解，我覺得這樣寫題目說明應該比較好懂，如果你有想到不遍歷的方法歡迎在下方留言討論。</p><ul><li>N 和 M 都是範圍 [1~100000] 的整數。</li><li>陣列 A 裡的元素都是範圍 [1~N+1] 的整數。</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>最棘手的部分就在於「當 A[K]=N+1，R 中所有元素值都必須統一成當前 R 的最大元素值」，因為如果你要將 R 所有數字都即時更新成最大值的話，你的時間複雜度就會變成 O(N*M)，而這顯然不是最好的答案。</p><p>那麼如果我不要即時統一，而是只紀錄這個觸發要統一的事實，並在之後的點替換成最大值呢 ?<br>感覺是可行的方向，但要如何實現需要思考一下，我們會發現當你觸發統一時，假設當前 R 最大元素是 3，代表之後如果遇到小於 3 的元素就是尚未統一過的元素，而如果之後又觸發統一，且當前 R 最大元素變成 5，那麼之後遇到小於 5 的元素就是尚未統一過的元素，我們並不需要擔心他到底有沒有統一成 3 過了，因為反正他都比 5 小，我們不需要記錄他的所有歷程。</p><p>具體來說我們除了需要紀錄 R 的最大元素值 max 之外，還需要知道要統一的目標數字是多少，所以會需要另一個變數 needToAdd 來處理，有點像雙指標的概念，max 永遠紀錄最大值，而當觸發統一時 needToAdd 會即時跟上 max。</p><p>最後，因為有可能有 M 中的元素完全沒被加過，你沒辦法幫他處理統一，所以你還需要遍歷一次 M，將 M 沒被統一的值做統一，因此所需的時間複雜度就是 N 和 M 個只遍歷一次，為 O(N+M)。</p><p>這題在 Codility 算 medium，感覺確實比起其他 Lesson 更有挑戰一點，不過以體感來說應該還是只有 LeetCode 的 easy 難度而已。</p><ul><li>時間複雜度 O(N+M)</li><li>空間複雜度 O(M)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/CountingElements/MaxCounters.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/CountingElements/MaxCountersTest.php">單元測試</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Codility </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 演算法 </tag>
            
            <tag> Codility </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codility Lesson PermCheck</title>
      <link href="/2023/04/24/Codility/CodilityLessonPermCheck/"/>
      <url>/2023/04/24/Codility/CodilityLessonPermCheck/</url>
      
        <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://app.codility.com/programmers/lessons/4-counting_elements/perm_check/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給一個包含 N 個元素的<strong>非空</strong>陣列 A。你必須檢查 A 中是否包含所有 1~N 的整數值且不重複(其實這有點廢話，因為當滿足包含所有 1~N 的整數時本來就不可能有重複)</p><p>例如輸入 A=[4, 1, 3, 2]，滿足所有 1~4 且不重複，所以回傳 1。<br>而如果輸入 A=[4, 1, 3]，不滿足所有 1~3 且不重複，所以回傳 0。</p><ul><li>N 是範圍 [1~100000] 的整數。</li><li>陣列 A 裡的所有元素都是範圍 [1~1000000000] 的整數</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>這邊容易疏忽的點應該是並不保證餵進來的陣列其值都不重複，所以你不能用等差數列來解，依然需要紀錄走了哪些合法值，所以空間複雜度只能 O(N)。</p><p>再來由於一樣要追求遍歷一次就做完，所以我們需要找到規律，能先檢查的就是當發生重複(也就是當前遍歷值是已記錄過得合法值)時可以直接回傳 0，也就表示如果成功遍歷完一次 A ，就能確保 A 是<strong>元素不重複</strong>的陣列，也就能確保當我們紀錄的<strong>不重複合法值陣列總數等同於其內部的最大元素值</strong>時，就代表符合需求。</p><p>因為有點饒舌所以用範例說明，當輸入 A=[4, 1, 3, 2] 時，我們遍歷一遍<strong>確保都不重複</strong>，並且會得到另一個不重複合法值陣列 B=[4, 1, 3, 2]，然後當 B 的元素總數 4 剛好等於他最大的元素 B[0]=4 時，就代表是正確的。</p><p>由於你邊遍歷就可以邊收集最大元素值了，所以總共只要遍歷一次就好。</p><ul><li>時間複雜度 O(N)</li><li>空間複雜度 O(N)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/CountingElements/PermCheck.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/CountingElements/PermCheckTest.php">單元測試</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Codility </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 演算法 </tag>
            
            <tag> Codility </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codility Lesson FrogRiverOne</title>
      <link href="/2023/04/24/Codility/CodilityLessonFrogRiverOne/"/>
      <url>/2023/04/24/Codility/CodilityLessonFrogRiverOne/</url>
      
        <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://app.codility.com/programmers/lessons/4-counting_elements/frog_river_one/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給一個鍵為 N，值為 K 的<strong>非空</strong>陣列 A。其中 N 表示秒數，K 表示位置，也就是第 N 秒時會有樹葉掉落到位置 K 上。</p><p>題目還會給一個整數 X 表示終點，你必須找出最少第幾秒時 1~X 的位置上都會有落葉。</p><p>例如輸入 A=[1, 3, 1, 4, 2, 3, <strong>5</strong>, 4]， X=5。<br>最少在第 6 秒時會有樹葉掉落到位置 5，且位置 1~5 都有樹葉，所以答案為 6。</p><p>如果 1~X 永遠不可能都有樹葉的話，你必須回傳 -1。</p><ul><li>N 是範圍 [1~100000] 的整數。</li><li>陣列 A 裡的所有元素都是範圍 [1~X] 的整數</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>這題不像 <a href="/2023/04/14/Codility/CodilityLessonPermMissingElem/">PermMissingElem</a> 一樣可以用等差數列去減，因為樹葉掉落的位置可能會出現重複的，所以始終是必須記錄走過的不重複合法位置有哪些，空間複雜度最低只能 O(N)。</p><p>而由於我們有紀錄走過的不重複合法位置，所以可以得知當你剛好找到第 X 個不重複合法值時，他的時間就會是答案，總共只需遍歷一次。</p><ul><li>時間複雜度 O(N)</li><li>空間複雜度 O(N)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/CountingElements/FrogRiverOne.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/CountingElements/FrogRiverOneTest.php">單元測試</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Codility </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 演算法 </tag>
            
            <tag> Codility </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Homebrew 懶人切換 php 版本</title>
      <link href="/2023/04/19/%E7%94%A8brew%E6%87%B6%E4%BA%BA%E5%88%87%E6%8F%9Bphp%E7%89%88%E6%9C%AC/"/>
      <url>/2023/04/19/%E7%94%A8brew%E6%87%B6%E4%BA%BA%E5%88%87%E6%8F%9Bphp%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<aside>💡 適用於 mac os 且使用 Homebrew 管理 php 環境</aside><hr><h2 id="核心為以下兩行">核心為以下兩行 :</h2><pre><code class="language-bash">brew unlink php@7.3 brew link -f php@8.1</code></pre><h2 id="每次都要記很煩所以寫了個簡單-script">每次都要記很煩所以寫了個簡單 script :</h2><p><a href="https://github.com/Koufuchi/php_version_switcher">GitHub - Koufuchi/php_version_switcher</a></p><h2 id="用命令行移動到-script-所在目錄，執行以下語法並指定版本即可切換：">用命令行移動到 script 所在目錄，執行以下語法並指定版本即可切換：</h2><pre><code class="language-bash">. ~/ps.sh 7.3  # 檔名自己取，執行時後面餵版本參數，如果參數錯誤則會列出你本機安裝的所有版本</code></pre><h2 id="或是真的超懶，就在-zshrc-中加入">或是真的超懶，就在 ~/.zshrc 中加入 :</h2><pre><code class="language-bash">export PATH=&quot;$PATH:/&lt;your script path&gt;/&quot;  # script 所在目錄</code></pre><h2 id="之後打開-terminal-後就直接輸入以下就好">之後打開 terminal 後就直接輸入以下就好 :</h2><pre><code class="language-bash"> ps.sh 7.3 </code></pre><p>注意所有指令都會跑去你指定的目錄對，所以其實不太推薦這樣玩</p>]]></content>
      
      
      <categories>
          
          <category> 自製工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Shell </tag>
            
            <tag> Homebrew </tag>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codility Lesson TapeEquilibrium</title>
      <link href="/2023/04/14/Codility/CodilityLessonTapeEquilibrium/"/>
      <url>/2023/04/14/Codility/CodilityLessonTapeEquilibrium/</url>
      
        <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://app.codility.com/programmers/lessons/3-time_complexity/tape_equilibrium/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給一個由 N 個不同整數組成的<strong>非空</strong>陣列 A。遍歷到 A 的任一非 0 索引 P 時，會將陣列分成 A[1], A[2],…, A[P−1] 以及 A[P]、A[P+1],…, A[N−1] 兩個部分，其<strong>差異</strong>指的就是這兩部分<strong>各自加總</strong>後相減的絕對值。</p><p>例如輸入 A=[3, 1, 2, 4, 3] 時，可能的 P 值就會是 1~4，且他們的差異會是:</p><ol><li>P = 1，差異 = |3 − 10| = 7   (3 vs 1+2+4+3)</li><li>P = 2，差異 = |4 − 9| = 5    (3+1 vs 2+4+3)</li><li>P = 3，差異 = |6 − 7| = 1</li><li>P = 4，差異 = |10 − 3| = 7</li></ol><p>你的方法必須能吃這個陣列，並返回其中最小的差異，以上述例子來看就是 1</p><ul><li>N 是範圍 [2~100000] 的整數。</li><li>陣列 A 裡的元素都是範圍 [-1000~1000] 的整數</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>這題敘述挺長的，有可能會一時不知道怎麼下手，但其實原則很簡單，就是一樣想辦法遍歷一次就做完。<br>我們會發現從 P 到 P+1 時，相當於右邊減去 A[P]，而左邊加上 A[P]，所以你能遍歷一次就找出所有差異值，<br>那麼只需要多一個變數來存最小差異值就好。</p><p>陷阱在於 [1000, -1000]，你如果沒處理好的話就會算出 0，但其實答案應該是 2000。</p><ul><li>時間複雜度 O(N)</li><li>空間複雜度 O(1)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/TimeComplexity/TapeEquilibrium.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/TimeComplexity/TapeEquilibriumTest.php">單元測試</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Codility </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 演算法 </tag>
            
            <tag> Codility </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codility Lesson PermMissingElem</title>
      <link href="/2023/04/14/Codility/CodilityLessonPermMissingElem/"/>
      <url>/2023/04/14/Codility/CodilityLessonPermMissingElem/</url>
      
        <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://app.codility.com/programmers/lessons/3-time_complexity/perm_missing_elem/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給一個由 N 個不同整數組成的陣列 A。該陣列包含 [1~(N+1)] 範圍內的整數，這表示正好缺少一個 [1~(N+1)] 的元素，你必須找出他。<br>例如輸入 A=[2, 3, 1, 5] ，答案應為 4。</p><ul><li>N 是範圍 [1~100000] 的整數。</li><li>陣列 A 裡的元素都是不重複的。</li><li>陣列 A 裡的元素都是範圍 [1~(N+1)] 的整數</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>也許你一開始會想到排序後遍歷，但排序需要 O(Nlog N)，所以顯然應該有更好的解法。</p><p>再來也許會想到定義一個鍵為 1~(N+1) 的結果陣列，只要遍歷到就從結果陣列中刪除，那麼最後剩下的那個就是答案，這樣的時間複雜度似乎已達標，但是空間是否能用得更少呢?</p><p>觀察題目可以發現 1~(N+1) 其實就是等差為 1 的等差數列，那麼我們其實一開始就可以預期他們的總和是多少了，只要用預期總和去減 A 的所有元素就能求解。<br>這邊需要注意的是公式不要套錯，因為題目其實有少給你 1 個元素，所以正確的長度和高度應是 A 的元素數量再 +1。</p><p>像這樣用公式解就能降低空間複雜度到 O(1)。<br><s>雖然題目主旨是時間複雜度</s></p><ul><li>時間複雜度 O(N)</li><li>空間複雜度 O(1)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/TimeComplexity/PermMissingElem.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/TimeComplexity/PermMissingElemTest.php">單元測試</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Codility </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 演算法 </tag>
            
            <tag> Codility </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codility Lesson FrogJmp</title>
      <link href="/2023/04/13/Codility/CodilityLessonFrogJmp/"/>
      <url>/2023/04/13/Codility/CodilityLessonFrogJmp/</url>
      
        <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://app.codility.com/programmers/lessons/3-time_complexity/frog_jmp/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給三個變數，起點是 X，終點是 Y，每次移動距離是 D，需求出最少需要幾次 D 才能剛好抵達或超過終點。<br><s>題外話，為甚麼官方是寫 FrogJmp 而不是 FrogJump 啊。</s><br>例如輸入 X=10, Y=85, D=30，答案應為 3。</p><ul><li>X, Y, D 都是範圍 [1~1000000000] 的整數。</li><li>X &lt;= Y。</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>既然題目都歸類在 TimeComplexity 裡了，感覺就是注重效能的題目。<br>實際上也沒錯，看起來就是想騙人去用迴圈去每次減 D，因為這樣在 D 為 1 的時候你的時間複雜度就會提高到 Y-X。<br>而其實你根本只需要用 (Y-X)/D 再無條件進位就能達到答案，時間複雜度 O(1)。<br><s>根本就是小學數學題。</s></p><p>以前在面試時有遇過類似題目，面試官是說希望知道你在看起來秒殺的題目下會不會忽略掉甚麼才是最佳解。</p><ul><li>時間複雜度 O(1)</li><li>空間複雜度 O(1)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/TimeComplexity/FrogJump.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/TimeComplexity/FrogJumpTest.php">單元測試</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Codility </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 演算法 </tag>
            
            <tag> Codility </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codility Lesson OddOccurrencesInArray</title>
      <link href="/2023/04/12/Codility/CodilityLessonOddOccurrencesInArray/"/>
      <url>/2023/04/12/Codility/CodilityLessonOddOccurrencesInArray/</url>
      
        <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://app.codility.com/programmers/lessons/2-arrays/odd_occurrences_in_array/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給一個非空陣列 A，包含了 N 個整數，索引從 0 開始。N 為奇數，其中除了唯一一個元素之外，其他每個元素都可以與陣列中另一個有相同值的元素配對，目的就是找出這個無法配對的元素。<br>例如輸入 A=[9, 3, 9, 3, 9, 7, 9]，答案應為 7。</p><ul><li>N 為範圍 [1~1000000] 的奇數。</li><li>陣列 A 的每個元素都是 [1~1000000000] 範圍內的整數。</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>光看題目第一時間其實想到 LeetCode 的 <a href="https://leetcode.com/problems/valid-parentheses/">20. Valid Parentheses</a>，那時是用 stack 解的，不過這題並沒有那麼複雜，不需要考慮開關符號的問題。</p><p>再來會想到的是記憶法，用數字種類當索引，用出現次數當值。當初會這樣想是因為題目的範例暗示了同個數字是可以出現超過 2 次的，於是潛意識想要知道每種數字出現幾次，這樣的優點是可以在時間和複雜度 O(N) 的情況下獲得完整資訊。</p><p>寫到一半才想到，目的只是要回傳那個沒有重複的值啊，我多做那麼沒用的事情幹嘛!</p><p>於是目標會希望改成只對 A 遍歷 1 次，且減少空間的用量，這時候就會發現我並不需要紀錄每種數字出現幾次，反正出現重複的就刪掉就好，因此空間用量值只會需要一個回傳陣列。<br>由於會需要知道回傳陣列是否已包含當前遍歷到的值，你仍需要以數字種類當索引才能保持每次查找的時間複雜度是 O(N)。<br>可以複習一下我的另一篇文章 : <a href="/2022/10/19/PHPArray/">PHP Array</a></p><p>時間和空間複雜度是一個<strong>估算</strong>用的參考，所以不管有沒有記憶數字出現幾次都是 O(N)，但身為工程師你應該會很清楚實際上到底程式執行的細節是什麼，以及當我的<strong>函式/方法已定義好要做 X，就不要浪費資源去多做用不到的 Y</strong>。</p><ul><li>時間複雜度 O(N)</li><li>空間複雜度 O(N) – 實際上最多存到 (N/2)+1，因為已保證只有一個元素不重複</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/Arrays/OddOccurrencesInArray.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/Arrays/OddOccurrencesInArrayTest.php">單元測試</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Codility </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 演算法 </tag>
            
            <tag> Codility </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codility Lesson CyclicRotation</title>
      <link href="/2023/04/11/Codility/CodilityLessonCyclicRotation/"/>
      <url>/2023/04/11/Codility/CodilityLessonCyclicRotation/</url>
      
        <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://app.codility.com/programmers/lessons/2-arrays/cyclic_rotation/">官網題目連結</a></p><blockquote><p>根據題目敘述，輸入整數陣列 A 和一個整數 K ，將<strong>每個</strong>陣列元素<strong>往右移</strong> K 次。<br>例如輸入 A=[3, 8, 9, 7, 6], K=3，答案應為 [9, 7, 6, 3, 8]。</p><ul><li>N 和 K 都是範圍 [0~100] 的整數。</li><li>陣列 A 的每個元素都是 [−1000~1000] 範圍內的整數。</li></ul><p>題目特別說專注在正確性而不是效能。</p></blockquote><h2 id="解法：">解法：</h2><blockquote><p>共做 K 次，每次將陣列的最後一個元素改放到最前面即可。</p><p>由於 php array 的特性，用 array_pop() 取出最後一個元素為時間複雜度 O(1)，<br>但使用 array_unshift() 將元素放到最前面時，需要時間複雜度 O(N) 來保持索引順序，其中 N 為陣列元素數量。<br>可以複習一下我的另一篇文章 : <a href="/2022/10/19/PHPArray/">PHP Array</a></p><ul><li>時間複雜度 O(N * K)</li><li>空間複雜度 O(N) / O(N * K) – 我不確定重複的 array_unshift() 會不會用到相同的空間來搬移陣列，之後可以實驗</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/Arrays/CyclicRotation.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/Arrays/CyclicRotationTest.php">單元測試</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Codility </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 演算法 </tag>
            
            <tag> Codility </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codility Lesson Iterations BinaryGap</title>
      <link href="/2023/04/10/Codility/CodilityLessonBinaryGap/"/>
      <url>/2023/04/10/Codility/CodilityLessonBinaryGap/</url>
      
        <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://app.codility.com/programmers/lessons/1-iterations/binary_gap/">官網題目連結</a></p><blockquote><p>根據題目敘述，會需要將輸入的整數 N 轉成二進位，並找出任意<strong>夾在兩個 1 中間</strong>的最大 0 總數。<br>例如輸入 529，轉成二進位是 1<strong>0000</strong>10001，答案就是 4，而如果沒有任何 0 是夾在兩個 1 中間的，則會回傳 0。</p><ul><li>N 是範圍 [1~2147483647] 的整數。</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>先把數字轉成字串再遍歷一次即可，這邊要注意的陷阱是容易疏忽最後一個 1 的判斷。<br>例如轉成二進位是 1001000 時，由於最後面並沒有結尾的 1 把三個 0 夾住，所以答案是 2 不是 3。<br>所以重點會在於何時將<strong>當前計算</strong>的最大值轉成<strong>合法</strong>的最大值。</p><ul><li>時間複雜度 O(N)</li><li>空間複雜度 O(1)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/Iterations/BinaryGap.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/Iterations/BinaryGapTest.php">單元測試</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Codility </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 演算法 </tag>
            
            <tag> Codility </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRU Cache</title>
      <link href="/2023/01/19/Cache/LRUCache/"/>
      <url>/2023/01/19/Cache/LRUCache/</url>
      
        <content type="html"><![CDATA[<h2 id="背景">背景</h2><blockquote><p>一般來說快取是將會常被取用的資料<strong>暫存</strong>起來，避免重複的 I/O 以加快速度，而你的空間是有限的，勢必會需要淘汰一些既有資料才能放新的，而<strong>快取檔案置換機制</strong>就是決定哪些資料會優先淘汰，以最大保持你的<strong>快取命中率</strong>。</p></blockquote><h2 id="LRU-Least-Recently-Used-Cache">LRU(Least Recently Used) Cache</h2><blockquote><p>最近最少使用算法，顧名思義就是會優先清除掉沒被使用的資料。</p></blockquote><h2 id="規則：">規則：</h2><ol><li>最先進入快取的 key 會最先被刪除。</li><li>若某一 key 被取用或更新值，則該 key 會視為新寫入，因為要將其被刪除的順序降到最低。</li><li><em><strong>(額外)</strong></em> 由於會使用快取就是為了提高速度，所以實作上必須要求放值和取值都必須達到時間複雜度O(1)</li></ol><h2 id="範例：">範例：</h2><blockquote><p>當你依序放入 a, b, c 三個資料時，他們的優先刪除順序就是 1, 2, 3，所以當空間不夠需要刪除資料時會先刪掉 a，因為他最先加入而且從來沒被取用過。</p><p>讓我們時光倒流回到刪除前，現在有 a, b, c 三個資料時，他們的優先刪除順序就是 1, 2, 3，而這時有人取用了 a，因為 a 被取用了， 他的刪除優先順序會從 1 降成 3，而 b, c 的刪除優先順序則會被提升，所以 a, b, c 他們的優先刪除順序就會變成 3, 1, 2，當空間不夠需要刪除資料時會先刪掉 b。</p></blockquote><h2 id="題目：">題目：</h2><p><a href="https://leetcode.com/problems/lru-cache/">LRU Cache - LeetCode</a></p><h2 id="PHP-實作思路">PHP 實作思路 :</h2><blockquote><p>首先需要思考要用什麼資料結構來存，根據前面提到的 LRU 的概念可以很自然的想到 php array，而必須注意的是 php array 跟一般學資料結構時定義的陣列不一樣，他是實作更高階的關聯陣列，簡單來說就是有序的 HashMap。<br><a href="/2022/10/19/PHPArray/">參考我的另一篇文章 - PHP Array</a></p><p>既然已經想到了 php array，再來實作上會發現的關鍵點是你的操作一定會需要用到頭尾，而由於鍵值對都拿去存資料了，你沒辦法用鍵當作順序，那麼應該如何在 O(1) 的情況下取得頭尾呢？</p><p>如果你已經想到要用另外一個空間去儲存順序，那麼恭喜你這道題已經解完了，一般來說這道題最常用的解法就是用 HashMap ＋ 雙向鏈結串列，用 HashMap 存 key 並指向雙向鏈結串列的節點，並用節點屬性來保存值，所以能保證查找的時間複雜度是 O(1)，而由於雙向鏈結串列能在時間複雜度 O(1) 找到所在節點的上下兩個節點，所以你的增刪也是時間複雜度 O(1)</p><p>補充一下，如果你是用 php 的話，你還是有辦法只用一個 php array 就做完的，這是因為 php array 實際上是<strong>有序的 HashMap</strong>，他會多花空間來記錄順序，也有多花空間來記錄起終點，所以剛好可以滿足 LRU 需要的條件，這個方法就是 array_key_first() 或 array_key_last() 。<br><a href="https://wiki.php.net/rfc/array_key_first_last_index">參考官方說明</a>，已明確指出時間複雜度 O(1)，</p><p>如果還是有疑慮或好奇，可以參考 <a href="https://github.com/php/php-src/blob/PHP-7.3.10/ext/standard/array.c">php7.3.10 官方開源</a></p><p>這做法要考量的就是 php array 在有序這件事上到底花了多少成本，有興趣的話可以自己產生一些測試案例來實驗跟紀錄，不過就算比較慢你也沒得挑，因為目前還沒看到 php 能提供無序的方法給你選。</p><p>補充：java 的話可以採用 LinkedHashMap，這是基於 HashMap 的拓展，為有序 HashMap， 但尚未確認取得和插入頭尾的時間複雜度。<br><a href="https://www.jianshu.com/p/8f4f58b4b8ab">图解 LinkedHashMap 原理</a></p></blockquote><h2 id="PHP-實作程式碼">PHP 實作程式碼 :</h2><pre><code class="language-php">&lt;?phpdeclare(strict_types=1);namespace App;use Exception;class LRUCache&#123;    private $capacity = 0;    private $lruArr;    /**     * @param Integer $capacity     */    function __construct(int $capacity)    &#123;        if ($capacity &lt;= 0) &#123;            throw new Exception('input capacity must great than 0');        &#125;        # 設定最大容量        $this-&gt;capacity = $capacity;        # 設定資料存放處，最尾端的優先度最高        $this-&gt;lruArr = [];    &#125;    /**     *  取得值     *      * @param Integer $key     * @return Integer     */    public function get($key)    &#123;        # 檢查是否已有鍵，若無則回傳 -1        if (!isset($this-&gt;lruArr[$key])) &#123;            return -1;        &#125;        # 找出目標值        $targetValue = $this-&gt;lruArr[$key];        # 將目標鍵值刪除再寫入，以將其優先度提至最高        unset($this-&gt;lruArr[$key]);        $this-&gt;lruArr[$key] = $targetValue;        return $targetValue;    &#125;    /**     *  寫入值     *      * @param Integer $key     * @param Integer $value     * @return NULL     */    public function put($key, $value)    &#123;        # 未有鍵        if (!isset($this-&gt;lruArr[$key])) &#123;            # 容量已滿，刪除優先度最低的            if (count($this-&gt;lruArr) == $this-&gt;capacity) &#123;                unset($this-&gt;lruArr[array_key_first($this-&gt;lruArr)]);            &#125;        &#125; else &#123;            # 已有鍵，刪除舊值            unset($this-&gt;lruArr[$key]);        &#125;        # 寫入新值        $this-&gt;lruArr[$key] = $value;    &#125;    /**     *  遍歷全部     *      * @return Array     */    public function all(): array    &#123;        return $this-&gt;lruArr;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 快取 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Array </tag>
            
            <tag> HashTable </tag>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP Array</title>
      <link href="/2022/10/19/PHPArray/"/>
      <url>/2022/10/19/PHPArray/</url>
      
        <content type="html"><![CDATA[<h2 id="先說結論：">先說結論：</h2><blockquote><p>PHP 的 array 其實是有序的 HashMap</p></blockquote><h2 id="以一般學習資料結構而言：">以一般學習資料結構而言：</h2><ul><li><p>陣列（Array）：使用一連串連續的記憶體空間來存資料。同一陣列只會存放同一種資料型態的值，並用索引來記錄順序。優點是查找時間複雜度為 O(1)，缺點是只要移動資料順序或陣列空間不夠用時（需創建另一串更大的連續記憶體來做搬移），時間複雜度會變成 O(N)。</p></li><li><p>哈希表（HashMap）：先定義好鍵值的型態，並且是<strong>無序</strong>的。當你放值時會用 hash function 算出雜湊值，以對應放值的記憶體位址。遇到碰撞時不同語言會用不同的方式解決，例如常見的拉鍊法。優點是查找和存放的時間複雜度都是 O(1)，缺點是效能會隨使用的 hash function 不同而有差異，且當哈希表容量不足時，會定義一個新的哈希表，並把舊的鍵值移過去，等於每個舊鍵都要重跑一次 hash function，成本大幅提高。</p></li></ul><h2 id="PHP-Array：">PHP Array：</h2><blockquote><p>在 PHP 裡基於 C 語言將兩者實作成關聯陣列，名稱還是叫 Array。可接受存放不同型態的鍵值對，且為有序的 HashMap</p></blockquote><p>補充：</p><blockquote><p>以 JAVA 而言，HashMap 會有預設大小(16)，如果存放內容超過最大容量的 75% 時，程式會自動建立一個更大的 HashMap(2倍)，並將舊的 HashMap 中所有鍵值搬移到新的 HashMap 裡（會重新對應hash值），導致時間複雜度變成O(N)。<br><a href="https://stackoverflow.com/questions/53003761/what-happens-to-the-index-of-the-values-in-a-hashmap-when-it-increases-its-size">參考 stackoverflow 討論</a></p><p>HashMap 在碰撞時會用鏈表存有撞到的值，查詢時會遍歷鍊表（鏈式解決碰撞法），當鍊表大於預設值(8)時會轉存成紅黑樹，以避免若無限碰撞時 HashMap 會變成鍊表。不用二元樹是因為二元樹在最糟情況下等同於鍊表，而小於 8 的情況下用紅黑樹則過於浪費資源。</p></blockquote><h2 id="PHP-Array-使用要點：">PHP Array 使用要點：</h2><ul><li><p>將值加入 array 用 <code>$arr['key'] = 'value'</code> 會比呼叫 array_push 更快。<br><a href="https://stackoverflow.com/questions/1739706/how-to-insert-an-item-at-the-beginning-of-an-array-in-php">參考 stackoverflow 討論</a></p></li><li><p>在 O(1) 的時間複雜度下獲取第一個或最後一個鍵，可以用 array_key_first() 或 array_key_last()。<br><a href="https://wiki.php.net/rfc/array_key_first_last_index">參考官方說明</a></p></li><li><p>計算 array 長度用 count(array) 是時間複雜度 O(1)。<br><a href="https://stackoverflow.com/questions/5835241/is-phps-count-function-o1-or-on-for-arrays">參考 stackoverflow 討論</a></p></li><li><p>大部分 array 相關的原生方法的時間複雜度 :<br><a href="https://stackoverflow.com/questions/2473989/list-of-big-o-for-php-functions?noredirect=1&amp;lq=1">參考 stackoverflow 討論</a></p></li><li><p>使用 count_chars() 的時間複雜度是 O(N)。<br><a href="https://www.php.net/manual/zh/function.count-chars.php">參考官方函式用法</a><br><a href="https://github.com/php/php-src/blob/master/ext/standard/string.c">參考官方字串相關的原始碼</a></p></li><li><p>使用 str_split() 的時間複雜度是 O(N)，與其原理有關，他主要是遍歷字串中每個字符並存到回傳陣列。<br><a href="https://github.com/php/php-src/blob/master/ext/standard/string.c">參考官方字串相關的原始碼</a></p></li></ul><h2 id="參考：">參考：</h2><ul><li><p><a href="https://github.com/php/php-src/blob/PHP-7.3.10/ext/standard/array.c">PHP 7.3.10 官方開源</a></p></li><li><p><a href="https://medium.com/@rtheunissen/efficient-data-structures-for-php-7-9dda7af674cd">Efficient data structures for PHP 7</a></p></li><li><p><a href="https://www.npopov.com/2014/12/22/PHPs-new-hashtable-implementation.html">PHP5 到 PHP7 Array 底層實現的改變</a></p></li><li><p><a href="https://gywbd.github.io/posts/2014/12/php7-new-hashtable-implementation.html">PHP5 到 PHP7 Array 底層實現的改變 - 翻譯版</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Array </tag>
            
            <tag> HashTable </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
