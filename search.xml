<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用 Prometheus 和 Grafana 來監控你的 K3s / K8s 叢集</title>
      <link href="/Kubernetes/PrometheusGrafanaK3s/"/>
      <url>/Kubernetes/PrometheusGrafanaK3s/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：">前言：</h2><p>本文的目標為安裝 Prometheus 和 Grafana 來監控 K3s / K8s 叢集，可以從非常細度的指標組合出想看的資訊，並用精美的圖表呈現，也能在達成條件時發送警告，是系統維運的好用工具。</p><h2 id="還沒有建好叢集的讀者請先參考我的另一篇文章：">還沒有建好叢集的讀者請先參考我的另一篇文章：</h2><ul><li><a href="/Kubernetes/MultipassK3sK8s/">用 Multipass 和 K3s 建立 K8s 叢集</a></li></ul><h2 id="本文有用圖形化工具-portainer-和指令兩種方式教學，想安裝-portainer-的話請先參考我的另一篇文章：">本文有用圖形化工具 portainer 和指令兩種方式教學，想安裝 portainer 的話請先參考我的另一篇文章：</h2><ul><li><a href="/Kubernetes/PortainerK3s/">使用 Portainer 圖形化工具管理 K3s / K8s 叢集</a></li></ul><h2 id="先用-helm-安裝-kube-prometheus-stack-內含-grafana-：">先用 helm 安裝 kube-prometheus-stack (內含 grafana)：</h2><p><a href="https://artifacthub.io/packages/helm/prometheus-community/kube-prometheus-stack">可參考官方說明</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install my-kube-prometheus-stack prometheus-community/kube-prometheus-stack --version 55.5.1</span><br></pre></td></tr></table></figure><p><img src="/images/helmInstallKubePrometheus.png" alt=""></p><p>雖然 terminal 很快就顯示跑完了，但可以觀察虛擬機還是在大量跑東西。</p><p>順帶一提筆者一開始使用 1G 或 2G RAM 的主節點都會無限失敗，後來換成 4G RAM 才成功，Grafana 需要吃的資源真的很多。</p><h2 id="裝完後查看-services：">裝完後查看 services：</h2><ul><li>用 portainer 看：</li></ul><p><img src="/images/portainerShowK8sServices.png" alt=""></p><ul><li>也可以用指令看：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get services</span><br></pre></td></tr></table></figure><p><img src="/images/codeShowK8sServices.png" alt=""></p><h2 id="把本機的-port-映射到叢集-pod-的-port-以便在本機瀏覽器觀看：">把本機的 port 映射到叢集 pod 的 port 以便在本機瀏覽器觀看：</h2><p>實際 services 名稱和 namespace 等等請參考你剛剛查看 services 的結果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grafana </span></span><br><span class="line">kubectl port-forward svc/my-kube-prometheus-stack-grafana 3000:80 -n default</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想看 prometheus 可以順便開這個</span></span><br><span class="line">kubectl port-forward svc/my-kube-prometheus-stack-prometheus 9090:9090 -n default</span><br><span class="line"><span class="comment"># 如果想看 prometheus alert manager 可以順便開這個</span></span><br><span class="line">kubectl port-forward svc/my-kube-prometheus-stack-alertmanager 9093:9093 -n default</span><br></pre></td></tr></table></figure><p><img src="/images/kubectlPortFowardResult.png" alt=""></p><h2 id="對上本機-port-後就可以在瀏覽器打開-localhost-port-了：">對上本機 port 後就可以在瀏覽器打開 <code>localhost:&lt;port&gt;</code> 了：</h2><p><img src="/images/welcomeToGrafana.png" alt=""></p><h2 id="回到叢集找-grafana-的帳密：">回到叢集找 grafana 的帳密：</h2><p>用 portainer 看：</p><p><img src="/images/portainerShowGrafanaUserPW.png" alt=""></p><p>也可以用指令看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get secrets</span><br></pre></td></tr></table></figure><p><img src="/images/codeShowK8sSecrets.png" alt=""></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get secret my-kube-prometheus-stack-grafana -o jsonpath=<span class="string">&quot;&#123;.data.admin-user&#125;&quot;</span> | <span class="built_in">base64</span> --decode</span><br><span class="line">kubectl get secret my-kube-prometheus-stack-grafana -o jsonpath=<span class="string">&quot;&#123;.data.admin-password&#125;&quot;</span> | <span class="built_in">base64</span> --decode</span><br></pre></td></tr></table></figure><p><img src="/images/codeShowK8sSecretsValue.png" alt=""></p><h2 id="輸入帳密後成功登入：">輸入帳密後成功登入：</h2><p><img src="/images/grafanaAfterLogin.png" alt=""></p><h2 id="選擇-Create-your-first-dashboard：">選擇 Create your first dashboard：</h2><p><img src="/images/grafanaCreateYourFirstDashboard.png" alt=""></p><h2 id="選擇-Add-visualization：">選擇 Add visualization：</h2><p>可以看到已經預設與 Prometheus 連接好了。</p><p><img src="/images/grafanaAddVisualization.png" alt=""></p><p>接下來就可以使用指標和語法來建立自己想看的 DashBoard。</p><h2 id="當然也可以直接看一些預設好的模板，點擊-DashBoard：">當然也可以直接看一些預設好的模板，點擊 DashBoard：</h2><p><img src="/images/grafanaDashboards.png" alt=""></p><p>點擊想要的就可以看到數據囉：</p><p><img src="/images/grafanaDashboardsCoreDNS.png" alt=""></p><hr>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> K8s </tag>
            
            <tag> K3s </tag>
            
            <tag> Prometheus </tag>
            
            <tag> Grafana </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Portainer 圖形化工具管理 K3s / K8s 叢集</title>
      <link href="/Kubernetes/PortainerK3s/"/>
      <url>/Kubernetes/PortainerK3s/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：">前言：</h2><p>本文的目標為安裝 Portainer 圖形化工具來管理 K3s / K8s 環境，並簡單快速的用 yaml 設定來將容器自動部署到叢集上。</p><h2 id="還沒有建好叢集的讀者請先參考我的另一篇文章：">還沒有建好叢集的讀者請先參考我的另一篇文章：</h2><ul><li><a href="/Kubernetes/MultipassK3sK8s/">用 Multipass 和 K3s 建立 K8s 叢集</a></li></ul><h2 id="先到-server-虛擬機內安裝-portainer：">先到 server 虛擬機內安裝 portainer：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multipass shell k8s-server</span><br><span class="line"></span><br><span class="line">kubectl apply -n portainer -f https://downloads.portainer.io/ce2-19/portainer.yaml</span><br></pre></td></tr></table></figure><h2 id="安裝完後確認是否成功：">安裝完後確認是否成功：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo kubectl get pods -n portainer</span><br></pre></td></tr></table></figure><h2 id="回到本機，連到以下網址：">回到本機，連到以下網址：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://&lt;your_server_node_ip&gt;:30777/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或是</span></span><br><span class="line">https://&lt;your_server_node_ip&gt;:30779/</span><br></pre></td></tr></table></figure><h2 id="第一次啟動服務要設定帳號，如下圖：">第一次啟動服務要設定帳號，如下圖：</h2><p><img src="/images/portainerFirstLogin.png" alt=""></p><p>設定完成就可以看到以下介面：</p><p><img src="/images/quickSetup.png" alt=""></p><p>點選 Get Started 即可開始。</p><h2 id="點選-local-進入-Dashboard：">點選 local 進入 Dashboard：</h2><p><img src="/images/portainerHome.png" alt=""></p><p><img src="/images/portainerDashboard.png" alt=""></p><h2 id="點選-Services，然後選右上的-create-from-manifest：">點選 Services，然後選右上的 create from manifest：</h2><p><img src="/images/portainerService.png" alt=""></p><h2 id="選擇-Web-editor-並輸入設定的-yaml：">選擇 Web editor 並輸入設定的 yaml：</h2><p><img src="/images/portainerWebEditor.png" alt=""></p><p>這裡提供我用的 yaml 設定，用 nginx 官方 image 當簡單範例。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-container</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">&quot;128Mi&quot;</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;100m&quot;</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">&quot;256Mi&quot;</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;200m&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LoadBalancer</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">38383</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>若有部署成功但發生 external ip always pending 或無法連線的問題，要注意 port 的設定。</p><h2 id="成功部署會像這樣：">成功部署會像這樣：</h2><p><img src="/images/portainerSuccessDepoly.png" alt=""></p><h2 id="從圖中可以看到設定的-LoadBalancer-正常運作，有兩個-External-IP-可以通：">從圖中可以看到設定的 LoadBalancer 正常運作，有兩個 External IP 可以通：</h2><p><img src="/images/portainerServiceLoadBalancer.png" alt="Untitled"></p><h2 id="使用-External-IP-即可正常連線：">使用 External IP 即可正常連線：</h2><p>以筆者案例是 <a href="http://192.168.64.2:38383/">http://192.168.64.2:38383/</a> 和 <a href="http://192.168.64.3:38383/">http://192.168.64.3:38383/</a> 。</p><p><img src="/images/welcomeToNginx.png" alt=""></p><h2 id="額外補充：">額外補充：</h2><p>在原叢集正常運作時加開一個 worker2 虛擬機並加入叢集：</p><p>卡在這裡快二十分鐘都沒顯示完成：</p><p><img src="/images/addWorker2.png" alt="Untitled"></p><p>然後查看狀態發現 Portainer 已無法連線到 k3s 叢集：</p><p><img src="/images/portainerLocalDown.png" alt="Untitled"></p><p>這邊注意，由於 Portainer 也是作為一個 pod 安裝在 master 上的，若是 master 主機掛了是連 Portainer 介面都看不到的，所以這裡的問題是 k3s 叢集卡住無法回應。</p><p>但依然可以正常訪問節點：</p><p><img src="/images/welcomeToNginx.png" alt=""></p><p>由於卡了二十分鐘都沒好，嘗試把 k8s-server 關掉，可以發現打其中一個 External IP 會變成「無法連上這個網站」了，但另一個正常，所以 LoadBalancer 的兩個端口確實是對應兩個不同節點上的服務，並且就算 master 掛掉 worker 還是能讀取。這也是因為 pod 是分散在兩個節點才能正常讀，不然 3 個 pod 都集中在 master 的話就算 worker 活著也讀不了。</p><p>最後把 k8s-server 重啟，一切正常，但中間還是等待了不少時間，可能開給他的資源真的太少了。</p><p>進入介面可以看到 LoadBalancer 自動的產生第三個端口，所以是隨著節點數量自動增減的：</p><p><img src="/images/portainerLoadBalancerAutoExpand.png" alt=""></p><p>嘗試把 k8s-worker2 關掉，大概要 2 分鐘才會顯示異常：</p><p><img src="/images/portainerClusterNodesError.png" alt=""></p><hr>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> K8s </tag>
            
            <tag> K3s </tag>
            
            <tag> Portainer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Multipass 和 K3s 建立 K8s 叢集</title>
      <link href="/Kubernetes/MultipassK3sK8s/"/>
      <url>/Kubernetes/MultipassK3sK8s/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：">前言：</h2><p>本文的目標為在 macOS 上開兩個 ubuntu 虛擬機並將他們納入 Kubernetes 環境，且可從 macOS 本機連接。</p><ul><li>Multipass : 在 macOS 快速建立 ubuntu 虛擬機。</li><li>K3s : 輕量化的 K8s(Kubernetes)。</li></ul><h2 id="安裝-kubectl：">安裝 kubectl：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install kubectl</span><br></pre></td></tr></table></figure><h2 id="安裝-Multipass：">安裝 Multipass：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install multipass --cask</span><br></pre></td></tr></table></figure><h2 id="創建兩台虛擬機：">創建兩台虛擬機：</h2><ul><li>鑒於筆者後面開發時遇到的巨坑經驗，如果可以的話虛擬機資源還是給多一點吧，server 給到 4G RAM 會對之後的開發友善許多。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multipass launch --name k8s-server --mem 1G --disk 5G --cpus 1</span><br><span class="line"></span><br><span class="line">multipass launch --name k8s-worker --mem 1G --disk 5G --cpus 1</span><br></pre></td></tr></table></figure><h2 id="檢查虛擬機狀態順便記下-IP-後面會用到：">檢查虛擬機狀態順便記下 IP 後面會用到：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multipass list</span><br></pre></td></tr></table></figure><h2 id="在-server-虛擬機上安裝-k3s：">在 server 虛擬機上安裝 k3s：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multipass shell k8s-server</span><br><span class="line"></span><br><span class="line">curl -sfL https://get.k3s.io | sh -</span><br></pre></td></tr></table></figure><h2 id="複製-server-虛擬機上的設定：">複製 server 虛擬機上的設定：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/rancher/k3s/k3s.yaml</span><br></pre></td></tr></table></figure><h2 id="回到本機，將剛剛複製完的設定貼進本機設定檔：">回到本機，將剛剛複製完的設定貼進本機設定檔：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.kube/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或是</span></span><br><span class="line">vim /Users/&lt;userName&gt;/.kube/config</span><br></pre></td></tr></table></figure><h2 id="貼上之後記得將本機設定檔裡的-cluster-的-server-位置改成-server-虛擬機-IP：">貼上之後記得將本機設定檔裡的 cluster 的 server 位置改成 server 虛擬機 IP：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意要 s 和指定 6443 port</span></span><br><span class="line">server: https://&lt;your_server_node_ip&gt;:6443</span><br></pre></td></tr></table></figure><h2 id="本機輸指令確認是否成功：">本機輸指令確認是否成功：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line">kubectl cluster-info</span><br></pre></td></tr></table></figure><h2 id="印出-server-虛擬機的-node-token，待會用到：">印出 server 虛擬機的 node-token，待會用到：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multipass <span class="built_in">exec</span> k8s-server sudo <span class="built_in">cat</span> /var/lib/rancher/k3s/server/node-token</span><br></pre></td></tr></table></figure><h2 id="在-worker-虛擬機上安裝-K3s-並加入叢集：">在 worker 虛擬機上安裝 K3s 並加入叢集：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multipass shell k8s-worker</span><br><span class="line"></span><br><span class="line">curl -sfL https://get.k3s.io | K3S_URL=https://&lt;your_server_node_ip&gt;:6443 K3S_TOKEN=<span class="string">&quot;&lt;your_server_node_token&gt;&quot;</span> sh -</span><br></pre></td></tr></table></figure><h2 id="回到本機輸指令確認是否成功：">回到本機輸指令確認是否成功：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes -owide</span><br></pre></td></tr></table></figure><h2 id="不想打那麼多指令嗎？">不想打那麼多指令嗎？</h2><p>參考我的另一篇文章：<a href="/Kubernetes/PortainerK3s">使用 Portainer 圖形化工具管理 K3s 叢集</a></p><h2 id="參考：">參考：</h2><ul><li><a href="https://geekhour.net/2023/12/23/kubernetes/">Kubernetes一小時入門課程</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> K8s </tag>
            
            <tag> Multipass </tag>
            
            <tag> K3s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 conda 管理 python 開發環境</title>
      <link href="/Python/conda/"/>
      <url>/Python/conda/</url>
      
        <content type="html"><![CDATA[<h2 id="前言：">前言：</h2><p>我過往在開發自製小工具的時候都會採用 python，因為語法簡潔，也有很多別人寫好的套件可以用，但為了快速所以本機環境都沒認真管控。由於最近接手公司的 python 專案，覺得要認真建置一下開發環境了。</p><blockquote><p>本文的範例都是基於 macOS 的。</p></blockquote><h2 id="安裝-conda：">安裝 conda：</h2><p>conda 是一個與語言無關的跨平台環境管理器，定位會類似於 apt 或 yum，可以方便管理各種包。<br>要安裝 conda 可以使用 Anaconda 或 Miniconda 來輕鬆安裝，由於後者比較輕量，所以我是用後者:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install --cask miniconda</span><br></pre></td></tr></table></figure><p>安裝完後可以用 <code>conda -V</code> 確認一下。<br><img src="/images/checkCondaVision.png" alt=""></p><h2 id="使用-conda-管理虛擬環境：">使用 conda 管理虛擬環境：</h2><p>虛擬環境的好處在於你可以切出不同的語言版本和不同的套件，而不需要擔心不同專案間的環境衝突或冗余套件。<br>在虛擬環境中可以自由使用 pip 安裝套件，作用範圍僅限當下的虛擬環境。</p><ol><li>創建虛擬環境: <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name &lt;env_name&gt; python=&lt;version&gt;</span><br></pre></td></tr></table></figure></li><li>查看虛擬環境列表: <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="built_in">env</span> list</span><br></pre></td></tr></table></figure></li><li>啟動虛擬環境: <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> activate &lt;env_name&gt;</span><br></pre></td></tr></table></figure></li><li>離開虛擬環境: <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> deactivate</span><br></pre></td></tr></table></figure></li><li>刪除虛擬環境: <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="built_in">env</span> remove --name &lt;env_name&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="在-VSCode-中使用-conda-虛擬環境：">在 VSCode 中使用 conda 虛擬環境：</h2><ol><li>選取解譯器：<ul><li>在 VSCode 中按下快捷鍵 <code>⌘ + Shift + P</code> 開啟「命令選擇區」，然後輸入 Select Interpreter，就可以在列表中選擇 conda 的虛擬環境。</li><li>如果已經開啟 python 專案，則也可以在右下角的工具列直接找到。</li></ul></li><li>開啟終端機：<ul><li>在 VSCode 中按下快捷鍵 <code>ctrl + ~</code> 叫出終端機，如果前面有選擇過解譯器的話就會直接進入該虛擬環境中囉。如果發現還是 base 的話可以按 Enter 或叫一個新的終端機自動進入。</li></ul></li></ol><h2 id="參考：">參考：</h2><ul><li><a href="https://medium.com/python4u/%E7%94%A8conda%E5%BB%BA%E7%AB%8B%E5%8F%8A%E7%AE%A1%E7%90%86python%E8%99%9B%E6%93%AC%E7%92%B0%E5%A2%83-b61fd2a76566">用conda建立及管理python虛擬環境</a></li><li><a href="https://medium.com/ai%E5%8F%8D%E6%96%97%E5%9F%8E/anaconda-miniconda-conda-pip%E7%9A%84%E7%9B%B8%E4%BA%92%E9%97%9C%E4%BF%82-%E8%BD%89%E8%BC%89-a0536f3a257">Anaconda、Miniconda、Conda、pip的相互關係 (轉載)</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>禁用 Linux 的密碼登入改用 ssh 憑證連線</title>
      <link href="/Linux/ReplacePasswordWithSSH/"/>
      <url>/Linux/ReplacePasswordWithSSH/</url>
      
        <content type="html"><![CDATA[<h2 id="緣由">緣由 :</h2><p>用密碼登入代表有可能會有洩漏或被暴力破解等等的隱憂，所以可以改用<a href="https://zh.wikipedia.org/zh-tw/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86">非對稱式加密</a>的 ssh 來保證安全，<s>也可以幫助懶人不用每次都要打密碼</s>。</p><h2 id="作法">作法 :</h2><h3 id="1-本機產生-ssh-金鑰對：">1. 本機產生 ssh 金鑰對：</h3><p>如果你是 Unix/Linux 或 macOS，可以直接使用以下指令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></table></figure><p>如果你是 Ubuntu 或 Debian 又缺少這個工具，則需要先用指令安裝套件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openssh-client</span><br></pre></td></tr></table></figure><p>如果成功會在你的帳戶家目錄下產生 <code>.ssh</code> 目錄，裡面有私鑰 <code>id_rsa</code> 和公鑰 <code>id_rsa.pub</code>，請記住私鑰絕對不要外洩。</p><h3 id="2-推送金鑰到你的機器上：">2. 推送金鑰到你的機器上：</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id &lt;username&gt;@&lt;remote_ip&gt; </span><br></pre></td></tr></table></figure><p>如果成功則會在你的機器的該帳號家目錄下產生 <code>.ssh/authorized_keys</code>。<br>或你也可以手動創建該目錄檔案並貼入公鑰 <code>id_rsa.pub</code> 的內容。<br>成功後記得確保 .ssh 和 authorized_keys 都是 <code>755</code> 權限。</p><h3 id="3-修改你的機器設定：">3. 修改你的機器設定：</h3><p>先打開設定檔案：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ssh/ssfd_config</span><br></pre></td></tr></table></figure><p>在裡面找到以下設定並修改其值:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">port 22  <span class="comment"># ssh 監聽端口，你可以改成自己喜歡的，但要注意防火墻不能擋。</span></span><br><span class="line">PubkeyAuthentication <span class="built_in">yes</span></span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys</span><br><span class="line">PasswordAuthentication No  <span class="comment"># 設為 No 後會禁止用密碼登入</span></span><br></pre></td></tr></table></figure><p>修改完設定後要重啟 ssh 服務:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart sshd</span><br></pre></td></tr></table></figure><p>通常這些做完就可以免密碼用 ssh 連線了。</p><h2 id="意外">意外 :</h2><p>如果你的機器是用雲端伺服器代理商的話，很有可能上面步驟都做完後還是有問題。<br>以 <code>Vultr</code> 為例，發現登入時他還是會要你輸入密碼。<br>使用以下指令檢查:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sshd -T |grep pass</span><br></pre></td></tr></table></figure><p>發現 <code>passwordauthentication</code> 還是 <code>yes</code>，代表系統並沒有吃到剛剛的設定。<br>原因是 Vultr 另外有 <code>sshd_config.d/50-cloud-init.conf</code>，裡面就有 <code>PubkeyAuthentication yes</code> 的內容，<br>而系統在執行時會先讀取 <code>ssfd_config</code> 後才讀取 <code>50-cloud-init.conf</code>，就導致你的設定被覆蓋掉了，解決方法就是直接修改 <code>50-cloud-init.conf</code> 再重啟服務。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ssh </tag>
            
            <tag> security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Certbot 來自動幫你的網站申請 &amp; 更新免費的 Let&#39;s Encrypt SSL 憑證吧 !</title>
      <link href="/Nginx/nginxCertbotLetsencrypt/"/>
      <url>/Nginx/nginxCertbotLetsencrypt/</url>
      
        <content type="html"><![CDATA[<h2 id="為何需要-SSL-憑證">為何需要 SSL 憑證 :</h2><p>你是否有注意過網址有分成 <code>http</code> 和 <code>https</code> 呢？</p><ul><li>HTTP (HyperText Transfer Protocol)</li><li>HTTPS (HyperText Transfer Protocol <mark class="hl-label orange">Secure</mark> )</li></ul><p>很明顯的，他們的差距就在於<code>安全性</code>，當你訪問 http 的網站時，瀏覽器會跳出非安全連線的提示，這是因為 http 封包是用明文傳遞資訊，很容易被截取，所以需要用 SSL/TLS 這樣的非對稱式加密來保證資訊安全，這些協議使用公開密鑰和私有密鑰來加密通信，確保只有發送方和接收方能夠解密和讀取數據。</p><p>不過這樣還不夠，瀏覽器只信任第三方機構（Certificate Authority，簡稱CA）發布的數位憑證，如果你使用了自簽名的憑證，瀏覽器仍會跳出非安全連線的提示。</p><p>那麼，為什麼瀏覽器只信任 CA 頒發的憑證呢？這是因為 CA 在頒發數位憑證前會驗證該網站的身份，他會核實網站所有者的身份和控制權，這樣可以有效防止<a href="https://zh.wikipedia.org/zh-tw/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB">中間人攻擊</a>。</p><h2 id="什麼是-Let’s-Encrypt">什麼是 Let’s Encrypt :</h2><p>如同前面提到的，我們需要向 CA 請求頒發數位憑證，而其中一間最知名又免費的 CA 機構就是 <a href="https://letsencrypt.org/zh-tw/">Let’s Encrypt</a>，可以通過 ACME 協議自動化的完成證書申請和更新，且幾乎所有主要網頁瀏覽器和操作系統都信任 Let’s Encrypt 的證書。</p><p>可以參考<a href="https://letsencrypt.org/docs/certificate-compatibility/">官方列出的可相容系統</a>。</p><h2 id="什麼是-Certbot">什麼是 Certbot :</h2><p>Certbot 是一個免費且開源的工具，用於自動化管理 SSL/TLS 證書的申請、安裝、更新和配置。他是 Let’s Encrypt 計畫的官方客戶端，旨在簡化網站擁有者獲取和管理 HTTPS 加密的過程。</p><p>簡單來說，你可以透過 Certbot 來申請和更新 Let’s Encrypt 憑證。</p><p>Certbot 有提供很多做法來取得憑證：</p><table><thead><tr><th>作法</th><th>指令</th></tr></thead><tbody><tr><td>全自動 (自備 HTTP 伺服器)</td><td>– certbot</td></tr><tr><td>半自動（自備 HTTP 伺服器，不調整 HTTP 伺服器設定）</td><td>– certbot certonly</td></tr><tr><td>webroot（自備 HTTP 伺服器，自行設定 acme-challenge 部分）</td><td>– certbot certonly --webroot</td></tr><tr><td>手動（自備 HTTP 伺服器 、其他主機）</td><td>– certbot certonly --manual</td></tr><tr><td>DNS 套件</td><td>– certbot certonly --dns-PLUGIN</td></tr><tr><td>Standalone（Certbot 提供獨立 HTTP 伺服器部分）</td><td>– certbot certonly --standalone</td></tr></tbody></table><h2 id="什麼是-nginx">什麼是 nginx :</h2><p>nginx 是一個輕量級的<code>反向代理伺服器</code>，你可以用它來監聽你的指定 port，並將來源請求導向至你對應設定的地方。<br>例如你可以在 <mark class="hl-label orange">A機器</mark>  上設定一個 server 區塊來監聽 80 port + <a href="http://test.com">test.com</a>，則所有打到 <mark class="hl-label orange">A機器</mark>  的 80 port 且 domain 為 <a href="http://test.com">test.com</a> 的請求都會適用於這個區塊的設定，你可以做些不同的動作，然後導向至 A 機器其他地方抑或是其他 BCD 機器。</p><p>詳細教學會需要另外開一篇文章，此篇僅簡單概述。</p><h2 id="使用教學">使用教學 :</h2><p>本次範例中我只會示範用 webroot 的做法，並且都採用 docker 來設定。</p><p>前置作業：</p><ul><li>你需要在你的機器上自行下載 docker 和 docker-compose。</li><li>你需要有一個自己的域名，且 DNS 設定是對應到你當前要跑 certbot 的機器上。</li></ul><p>以結論來說，我們會定義兩個容器，一個是 nginx，一個是 certbot，certbot 只有在取得和更新憑證時啟動，nginx 則是永遠保持運作並使用 ssl 憑證來轉向給背後指定的服務。</p><h3 id="1-nginx-conf">1. nginx.conf</h3><p>首先，在你的專案根目錄新增一個 config 目錄，並在裡面新增一個 nginx.conf 後寫入以下內容：<br>有關 nginx 的目錄結構和語法就不多贅述了。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx worker process 的數量，通常設定為 CPU 的核心數量</span></span><br><span class="line"><span class="attribute">worker_processes</span> <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">512</span>;  <span class="comment"># 每個 worker process 所能處理的連線數量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">1M</span>;  <span class="comment"># 單次 request 超過指定用量則中斷連線</span></span><br><span class="line">    <span class="attribute">server_tokens</span> <span class="literal">off</span>;  <span class="comment"># 關閉 nginx 的版本資訊</span></span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;  <span class="comment"># listen port</span></span><br><span class="line">        <span class="attribute">listen</span> [::]:<span class="number">80</span>;  <span class="comment"># listen Ipv6 port</span></span><br><span class="line">        <span class="attribute">server_name</span> your.domain.com  <span class="comment"># listen domain name，為了好理解才加.com，你要填你自己的</span></span><br><span class="line"></span><br><span class="line">        location /.well-known/acme-challenge/ &#123;  <span class="comment"># Let&#x27;s Encrypt 驗證用</span></span><br><span class="line">            <span class="attribute">allow</span> all;</span><br><span class="line">            <span class="attribute">root</span> /tmp/acme-challenge;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>;  <span class="comment"># 其餘的把 http 轉成 https</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 這裡是有憑證之後要導向指定服務的設定，但一開始還沒有憑證 nginx 會報錯所以先註解掉。</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">        <span class="comment">#listen 443 ssl;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#server_name your.domain.com; </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#ssl_certificate /etc/letsencrypt/live/your.domain.com/fullchain.pem;  # 指定伺服器所使用的 SSL/TLS 憑證</span></span><br><span class="line">        <span class="comment">#ssl_certificate_key /etc/letsencrypt/live/your.domain.com/privkey.pem;  # SSL/TLS 憑證的私鑰</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#location / &#123;</span></span><br><span class="line">            <span class="comment">#proxy_pass https://ip.address  # 指定服務的 ip</span></span><br><span class="line">            <span class="comment">#proxy_set_header Host $host;</span></span><br><span class="line">            <span class="comment">#proxy_set_header X-Real-IP $remote_addr;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Dockerfile">2. Dockerfile</h3><p>在你的 config 目錄下新增 Dockerfile 並寫入以下內容。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx:<span class="number">1.24</span>.<span class="number">0</span>-alpine  <span class="comment"># 使用 docker hub 的官方映像檔</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">rm</span> /etc/nginx/conf.d/default.conf  <span class="comment"># 刪除原本的預設檔</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./nginx.conf /etc/nginx/nginx.conf  <span class="comment"># 將剛剛創建的 nginx.conf 檔案複製到容器對應的目錄</span></span></span><br></pre></td></tr></table></figure><h3 id="3-docker-compose-yml">3. docker-compose.yml</h3><p>回到你的專案根目錄，新增 docker-compose.yml 檔案並寫入以下內容 :</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span> <span class="comment"># 不同版本有不同語法規範，請參考官網</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">&quot;nginx_server&quot;</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">./config</span>  <span class="comment"># 設定用剛剛創建的 Dcokerfile 來啟動</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">443</span><span class="string">:443</span></span><br><span class="line">    <span class="attr">volumes:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config:/config</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/letsencrypt:/etc/letsencrypt:ro</span>  <span class="comment"># 等 certbot 拿完憑證會放這裡，所以要讓容器共用。</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/tmp/acme-challenge:/tmp/acme-challenge</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">letsencrypt:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">&quot;certbot&quot;</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">certbot/certbot:v2.6.0</span>  <span class="comment"># 指定用官方映像檔</span></span><br><span class="line">    <span class="comment"># 拿 SSL 憑證，注意替換 domain 和 email</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">-c</span> <span class="string">&quot;certbot certonly --webroot -w /tmp/acme-challenge/ </span></span><br><span class="line"><span class="string">                    -d &quot;</span><span class="string">your.domain.com&quot;</span> <span class="string">--text</span> <span class="string">--agree-tos</span> </span><br><span class="line">                    <span class="string">--email</span> <span class="string">your@email</span> <span class="string">--rsa-key-size</span> <span class="number">4096</span> <span class="string">--verbose</span> </span><br><span class="line">                    <span class="string">--keep-until-expiring</span> <span class="string">--preferred-challenges=http&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/etc/letsencrypt:/etc/letsencrypt&quot;</span>  <span class="comment"># 等 certbot 拿完憑證會放這裡，所以要讓容器共用。</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/tmp/acme-challenge:/tmp/acme-challenge&quot;</span></span><br><span class="line">    <span class="attr">environment:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">TERM=xterm</span>  <span class="comment"># 讓容器內的程式或命令知道如何與終端機互動，例如 vim 或變色等等。</span></span><br></pre></td></tr></table></figure><h3 id="4-啟動-nginx-容器">4. 啟動 nginx 容器</h3><p>CA 會打到 DNS 對應 IP 進行審核，所以要先啟動 nginx 容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up --build -d nginx </span><br></pre></td></tr></table></figure><h3 id="5-啟動-certbot-容器來拿憑證">5. 啟動 certbot 容器來拿憑證</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up --build letsencrypt</span><br></pre></td></tr></table></figure><h3 id="6-配置你的憑證檔案">6. 配置你的憑證檔案</h3><p>回到你的 config/nginx.conf，把剛剛因為沒有憑證會報錯而註解掉的地方取消註解。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up --build -d nginx</span><br></pre></td></tr></table></figure><p>如此一來就大功告成了，之後要更新憑證就啟動 certbot 容器就好。</p><h2 id="自動化腳本">自動化腳本 :</h2><p><s>作為懶人工程師當然要自動化啊，誰會想每次都記得手動跑更新！</s><br>到你的專案根目錄下新增 <a href="http://getSSL.sh">getSSL.sh</a> 並寫入以下內容 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定專案路徑</span></span><br><span class="line">PROJECT_PATH=<span class="string">&quot;/your/project/path&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定日誌文件的路徑和名稱 </span></span><br><span class="line">LOG_FILE=<span class="string">&quot;<span class="variable">$PROJECT_PATH</span>/log/getSSL.log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fn：給訊息，寫入日誌文件</span></span><br><span class="line"><span class="function"><span class="title">log_message</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> message=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">    <span class="built_in">local</span> timestamp=<span class="string">&quot;<span class="subst">$(date +&#x27;%Y-%m-%d %H:%M:%S&#x27;)</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    sudo <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$timestamp</span>: <span class="variable">$message</span>&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$LOG_FILE</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log_message <span class="string">&quot;Starting letsencrypt container&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拿 SSL 憑證</span></span><br><span class="line">sudo docker-compose run --<span class="built_in">rm</span> letsencrypt &gt;&gt; <span class="string">&quot;<span class="variable">$LOG_FILE</span>&quot;</span> 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有帶關鍵字就多設定排程</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;--schedule&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    log_message <span class="string">&quot;Setting up crontab job&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 設定腳本路徑和排程時間</span></span><br><span class="line">    CRON_SCHEDULE=<span class="string">&quot;0 0 * * 1&quot;</span></span><br><span class="line">    CRON_FILENAME=<span class="string">&quot;getSSL.sh&quot;</span></span><br><span class="line">    (crontab -l ; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$CRON_SCHEDULE</span> cd <span class="variable">$PROJECT_PATH</span>; ./<span class="variable">$CRON_FILENAME</span> &quot;</span>) | sudo crontab -</span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">log_message <span class="string">&quot;Stopping letsencrypt container&quot;</span></span><br></pre></td></tr></table></figure><p><code>記得把檔案權限設為可執行</code>，然後到專案目錄執行以下：</p><div class="tabs" id="getssh"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#getssh-1">單次更新</button></li><li class="tab"><button type="button" data-href="#getssh-2">設定排程</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="getssh-1"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./getSSL.sh</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="getssh-2"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./getSSL.sh --schedule</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p><s>啊如果你是 windows 或其他有的沒有 OS 我也懶得一個一個找，就照這個概念去換語法就好。</s></p><h2 id="參考">參考</h2><ul><li><a href="https://dev.to/mrshanas/https-on-docker-containers-using-nginx-and-letsencrypt-3nfa">HTTPS on Docker Containers using Nginx and LetsEncrypt</a></li><li><a href="https://yowlab.idv.tw/wordpress/?p=1390">使用 Certbot 來為網站申請 Let’s Encrtpt 憑證 (CentOS 7)</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
            <tag> Nginx </tag>
            
            <tag> Certbot </tag>
            
            <tag> Let&#39;s Encrypt </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快取的一致性難題與架構模式 (下)</title>
      <link href="/Cache/CacheConsistencyMeta/"/>
      <url>/Cache/CacheConsistencyMeta/</url>
      
        <content type="html"><![CDATA[<h2 id="Meta-是怎麼做的？">Meta 是怎麼做的？</h2><blockquote><ul><li>讀：和 Read aside 一樣。先從 Cache 讀，讀到就回，沒讀到就從 DB 讀然後寫回 Cache。</li><li>寫：先寫回 DB，接著清掉 Cache</li></ul><p>讀寫和 Read aside 一樣，但對 Cache 的操作採用版本控制及 Polaris 系統實作</p></blockquote><h2 id="版本控制">版本控制 :</h2><blockquote><p>所有對 Cache 寫入的請求字段要附加版本資訊</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 依收到請求的時間排序</span><br><span class="line">SET x=1 @VERSION=1 </span><br><span class="line">SET x=12345 @VERSION=3 (先到，所以先寫入) </span><br><span class="line">SET x=45678 @VERSION=2 (無效，因為剛剛已經先寫版本3了，所以版本2比較低視為無效） </span><br></pre></td></tr></table></figure><p>缺點：若在 v2 的請求到達之前 v3 的資料就先被清除，v2 就會被成功寫入</p></blockquote><h2 id="Polaris">Polaris :</h2><blockquote><p>是一個基於 Multi-Paxos 演算法實作的系統。</p><p><img src="/images/polaris.webp" alt=""></p><p>Polaris 是獨立的監控服務。<br>如上圖，當 DB 某資料更新成 x=4 後，會發請求告訴所有 Cache “x=4 @version 4” 的失效事件(invalidation event)，表示跟 “x=4 @version 4” 不同的快取已失效，而這時 Polaris 會和其他 Cache 一起收到同樣的請求。</p><p>接著，Polaris 會去查詢其他 Cache 以便確認他們是否已經更新完成。</p><p>假如其中一台 Cache 返回 “x=3 @version 3”， 則 Polaris 會將這台 Cache 標記為不一致，並將這次檢查重新排隊，以便待會再重新檢查一次。<br>有個特別的地方在於 Polaris 的不一致回報會有 1, 5, 10分鐘內的不同時間尺度，當發現某個 cache 持續 1 分鐘以上不一致後，Polaris 會將此報告歸類為 5 分鐘內的不一致。</p><p>以 Polaris 的角度來看，當收到不一致的回報時，可能會有不同的情況，例如：<br>Polaris 收到 “x=4 @version 4” 的失效事件，但是當它查詢 Cache A 時，A 的回覆是 “x” 不存在 。</p><ul><li>狀況1：x 的 v3 是不可視(invisible)，而 v4 是對 x 的最新寫入，所以 Cache A 為不一致。</li><li>狀況2：x 的 v5 是刪除 x，所以 Polaris 在 v4 還沒檢查完的情況下，Cache A 就已經同步了 v5， 但並不是不一致。</li></ul><p>由於兩種狀況互斥，必須查詢 DB 才能區分是狀況1還是狀況2，但是對 DB 的操作成本是非常高的，所以這時候 Polaris 的時間尺度設計就派上用場。<br>由於真正的緩存不一致和對同一鍵的競速寫操作很少見，對 Cache 重新多做幾次確認就能過濾掉並非真正不一致的情況，而可以彈性設定成例如當 5 分鐘內都還是有不一致的狀況時，才對 DB 做查詢。</p><p>根據官方使用 Polaris 監測的數據，有 99.99999999% 的緩存寫入在五分鐘內是一致的。而在五分鐘後，100 億次緩存寫入中只有不到 1 次會出現不一致，這個有點饒舌的數據也是因為前面提到的時間尺度設計。</p></blockquote><h2 id="小結">小結 :</h2><blockquote><p>Meta 的部落格講了很多架構原理，也因此更能感受到一個高可用性的系統是如何的複雜且高成本，以一般小公司來說可能簡單的 Read Aside 就永遠不會遇到不一致的狀況了，所以終歸是需要依照尖峰的 QPS 和系統能力來判斷是否需要更進一步的拓展，這也是工程師經驗的價值所在。</p></blockquote><h2 id="參考">參考 :</h2><ul><li><a href="https://engineering.fb.com/2022/06/08/core-data/cache-invalidation/">官方技術部落格 Cache made consistent</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 快取 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cache </tag>
            
            <tag> 系統架構 </tag>
            
            <tag> Consistency </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快取的一致性難題與架構模式 (中)</title>
      <link href="/Cache/CacheConsistencyCanal/"/>
      <url>/Cache/CacheConsistencyCanal/</url>
      
        <content type="html"><![CDATA[<h2 id="阿里巴巴的開源專案-canal">阿里巴巴的開源專案 canal :</h2><blockquote><ul><li>讀：和 Read Aside 一樣。先從 Cache 讀，讀到就回，沒讀到就從 DB 讀然後寫回 Cache。</li><li>寫：只寫回 DB，canal 會從 DB 的 binlog 複製到 Cache (canal 扮演 Slave 的角色去監聽 binlog)。</li></ul><p>補充 : binlog 是 MySQL 二進位制格式的日誌，只要資料庫有操作，就會寫入 binlog。</p></blockquote><h2 id="MySQL-主從複製">MySQL 主從複製 :</h2><blockquote><p>在探討 canal 如何運作之前，我們必須先了解 MySQL 是如何達到主從複製的 :</p><p><img src="/images/MySQLMasterSlave.jpeg" alt=""></p><ol><li>Slave 產生 I/O thread 向 Master 請求 binlog。</li><li>Master 會產生一個 log dump thread，負責傳 binlog 給 Slave 的 I/O thread，而在讀取和發送<br>給 Slave 的過程中會將 binlog 上鎖。</li><li>Slave I/O thread 將得到的 binlog 日志<strong>寫入</strong> Relay log(中繼日誌) 文件中。</li><li>Slave 產生 SQL thread 讀取 Relay log 文件中的日誌，並<strong>解析</strong>成具體操作，這樣就能保證主從操作一致，即達成資料一致。</li></ol><p>你可能已經發現了他實際上還是會存在不一致的時間，至於具體是多久，可能的影響因素很多，包括網路如何連接、有多少個從機、採用什麼樣的主從架構和同步方式等等…。</p><p>大部分人給出的答案都是在同個 lan 下是瞬時的，因為採用獨立的 thread 和 socket 連接，且 binlog 是二進制文件，但是具體的數據官方也沒有提供，可能需要自己測試，可以架好環境後用 SHOW SLAVE STATUS 看 seconds_behind_master 的值。</p></blockquote><h2 id="canal-工作原理">canal 工作原理 :</h2><blockquote><p>如同上面提到的，MySQL 主從複製是一個成熟且使用者眾多的架構，他的目的也是為了解決分散式架構造成的一致性問題，所以如果我們能讓一個服務偽裝成 Slave 加入這個架構，就能直接沿用這個可靠的架構。</p><p><img src="/images/canal.png" alt=""></p><p>如上圖，canal 模擬 MySQL Slave 的交互協議，讓自己偽裝成 MySQL Slave，並向 MySQL Master 發送 dump 協議，之後 MySQL Master 收到 dump 請求，開始推送 binlog 给 Slave (即 canal)，之後 canal 再解析 binlog，就能再去同步到快取或是做其他事情。</p></blockquote><h2 id="小結">小結 :</h2><blockquote><p>canal 其實是基於 MySQL 解決一致性的方法作延伸來達成快取架構，但也代表其綁定了 MySQL，如果你是使用其他關聯式資料庫就不適用，可能需要另外找解法。</p><p>在之後的文章裡，我們會探討 Meta 是如何設計快取架構的，由於不是基於單一資料庫的延伸，他的架構會更加的複雜，以達到 99.99999999% 的快取寫入一致性。</p></blockquote><h2 id="參考">參考 :</h2><ul><li><a href="https://github.com/alibaba/canal">canal 官方開源</a></li><li><a href="https://github.com/xingwenge/canal-php">canal-php(基於 canal)</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 快取 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cache </tag>
            
            <tag> 系統架構 </tag>
            
            <tag> Consistency </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快取的一致性難題與架構模式 (上)</title>
      <link href="/Cache/CacheConsistency/"/>
      <url>/Cache/CacheConsistency/</url>
      
        <content type="html"><![CDATA[<h2 id="快取是什麼">快取是什麼 :</h2><blockquote><p>我們都知道電腦的核心運算是由 CPU 負責的，而我們的主要的資料儲存單元是硬碟，由於要在硬碟裡面搜尋資料並帶回來是一件時間成本極高的事，所以就有了<strong>將找過的資料暫存起來</strong>的概念，如下圖 :</p><p><img src="/images/cacheIO.png" alt=""></p><p>CPU 會先在 CPU Cache 裡尋找資料，當發現沒有之後就會去 main memory(DRAM) 找，再沒有才會去硬碟找。<br>找到之後就會一路寫回來，這樣你下次要找同樣資料時就不用再跑這麼遠去硬碟找。</p><p>我們之後會探討的快取就是 main memory(DRAM) 與硬碟的這一塊。</p></blockquote><h2 id="為什麼要使用快取">為什麼要使用快取 :</h2><blockquote><ol><li>DB 很慢 : 因為 RDBMS 需要保證 <a href="https://zh.wikipedia.org/zh-tw/ACID">ACID</a>，所以必須等待整個流程跑完。</li><li>DB 很貴 : 由於 RDBMS 的資料儲存在硬碟，會需要更多次 IO，上面已說明過。</li><li>DB 很遠 : 當你的 DB 建在新加坡，對於台灣用戶來說網路距離增加，傳輸速度也慢。</li></ol></blockquote><h2 id="為什麼快取會有一致性難題">為什麼快取會有一致性難題 :</h2><blockquote><p>如果你是分散式系統，那就一定逃不過 <a href="https://zh.wikipedia.org/zh-tw/CAP%E5%AE%9A%E7%90%86">CAP 定理</a>，但如果我只在單一台電腦上同時裝 Cache(ex. Redis) 和 DB(ex. MySQL)，還會有一致性難題嗎？讓我們接著以實作方式來探討。</p></blockquote><h2 id="快取模式-Read-Aside">快取模式 - Read Aside :</h2><blockquote><p><img src="/images/cacheReadAside.png" alt=""></p><ul><li>讀：先從 Cache 讀，讀到就回，沒讀到就從 DB 讀然後寫回 Cache。</li><li>寫：先寫回 DB，接著清掉 Cache。</li></ul><p>大部分情況都會正常，因為架構很簡單所以是常見的做法。<br>缺點為極端情況下不符合一致性，因為先對 DB 做事再去同步 Cache，所以同步前的時間差會導致非一致性。</p><ul><li>問題一 : A 寫了新資料，但還沒同步到 Cache 前 B 就去讀 Cache 的資料，導致不一致。</li></ul><p><img src="/images/cacheReadAsideProblem1.png" alt=""></p><ul><li>問題二 : A 寫了新資料，但要去同步到 Cache 時出了狀況，導致 DB 和 Cache 不一致。</li></ul><p><img src="/images/cacheReadAsideProblem2.png" alt=""></p><ul><li>問題三 : A 讀資料時發現 Cache 沒資料，所以去 DB 讀，但在寫回 Cache 前 B 就已經更新此資料並清掉Cache 了，這時候 A 才將舊資料寫回 Cache，導致不一致。</li></ul><p><img src="/images/cacheReadAsideProblem3.png" alt=""></p></blockquote><h2 id="快取模式-Double-Delete">快取模式 - Double Delete :</h2><blockquote><p><img src="/images/cacheReadAside.png" alt=""></p><ul><li>讀：先從 Cache 讀，讀到就回，沒讀到就從 DB 讀然後寫回 Cache。</li><li>寫：先清掉 Cache 再寫回 DB，接著<strong>等一下</strong>(依需求調整，例如 0.5s) 再清掉 Cache。</li></ul><p>我們可以發現他和 Read Aside 只差在寫的部分，原理是先避免其他人讀到舊資料，之後寫入 DB，先等一下再清掉 Cache 的過程則是為了減少 Read Aside 的問題三發生機率，所以雖然一致的機率提高了，但終究是會在極端情況下不符合一致性。</p></blockquote><h2 id="快取模式-Read-through">快取模式 - Read through :</h2><blockquote><p><img src="/images/cacheReadThrough.png" alt=""></p><ul><li>讀：先從 Cache 讀，讀到就回，沒讀到就<strong>由 Cache 從 DB 讀</strong>。</li><li>寫：無所謂，通常結合 Write Through 或 Write Behind 使用。</li></ul><p>注意<strong>由 Cache 從 DB 讀</strong>的實現 Redis 並不支援，NCache 則是需要收費。<br>可以自己實作 Data Access Layer(DAL)，在 DAL 裡用內部 api 伺服器去決定讀 Cache 還是 DB，而對於應用程式來說並不需要知道到底打了誰或是有沒有緩存，他只要知道可以透過 DAL 快速得到資料就好。</p></blockquote><h2 id="快取模式-Write-through">快取模式 - Write through :</h2><blockquote><p><img src="/images/cacheReadThrough.png" alt=""></p><ul><li>讀：無所謂，通常結合 Read Through 使用。</li><li>寫：只更新 Cache，並<strong>由 Cache 去更新 DB</strong>。</li></ul><p>注意跟 Read through 一樣，<strong>由 Cache 去更新 DB</strong> 的實現 Redis 並不支援，NCache 則是需要收費。<br>所以一樣可以藉由實作 Data Access Layer(DAL)來實現。</p><p>也就是說，當你使用 Read through + Write through 來實作快取架構，相當於你都只對 DAL 操作，這樣的優點是可以解決 Read Aside 的問題，但也引發了新的問題 :</p><ol><li>速度慢，因為你同時要寫完 Cache 和 DB 才算完成。</li><li>如果你不是用 DAL 而是原生支援 DB 連線的 Cache 的話，如果在 Cache 未寫入 DB 前就斷電重啟的話，那筆尚未更新到 DB 的資料就會永久遺失。</li></ol></blockquote><h2 id="快取模式-Write-Ahead-Behind-Back">快取模式 - Write Ahead (Behind)(Back) :</h2><blockquote><p><img src="/images/cacheWriteAhead.png" alt=""></p><ul><li>讀：無所謂，通常結合 Read Through 使用。</li><li>寫：需實作 DAL，並<strong>由 DAL 去更新 Cache 和 DB</strong>。</li></ul><p>和 Write through 不一樣需實作 DAL，並且會使用 Message Queue 來管理請求，這樣就可以避免 Cache 永久遺失資料的問題，也可以進一步實現對資料庫的批次寫入以減少寫入次數(Write Back)，但這樣的架構不好實現，需要處理非常多的細節，除非你真的需要這樣的可靠性，不然直接實作 Read Aside 是最簡單的。</p></blockquote><h2 id="小結">小結 :</h2><blockquote><p>介紹了這麼多不同做法，我們應該可以深刻體會一致性的難題有多複雜，以及這些架構背後可能會需要付出的成本，所以在決定你要如何實現快取架構前，你應該先考慮 :</p><ol><li>你的情境為何？為什麼要使用快取？</li><li>你的快取機器要求會有多高？會不會需要分散式？</li><li>比較看重的是一致性還是可用性？</li><li>哪些動作的延遲是可以接受的？哪些不行？讀跟寫的需求那個比較重？</li><li>你的快取需要多高的一致性保證？例如 Meta 可以保證 99.99999999% 的快取寫入一致性。</li></ol><p>在之後的文章裡，我們會探討阿里巴巴和 Meta 是如何設計快取架構的，雖然絕大多數的公司都不需要實現如此高的一致性，但他們的架構還是值得了解。</p></blockquote><h2 id="參考">參考 :</h2><ul><li><a href="https://web.ntnu.edu.tw/~algo/AlgorithmDesign.html#11">I/O-efficient Algorithm</a></li><li><a href="https://hackmd.io/@drwQtdGASN2n-vt_4poKnw/H1U6NgK3Z">CPU Cache 原理探討</a></li><li><a href="https://www.cs.pu.edu.tw/~bcc/93course/ch18.pdf">計算機組織與結構</a></li><li><a href="https://medium.com/starbugs/consistency-between-cache-and-database-part-1-f64f4a76720">Consistency between Cache and Database, Part 1</a></li><li><a href="https://medium.com/starbugs/consistency-between-cache-and-database-part-2-e28fc7f8a7c3">Consistency between Cache and Database, Part 2</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10224938">資料緩存失效問題</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 快取 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cache </tag>
            
            <tag> 計算機組織 </tag>
            
            <tag> 系統架構 </tag>
            
            <tag> Message queue </tag>
            
            <tag> Consistency </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 49. Group Anagrams</title>
      <link href="/LeetCode/GroupAnagrams/"/>
      <url>/LeetCode/GroupAnagrams/</url>
      
        <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://leetcode.com/problems/group-anagrams/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給定一個字串陣列 strs，需要把每個字串依據 anagram 做分類放進不同的陣列後回傳。<br>相同 anagram 定義 : 若字串 s 的字元出現頻率與字串 t 相同，則他們為同一個 anagram。</p><p>例如輸入 strs=[“eat”,“tea”,“tan”,“ate”,“nat”,“bat”]，應回傳 [[“bat”],[“nat”,“tan”],[“ate”,“eat”,“tea”]]，不看順序。</p><ul><li>1 &lt;= strs.length &lt;= 10^4</li><li>0 &lt;= strs[i].length &lt;= 100</li><li>strs 裡的每個字串都只由小寫英文字組成</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>原本想到的作法是每個字串做一個<strong>字符出現次數表</strong>，但這樣的時間複雜度就會變成「字串總數 * (每個字串的最大長度 * 當下有的出現次數表(最大等於字串總數) * 當下有的出現次數表最大長度)，光看就不可行。</p><p>後來想說既然存出現次數陣列沒比較快，那就改成<strong>存排序後的不重複字串</strong>，也就是對每個字串做排序後去比較我們存過的不重複字串，時間複雜度會變成「字串總數 * 最大字串排序的時間複雜度」。而因為基本上排序演算法最快也要 O(MlogM)，所以當字串總數 N 且最大字串長度 M 時，時間複雜度會是 O(N * MlogM)。</p><p>最後是參考別人的答案 : 方法一之所以慢是因為你沒有辦法在 O(K) 的時間複雜度內找到他是否有符合已找過的 K 個 anagram 種類之一，而方法二雖然成功讓其降到 O(K)，卻因為需要做排序導致變成 O(MlogM)，所以最後這個方法三就是讓你不需排序也能達到 O(K) 甚至更快。</p><p>具體來說，我們可以發現題目確保每個字串都是小寫字母，也就是說他們本來就有順序的關係性在，由於 a 的 ASCII 值是 97，而 b 是 98，以此類推到 z，所以可以將每個小寫字母(a~z)減去 a 的值當作索引，剛好就會是索引從 0 開始排到 25 的陣列，你就可以用這個陣列當作有序的字符出現次數表，之後將這個陣列轉成字串當作陣列索引，你就能在 O(1) 的時間複雜度內找到他是否有符合已找過的 anagram 種類之一。</p><p>需要注意的陷阱是每個字母出現的次數有可能超過十位數，就代表如果你將陣列轉成字串的作法是直接把次數串在一起就會錯，例如下圖的第二個範例 :</p><p><img src="/images/GroupAnagramsExample1.jpg" alt=""></p><p>所以說我們在串聯時可以加上特殊標記來區分，例如 :</p><p><img src="/images/GroupAnagramsExample2.jpg" alt=""></p><p>這樣就不會搞混了。</p><ul><li>時間複雜度 O(N * M)，N 為字串總數，M 為最大字串長度</li><li>空間複雜度 O(N)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/app/LeetCode/Blind75/Array/GroupAnagrams.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/tests/Unit/LeetCode/Blind75/Array/GroupAnagramsTest.php">單元測試</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Array </tag>
            
            <tag> HashTable </tag>
            
            <tag> 演算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Blind75 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 242. Valid Anagram</title>
      <link href="/LeetCode/ValidAnagram/"/>
      <url>/LeetCode/ValidAnagram/</url>
      
        <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://leetcode.com/problems/valid-anagram/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給定兩個字串 s 和 t，你必須判斷 s 是不是 t 的 anagram，若是則回傳 true，不是則回傳 false。</p><p>s 必須符合以下兩個條件才能算是 t 的 anagram :</p><ol><li>s 和 t 字串長度相同</li><li>s 和 t 有相同的字元數且各字元出現次數相同</li></ol><p>例如輸入 s = “anagram”, t = “nagaram”，應回傳 true。<br>輸入 s = “rat”, t = “car”，則回傳 false</p><ul><li>1 &lt;= s.length, t.length &lt;= 5*10^4</li><li>s 和 t 都只由小寫英文字組成。</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>原本想到的作法是遍歷 s 並記錄 s 中各字母出現次數，之後再遍歷 t 並用紀錄的陣列去減，如果有新字母或出現次數變成負數的情況就代表兩者不相同，但這樣做會導致最差情況(s 是 t 的 anagram)必須遍歷兩次 s 長度。</p><p>後來發現其實根本不需要分開遍歷，因為你可以<strong>從記錄 s 變成紀錄兩者差距</strong>，也就是 s 有的就加，t 有的就減，這樣你就只需要遍歷找完的字母出現次數差異陣列，發現有字母出現次數不等於 0 的時候就代表失敗。雖然最差情況(s 是 t 的 anagram 且字母出現次數不重複)也是遍歷兩次 s 長度，但這只會發生在剛好 26 個字母的時候，所以絕大情況下這個做法都是實際效能更高的。</p><ul><li>時間複雜度 O(N)，如何證明檢查存在鍵與拿取存放的時間複雜度請 <a href="/PHPArray/">參考我的另一篇文章 - PHP Array</a></li><li>空間複雜度 O(N)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/app/LeetCode/Blind75/Array/ValidAnagram.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/tests/Unit/LeetCode/Blind75/Array/ValidAnagramTest.php">單元測試</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Array </tag>
            
            <tag> HashTable </tag>
            
            <tag> 演算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Blind75 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 217. Contains Duplicate</title>
      <link href="/LeetCode/ContainsDuplicate/"/>
      <url>/LeetCode/ContainsDuplicate/</url>
      
        <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://leetcode.com/problems/contains-duplicate/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給定一個整數陣列 nums，你必須判斷 nums 中是否有元素值是重複出現的，若有則回傳 true，沒有則回傳 false。</p><p>例如輸入 nums=[1, 2, 3, 1]，由於元素值 1 重複出現，所以回傳 true。<br>而若輸入 nums=[1, 2, 3, 4]，由於元素值都沒有重複出現，所以回傳 false。</p><ul><li>1 &lt;= nums.length &lt;= 10^5</li><li>-10^9 &lt;= nums[i] &lt;= 10^9</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>這題比 <a href="/2023/05/02/LeetCode/TwoSum/">TwoSum</a> 更簡單，因為我們不需要知道重複的元素分別在哪裡，只需要知道當檢查到重複元素值時就回傳 true 就好。</p><p>所以一樣可以花一點空間來換時間，也就是用另一個陣列來邊找邊記錄我們已找過的值，當發現 nums[i] 已經有找過時，就代表要回傳 true。</p><ul><li>時間複雜度 O(N)，如何證明檢查存在鍵與拿取存放的時間複雜度請 <a href="/PHPArray/">參考我的另一篇文章 - PHP Array</a></li><li>空間複雜度 O(N)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/app/LeetCode/Blind75/Array/ContainsDuplicate.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/tests/Unit/LeetCode/Blind75/Array/ContainsDuplicateTest.php">單元測試</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Array </tag>
            
            <tag> HashTable </tag>
            
            <tag> 演算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Blind75 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1. Two Sum</title>
      <link href="/LeetCode/TwoSum/"/>
      <url>/LeetCode/TwoSum/</url>
      
        <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://leetcode.com/problems/two-sum/">官網題目連結</a></p><blockquote><p>最經典的 LeetCode 第一題，求兩數之和！</p><p>根據題目敘述，會給定一個整數陣列 nums，還有一個整數 target，你必須找出 nums 中哪兩個元素相加會等於 target，用陣列回傳他們的索引。</p><p>例如輸入 nums=[2, 7, 11, 15], target=9，由於前兩個元素 2+7=9 剛好就是答案，所以回傳 [0 ,1]，題目特別說<strong>不看順序</strong>所以你要回傳 [1, 0] 也可以。</p><ul><li>2 &lt;= nums.length &lt;= 10^4</li><li>-10^9 &lt;= nums[i] &lt;= 10^9</li><li>-10^9 &lt;= target &lt;= 10^9</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>沒碰過演算法的人可能一開始都會想到用暴力解，也就是先用第 1 個去對剩下 N-1，再用第 2 個去對剩下 N-2 個，但這樣的做法會導致運算次數變成等差數列總和，也就是時間複雜度 O(N^2)。</p><p>我們可以花一點空間來換時間，也就是用另一個陣列來邊找邊記錄我們已找過的值，當發現 target - nums[i] 已經有找過時，就代表這是答案。</p><ul><li>時間複雜度 O(N)，如何證明檢查存在鍵與拿取存放的時間複雜度請 <a href="/PHPArray/">參考我的另一篇文章 - PHP Array</a></li><li>空間複雜度 O(N)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/app/LeetCode/Blind75/Array/TwoSum.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/LeetCodePHP/blob/main/tests/Unit/LeetCode/Blind75/Array/TwoSumTest.php">單元測試</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Array </tag>
            
            <tag> HashTable </tag>
            
            <tag> 演算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Blind75 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Linux 的 systemd 來保持你的服務吧 !</title>
      <link href="/SystemdToKeepAlive/"/>
      <url>/SystemdToKeepAlive/</url>
      
        <content type="html"><![CDATA[<h2 id="簡介">簡介 :</h2><blockquote><p>systemd 基於一個事件驅動的機制，它可以同時啟動並管理多個服務，並在服務失敗或系統崩潰時自動重啟服務。它還提供了各種管理命令和工具，用於管理系統日誌、網絡配置、作業系統時間等等…。</p></blockquote><h2 id="首先，移動到系統單位檔案的存放位置">首先，移動到系統單位檔案的存放位置 :</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/systemd/system   <span class="comment"># 我是用 ubuntu 22.04 版本，如果你路徑不一樣請自己找</span></span><br></pre></td></tr></table></figure><h2 id="建立系統單位檔案">建立系統單位檔案 :</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> &lt;your service name&gt;.service</span><br></pre></td></tr></table></figure><h2 id="打開你建立的檔案並寫入設定">打開你建立的檔案並寫入設定 :</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=&lt;write your description&gt;</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"><span class="comment"># 讓 systemd 知道編譯器和啟動檔案在哪，以及啟動方式，一般來說你怎麼啟動的就直接貼過來，不過他不吃你的 $PATH 所以要給完整路徑</span></span><br><span class="line">ExecStart=/usr/bin/python3 -u /home/ubuntu/projects/DiscordBot/main.py  </span><br><span class="line">WorkingDirectory=/home/ubuntu/projects/DiscordBot/</span><br><span class="line">User=ubuntu  <span class="comment"># 要記得確保有權限讀取和執行 WorkingDirectory 底下所有檔案</span></span><br><span class="line">Group=ubuntu  <span class="comment"># 要記得確保有權限讀取和執行 WorkingDirectory 底下所有檔案</span></span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><h2 id="開始執行">開始執行 :</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start &lt;your service name&gt;.service</span><br></pre></td></tr></table></figure><h2 id="查看服務狀態">查看服務狀態 :</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status &lt;your service name&gt;.service</span><br></pre></td></tr></table></figure><h2 id="當你有變更你的-service-內容時，需要先-reload">當你有變更你的 .service 內容時，需要先 reload :</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure><h2 id="其他語法">其他語法 :</h2><ul><li>設定為啟動系統時就自動啟動 :</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> &lt;your service name&gt;.service</span><br></pre></td></tr></table></figure><ul><li>停止服務 :</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop &lt;your service name&gt;.service</span><br></pre></td></tr></table></figure><ul><li>重啟服務 :</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart &lt;your service name&gt;.service</span><br></pre></td></tr></table></figure><ul><li>查看錯誤日誌 :</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -u &lt;your service name&gt;.service</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> systemd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Postman 實現 api 自動測試吧 !</title>
      <link href="/PostMan/PostmanTest/"/>
      <url>/PostMan/PostmanTest/</url>
      
        <content type="html"><![CDATA[<h2 id="Postman-工作區目錄架構">Postman 工作區目錄架構 :</h2><blockquote><p>Postman 的工作區目錄架構為 Collection、Folder、Request、Example，如下圖 :</p><p><img src="/images/postmanStructure.png" alt=""></p><p>注意只有 Folder 可以自己包自己。</p><p>我們可以寫測試的範圍有 Collection、Folder、Request，不包含 Example，原因為 Example 只是把一些參數取出來單獨設定而已，他要執行時會將這些參數覆寫到繼承的 Request 並執行，但終究還是歸附於 Request，所以也會執行 Request 寫好的測試。</p></blockquote><h2 id="自動測試的執行順序">自動測試的執行順序 :</h2><blockquote><p>在 Collection、Folder、Request 界面中我們都可找到和設定「Pre-request Script」以及「Tests」，顧名思義就是一個是先跑的腳本、另一個是最後才跑的腳本，我們假設範例為 Collection 包 Folder 包 Request，且都有設定「Pre-request Script」以及「Tests」，那麼當你按下 Send Request 後的執行順序就是 :</p><ol><li>Collection Pre-request Script</li><li>Folder Pre-request Script</li><li>Request Pre-request Script</li><li>Request 本身</li><li>Request Tests</li><li>Folder Tests</li><li>Collection Tests</li></ol><p>從這樣的順序也很明顯可以看出 :</p><ul><li>Pre-request Script 在打 api 前就執行了，可以做的事有檢查參數、預打其他 api 拿 token 等等…。</li><li>Tests 是在打 api 後執行的，可以做的事有檢查回傳狀態、檢查回傳內容等等…。</li></ul></blockquote><h2 id="如何撰寫測試">如何撰寫測試 :</h2><blockquote><p>Postman 的腳本撰寫語法是基於 JavaScript，並提供物件 pm 以供操作，至於詳細有哪些用法官網已經寫得很清楚了，參考 :</p><ul><li><a href="https://learning.postman.com/docs/writing-scripts/pre-request-scripts/">Writing pre-request scripts</a></li><li><a href="https://learning.postman.com/docs/writing-scripts/test-scripts/">Writing tests</a></li></ul></blockquote><h2 id="範例一，打-api-前檢查當前用的-Postman-環境變數">範例一，打 api 前檢查當前用的 Postman 環境變數 :</h2><blockquote><p>情境 : 因為有時候打不同台伺服器或本地時忘了切換環境變數，會導致我對應的 domain 值壞掉。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;檢查環境變數&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123; </span><br><span class="line">    pm.<span class="title function_">expect</span>(pm.<span class="property">environment</span>.<span class="title function_">get</span>(<span class="string">&quot;domain&quot;</span>)).<span class="property">to</span>.<span class="property">be</span>.<span class="title function_">oneOf</span>([</span><br><span class="line">        <span class="string">&quot;打卡系統正式機&quot;</span>,</span><br><span class="line">        <span class="string">&quot;打卡系統測試機&quot;</span></span><br><span class="line">    ]); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>像這個範例你就可以寫在 Collection 的 Pre-request Script，因為通常一個 Collection 就對應一個系統、服務，其底下的 Request 應該都是吃同一種環境變數。</p></blockquote><h2 id="範例二，檢查-api-response-的狀態">範例二，檢查 api response 的狀態 :</h2><blockquote><p>情境 : 我希望知道此次回傳是否成功(這範例其實蠻雞肋的啦，因為本來界面就會顯示了)。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;檢查回傳狀態&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    pm.<span class="property">response</span>.<span class="property">to</span>.<span class="property">have</span>.<span class="title function_">status</span>(<span class="number">200</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="範例三，檢查-api-request-的-JSON-Schema">範例三，檢查 api request 的 JSON Schema :</h2><blockquote><p>情境 : 有時候你邊寫邊打就忘了有些 request 參數忘了改，這時候就能檢查。<br>注意 : Postman 用的 jsonSchema 是最新版的，你需要注意自己使用的版本是否有落差，因為寫法會變。<br>以筆者撰寫這篇文章的時間點來說是 3.1 或以上。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定義期望的 JSON Schema</span></span><br><span class="line"><span class="keyword">let</span> schema = &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">    <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;orderId&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: [<span class="string">&quot;integer&quot;</span>, <span class="string">&quot;null&quot;</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;isVoid&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: [<span class="string">&quot;boolean&quot;</span>, <span class="string">&quot;null&quot;</span>],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 檢查</span></span><br><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;檢查請求 json 是否符合期望的 jsonSchema&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">     pm.<span class="property">request</span>.<span class="property">to</span>.<span class="property">have</span>.<span class="title function_">jsonSchema</span>(schema);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="範例四，檢查-api-response-的-JSON-Schema">範例四，檢查 api response 的 JSON Schema :</h2><blockquote><p>情境 : 我希望回傳的 key 都符合我的期望，例如期望是整數那就不能回傳字串。<br>用法跟上面幾乎一樣，只是你要改從 response 拿而已。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定義期望的 JSON Schema</span></span><br><span class="line"><span class="keyword">let</span> schema = &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">    <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;typeId&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: [<span class="string">&quot;integer&quot;</span>, <span class="string">&quot;null&quot;</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;statusId&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: [<span class="string">&quot;integer&quot;</span>, <span class="string">&quot;null&quot;</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;supplierCode&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: [<span class="string">&quot;integer&quot;</span>, <span class="string">&quot;null&quot;</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;customerName&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: [<span class="string">&quot;string&quot;</span>, <span class="string">&quot;null&quot;</span>],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 檢查</span></span><br><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;檢查回傳 json 是否符合期望的 jsonSchema&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">     pm.<span class="property">response</span>.<span class="property">to</span>.<span class="property">have</span>.<span class="title function_">jsonSchema</span>(schema);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>你可能會覺得定義 jsonSchema 很麻煩，沒錯！因為我也這樣覺得，所以在這邊提供方法 :</p><ol><li><p>一般來說都會有寫 swagger 給前端對接用，那你就直接拿這個用就好了，簡單粗暴，像 Laravel 框架可以使用 : php artisan l5-swagger:generate 的指令快速產出。</p></li><li><p>你的 request 或 response 在 Postman 上都有完整 JSON 了，所以你可以使用 <a href="https://jsonschema.net/app/schemas">JSON Schema – json 轉 jsonschema</a> 快速轉換，但最麻煩的就是 nullable 你要自己加。</p></li></ol><p><a href="/2023/04/29/ThirdParty/">參考我的另一篇文章 - 常用的第三方工具</a></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> Postman </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Postman </tag>
            
            <tag> 自動化測試 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的第三方工具</title>
      <link href="/ThirdParty/"/>
      <url>/ThirdParty/</url>
      
        <content type="html"><![CDATA[<h2 id="工作中用過的一些第三方工具：">工作中用過的一些第三方工具：</h2><ul><li><p><a href="https://regex101.com/">regex101 – 線上測試正規表達式工具</a></p></li><li><p><a href="https://crontab.guru/">crontab guru – 線上測試 corntab 語法工具</a></p></li><li><p><a href="https://sequencediagram.org/">sequencediagram – 畫時序圖工具</a></p></li><li><p><a href="https://app.diagrams.net/">Draw.io – 畫圖工具</a></p></li><li><p><a href="http://sqlfiddle.com/">SQL Fiddle – 線上資料庫工具</a></p></li><li><p><a href="https://dbdiagram.io/home">dbdiagram – 資料庫工具</a></p></li><li><p><a href="https://dbschema.com/">dbSchema – 資料庫工具</a></p></li><li><p><a href="https://jsoneditoronline.org/#left=local.ranopi&amp;right=local.vosuzi">json editor – JSON 比對工具</a></p></li><li><p><a href="https://jsonschema.net/app/schemas">JSON Schema – json 轉 jsonschema</a></p></li><li><p><a href="https://shancarter.github.io/mr-data-converter/">Mr. Data Converter – CSV 轉其他格式</a></p></li><li><p><a href="https://slack.com/intl/zh-tw">Slack – 團隊溝通</a></p></li><li><p><a href="https://www.invisionapp.com/">InVision – 前端畫面工具</a></p></li><li><p><a href="https://www.figma.com/">figma – UI 設計工具</a></p></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 第三方工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第三方工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>讓你的 git commit message 更容易閱讀</title>
      <link href="/git/GitCommitMessage/"/>
      <url>/git/GitCommitMessage/</url>
      
        <content type="html"><![CDATA[<h2 id="讓版控更加容易追蹤">讓版控更加容易追蹤 :</h2><blockquote><p>習慣上會將每個 commit 的內容盡量限縮在<strong>單一單元或一件事</strong>上，以讓你的 commit message 和異動處能夠簡潔的對應，對於自己或團隊成員在追蹤進度、回顧異動上都能提高效率。</p><p>在這之上能更快表達此次 commit 意義的做法，就是在 commit message 開頭加上<strong>前綴字</strong>，常見的有 :</p><ul><li>feat : 新增/修改功能 (feature)。</li><li>fix : 修補 bug (bug fix)。</li><li>docs : 文件 (documentation)。</li><li>style : 格式 (不影響程式碼運行的變動 white-space, formatting, missing semi colons, etc)。</li><li>refactor : 重構 (既不是新增功能，也不是修補 bug 的程式碼變動)。</li><li>perf : 改善效能 (A code change that improves performance)。</li><li>test : 增加測試 (when adding missing tests)。</li><li>chore : 建構程序或輔助工具的變動 (maintain)。</li><li>revert : 撤銷回覆先前的 commit 例如：revert: type(scope): subject (回覆版本：xxxx)。</li></ul><p>加上前綴字之後一看就能先猜到在做什麼，之後再閱讀你改動的訊息就能更快進入狀況。</p></blockquote><h2 id="參考">參考</h2><ul><li><a href="https://wadehuanglearning.blogspot.com/2019/05/commit-commit-commit-why-what-commit.html">Git Commit Message 這樣寫會更好，替專案引入規範與範例</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> style </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codility Lesson MissingInteger</title>
      <link href="/Codility/CodilityLessonMissingInteger/"/>
      <url>/Codility/CodilityLessonMissingInteger/</url>
      
        <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://app.codility.com/programmers/lessons/4-counting_elements/missing_integer/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給一個由 N 個整數組成的陣列 A。需找出 A 中沒有出現且大於 0 的最小正整數。<br>例如輸入 A=[1, 3, 6, 4, 1, 2]，答案應為 5。<br>A=[1, 2, 3]，答案應為 4。<br>A=[-1, -3]，答案應為 1。</p><ul><li>N 是範圍 [1~100000] 的整數。</li><li>陣列 A 裡的元素都是範圍 [−1000000~1000000] 的整數。</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>第一時間還是想到了記憶法，先遍歷 A 記錄走過的不重複合法值，之後再遍歷記錄到的合法值來找出第一個 合法總數+1 的範圍內沒有記錄到的合法值。</p><p>總覺得還有機會想出跟 <a href="/2023/04/25/Codility/CodilityLessonMaxCounters/">MaxCounters</a> 一樣將當前最小值與合法最小值分開存的方法，就不用分兩次遍歷，但目前仍未想到。</p><ul><li>時間複雜度 O(N)</li><li>空間複雜度 O(N)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/CountingElements/MissingInteger.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/CountingElements/MissingIntegerTest.php">單元測試</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Codility </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 演算法 </tag>
            
            <tag> Codility </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codility Lesson MaxCounters</title>
      <link href="/Codility/CodilityLessonMaxCounters/"/>
      <url>/Codility/CodilityLessonMaxCounters/</url>
      
        <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://app.codility.com/programmers/lessons/4-counting_elements/max_counters/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給一個由 N 個整數組成的陣列 A 以及一個整數 M，你必須照順序遍歷 A 並執行以下判斷，之後返回結果陣列 R (包含 M 個整數) :</p><ul><li>當遍歷到 A[K]=X，且 1 ≤ X ≤ N 時，結果陣列 R[K-1] 的值要加 1。</li><li>當遍歷到的 A[K]=N+1，則 R 中所有元素值都必須統一成當前 R 的最大元素值。</li></ul><p>例如輸入 A=[3, 4, 4, 6, 1, 4, 4]，M=5 :</p><ol><li>當 K=0，A[K]=3，R[3-1] 要加 1，R 就變成 [0, 0, 1, 0, 0]</li><li>當 K=1，A[K]=4，R[4-1] 要加 1，R 就變成 [0, 0, 1, 1, 0]</li><li>當 K=2，A[K]=4，R[4-1] 要加 1，R 就變成 [0, 0, 1, 2, 0]</li><li>當 K=3，A[K]=6，R[6-1] 等於 M+1，R 所有元素要等於當前最大元素 2，所以 R 就變成 [2, 2, 2, 2, 2]</li><li>當 K=4，A[K]=1，R[1-1] 要加 1，R 就變成 [3, 2, 2, 2, 2]</li><li>當 K=5，A[K]=4，R[4-1] 要加 1，R 就變成 [3, 2, 2, 3, 2]</li><li>當 K=6，A[K]=4，R[4-1] 要加 1，R 就變成 [3, 2, 2, 4, 2]，因為遍歷完了，所以 R 已是答案。</li></ol><p>其實題目沒有要你遍歷，只是講計數規則，但這題不遍歷不能解，我覺得這樣寫題目說明應該比較好懂，如果你有想到不遍歷的方法歡迎在下方留言討論。</p><ul><li>N 和 M 都是範圍 [1~100000] 的整數。</li><li>陣列 A 裡的元素都是範圍 [1~N+1] 的整數。</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>最棘手的部分就在於「當 A[K]=N+1，R 中所有元素值都必須統一成當前 R 的最大元素值」，因為如果你要將 R 所有數字都即時更新成最大值的話，你的時間複雜度就會變成 O(N*M)，而這顯然不是最好的答案。</p><p>那麼如果我不要即時統一，而是只紀錄這個觸發要統一的事實，並在之後的點替換成最大值呢 ?<br>感覺是可行的方向，但要如何實現需要思考一下，我們會發現當你觸發統一時，假設當前 R 最大元素是 3，代表之後如果遇到小於 3 的元素就是尚未統一過的元素，而如果之後又觸發統一，且當前 R 最大元素變成 5，那麼之後遇到小於 5 的元素就是尚未統一過的元素，我們並不需要擔心他到底有沒有統一成 3 過了，因為反正他都比 5 小，我們不需要記錄他的所有歷程。</p><p>具體來說我們除了需要紀錄 R 的最大元素值 max 之外，還需要知道要統一的目標數字是多少，所以會需要另一個變數 needToAdd 來處理，有點像雙指標的概念，max 永遠紀錄最大值，而當觸發統一時 needToAdd 會即時跟上 max。</p><p>最後，因為有可能有 M 中的元素完全沒被加過，你沒辦法幫他處理統一，所以你還需要遍歷一次 M，將 M 沒被統一的值做統一，因此所需的時間複雜度就是 N 和 M 個只遍歷一次，為 O(N+M)。</p><p>這題在 Codility 算 medium，感覺確實比起其他 Lesson 更有挑戰一點，不過以體感來說應該還是只有 LeetCode 的 easy 難度而已。</p><ul><li>時間複雜度 O(N+M)</li><li>空間複雜度 O(M)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/CountingElements/MaxCounters.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/CountingElements/MaxCountersTest.php">單元測試</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Codility </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 演算法 </tag>
            
            <tag> Codility </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codility Lesson PermCheck</title>
      <link href="/Codility/CodilityLessonPermCheck/"/>
      <url>/Codility/CodilityLessonPermCheck/</url>
      
        <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://app.codility.com/programmers/lessons/4-counting_elements/perm_check/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給一個包含 N 個元素的<strong>非空</strong>陣列 A。你必須檢查 A 中是否包含所有 1~N 的整數值且不重複(其實這有點廢話，因為當滿足包含所有 1~N 的整數時本來就不可能有重複)</p><p>例如輸入 A=[4, 1, 3, 2]，滿足所有 1~4 且不重複，所以回傳 1。<br>而如果輸入 A=[4, 1, 3]，不滿足所有 1~3 且不重複，所以回傳 0。</p><ul><li>N 是範圍 [1~100000] 的整數。</li><li>陣列 A 裡的所有元素都是範圍 [1~1000000000] 的整數</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>這邊容易疏忽的點應該是並不保證餵進來的陣列其值都不重複，所以你不能用等差數列來解，依然需要紀錄走了哪些合法值，所以空間複雜度只能 O(N)。</p><p>再來由於一樣要追求遍歷一次就做完，所以我們需要找到規律，能先檢查的就是當發生重複(也就是當前遍歷值是已記錄過得合法值)時可以直接回傳 0，也就表示如果成功遍歷完一次 A ，就能確保 A 是<strong>元素不重複</strong>的陣列，也就能確保當我們紀錄的<strong>不重複合法值陣列總數等同於其內部的最大元素值</strong>時，就代表符合需求。</p><p>因為有點饒舌所以用範例說明，當輸入 A=[4, 1, 3, 2] 時，我們遍歷一遍<strong>確保都不重複</strong>，並且會得到另一個不重複合法值陣列 B=[4, 1, 3, 2]，然後當 B 的元素總數 4 剛好等於他最大的元素 B[0]=4 時，就代表是正確的。</p><p>由於你邊遍歷就可以邊收集最大元素值了，所以總共只要遍歷一次就好。</p><ul><li>時間複雜度 O(N)</li><li>空間複雜度 O(N)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/CountingElements/PermCheck.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/CountingElements/PermCheckTest.php">單元測試</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Codility </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 演算法 </tag>
            
            <tag> Codility </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codility Lesson FrogRiverOne</title>
      <link href="/Codility/CodilityLessonFrogRiverOne/"/>
      <url>/Codility/CodilityLessonFrogRiverOne/</url>
      
        <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://app.codility.com/programmers/lessons/4-counting_elements/frog_river_one/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給一個鍵為 N，值為 K 的<strong>非空</strong>陣列 A。其中 N 表示秒數，K 表示位置，也就是第 N 秒時會有樹葉掉落到位置 K 上。</p><p>題目還會給一個整數 X 表示終點，你必須找出最少第幾秒時 1~X 的位置上都會有落葉。</p><p>例如輸入 A=[1, 3, 1, 4, 2, 3, <strong>5</strong>, 4]， X=5。<br>最少在第 6 秒時會有樹葉掉落到位置 5，且位置 1~5 都有樹葉，所以答案為 6。</p><p>如果 1~X 永遠不可能都有樹葉的話，你必須回傳 -1。</p><ul><li>N 是範圍 [1~100000] 的整數。</li><li>陣列 A 裡的所有元素都是範圍 [1~X] 的整數</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>這題不像 <a href="/2023/04/14/Codility/CodilityLessonPermMissingElem/">PermMissingElem</a> 一樣可以用等差數列去減，因為樹葉掉落的位置可能會出現重複的，所以始終是必須記錄走過的不重複合法位置有哪些，空間複雜度最低只能 O(N)。</p><p>而由於我們有紀錄走過的不重複合法位置，所以可以得知當你剛好找到第 X 個不重複合法值時，他的時間就會是答案，總共只需遍歷一次。</p><ul><li>時間複雜度 O(N)</li><li>空間複雜度 O(N)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/CountingElements/FrogRiverOne.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/CountingElements/FrogRiverOneTest.php">單元測試</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Codility </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 演算法 </tag>
            
            <tag> Codility </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Homebrew 懶人切換 php 版本</title>
      <link href="/%E7%94%A8brew%E6%87%B6%E4%BA%BA%E5%88%87%E6%8F%9Bphp%E7%89%88%E6%9C%AC/"/>
      <url>/%E7%94%A8brew%E6%87%B6%E4%BA%BA%E5%88%87%E6%8F%9Bphp%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<aside>💡 適用於 mac os 且使用 Homebrew 管理 php 環境</aside><hr><h2 id="核心為以下兩行">核心為以下兩行 :</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew <span class="built_in">unlink</span> php@7.3 </span><br><span class="line">brew <span class="built_in">link</span> -f php@8.1</span><br></pre></td></tr></table></figure><h2 id="每次都要記很煩所以寫了個簡單-script">每次都要記很煩所以寫了個簡單 script :</h2><p><a href="https://github.com/Koufuchi/php_version_switcher">GitHub - Koufuchi/php_version_switcher</a></p><h2 id="用命令行移動到-script-所在目錄，執行以下語法並指定版本即可切換：">用命令行移動到 script 所在目錄，執行以下語法並指定版本即可切換：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. ~/ps.sh 7.3  <span class="comment"># 檔名自己取，執行時後面餵版本參數，如果參數錯誤則會列出你本機安裝的所有版本</span></span><br></pre></td></tr></table></figure><h2 id="或是真的超懶，就在-zshrc-中加入">或是真的超懶，就在 ~/.zshrc 中加入 :</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$PATH</span>:/&lt;your script path&gt;/&quot;</span>  <span class="comment"># script 所在目錄</span></span><br></pre></td></tr></table></figure><h2 id="之後打開-terminal-後就直接輸入以下就好">之後打開 terminal 後就直接輸入以下就好 :</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps.sh 7.3 </span><br></pre></td></tr></table></figure><p>注意所有指令都會跑去你指定的目錄對，所以其實不太推薦這樣玩</p><hr>]]></content>
      
      
      <categories>
          
          <category> 自製工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Shell </tag>
            
            <tag> Homebrew </tag>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codility Lesson PermMissingElem</title>
      <link href="/Codility/CodilityLessonPermMissingElem/"/>
      <url>/Codility/CodilityLessonPermMissingElem/</url>
      
        <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://app.codility.com/programmers/lessons/3-time_complexity/perm_missing_elem/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給一個由 N 個不同整數組成的陣列 A。該陣列包含 [1~(N+1)] 範圍內的整數，這表示正好缺少一個 [1~(N+1)] 的元素，你必須找出他。<br>例如輸入 A=[2, 3, 1, 5] ，答案應為 4。</p><ul><li>N 是範圍 [1~100000] 的整數。</li><li>陣列 A 裡的元素都是不重複的。</li><li>陣列 A 裡的元素都是範圍 [1~(N+1)] 的整數</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>也許你一開始會想到排序後遍歷，但排序需要 O(Nlog N)，所以顯然應該有更好的解法。</p><p>再來也許會想到定義一個鍵為 1~(N+1) 的結果陣列，只要遍歷到就從結果陣列中刪除，那麼最後剩下的那個就是答案，這樣的時間複雜度似乎已達標，但是空間是否能用得更少呢?</p><p>觀察題目可以發現 1~(N+1) 其實就是等差為 1 的等差數列，那麼我們其實一開始就可以預期他們的總和是多少了，只要用預期總和去減 A 的所有元素就能求解。<br>這邊需要注意的是公式不要套錯，因為題目其實有少給你 1 個元素，所以正確的長度和高度應是 A 的元素數量再 +1。</p><p>像這樣用公式解就能降低空間複雜度到 O(1)。<br><s>雖然題目主旨是時間複雜度</s></p><ul><li>時間複雜度 O(N)</li><li>空間複雜度 O(1)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/TimeComplexity/PermMissingElem.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/TimeComplexity/PermMissingElemTest.php">單元測試</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Codility </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 演算法 </tag>
            
            <tag> Codility </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codility Lesson TapeEquilibrium</title>
      <link href="/Codility/CodilityLessonTapeEquilibrium/"/>
      <url>/Codility/CodilityLessonTapeEquilibrium/</url>
      
        <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://app.codility.com/programmers/lessons/3-time_complexity/tape_equilibrium/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給一個由 N 個不同整數組成的<strong>非空</strong>陣列 A。遍歷到 A 的任一非 0 索引 P 時，會將陣列分成 A[1], A[2],…, A[P−1] 以及 A[P]、A[P+1],…, A[N−1] 兩個部分，其<strong>差異</strong>指的就是這兩部分<strong>各自加總</strong>後相減的絕對值。</p><p>例如輸入 A=[3, 1, 2, 4, 3] 時，可能的 P 值就會是 1~4，且他們的差異會是:</p><ol><li>P = 1，差異 = |3 − 10| = 7   (3 vs 1+2+4+3)</li><li>P = 2，差異 = |4 − 9| = 5    (3+1 vs 2+4+3)</li><li>P = 3，差異 = |6 − 7| = 1</li><li>P = 4，差異 = |10 − 3| = 7</li></ol><p>你的方法必須能吃這個陣列，並返回其中最小的差異，以上述例子來看就是 1</p><ul><li>N 是範圍 [2~100000] 的整數。</li><li>陣列 A 裡的元素都是範圍 [-1000~1000] 的整數</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>這題敘述挺長的，有可能會一時不知道怎麼下手，但其實原則很簡單，就是一樣想辦法遍歷一次就做完。<br>我們會發現從 P 到 P+1 時，相當於右邊減去 A[P]，而左邊加上 A[P]，所以你能遍歷一次就找出所有差異值，<br>那麼只需要多一個變數來存最小差異值就好。</p><p>陷阱在於 [1000, -1000]，你如果沒處理好的話就會算出 0，但其實答案應該是 2000。</p><ul><li>時間複雜度 O(N)</li><li>空間複雜度 O(1)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/TimeComplexity/TapeEquilibrium.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/TimeComplexity/TapeEquilibriumTest.php">單元測試</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Codility </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 演算法 </tag>
            
            <tag> Codility </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codility Lesson FrogJmp</title>
      <link href="/Codility/CodilityLessonFrogJmp/"/>
      <url>/Codility/CodilityLessonFrogJmp/</url>
      
        <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://app.codility.com/programmers/lessons/3-time_complexity/frog_jmp/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給三個變數，起點是 X，終點是 Y，每次移動距離是 D，需求出最少需要幾次 D 才能剛好抵達或超過終點。<br><s>題外話，為甚麼官方是寫 FrogJmp 而不是 FrogJump 啊。</s><br>例如輸入 X=10, Y=85, D=30，答案應為 3。</p><ul><li>X, Y, D 都是範圍 [1~1000000000] 的整數。</li><li>X &lt;= Y。</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>既然題目都歸類在 TimeComplexity 裡了，感覺就是注重效能的題目。<br>實際上也沒錯，看起來就是想騙人去用迴圈去每次減 D，因為這樣在 D 為 1 的時候你的時間複雜度就會提高到 Y-X。<br>而其實你根本只需要用 (Y-X)/D 再無條件進位就能達到答案，時間複雜度 O(1)。<br><s>根本就是小學數學題。</s></p><p>以前在面試時有遇過類似題目，面試官是說希望知道你在看起來秒殺的題目下會不會忽略掉甚麼才是最佳解。</p><ul><li>時間複雜度 O(1)</li><li>空間複雜度 O(1)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/TimeComplexity/FrogJump.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/TimeComplexity/FrogJumpTest.php">單元測試</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Codility </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 演算法 </tag>
            
            <tag> Codility </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codility Lesson OddOccurrencesInArray</title>
      <link href="/Codility/CodilityLessonOddOccurrencesInArray/"/>
      <url>/Codility/CodilityLessonOddOccurrencesInArray/</url>
      
        <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://app.codility.com/programmers/lessons/2-arrays/odd_occurrences_in_array/">官網題目連結</a></p><blockquote><p>根據題目敘述，會給一個非空陣列 A，包含了 N 個整數，索引從 0 開始。N 為奇數，其中除了唯一一個元素之外，其他每個元素都可以與陣列中另一個有相同值的元素配對，目的就是找出這個無法配對的元素。<br>例如輸入 A=[9, 3, 9, 3, 9, 7, 9]，答案應為 7。</p><ul><li>N 為範圍 [1~1000000] 的奇數。</li><li>陣列 A 的每個元素都是 [1~1000000000] 範圍內的整數。</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>光看題目第一時間其實想到 LeetCode 的 <a href="https://leetcode.com/problems/valid-parentheses/">20. Valid Parentheses</a>，那時是用 stack 解的，不過這題並沒有那麼複雜，不需要考慮開關符號的問題。</p><p>再來會想到的是記憶法，用數字種類當索引，用出現次數當值。當初會這樣想是因為題目的範例暗示了同個數字是可以出現超過 2 次的，於是潛意識想要知道每種數字出現幾次，這樣的優點是可以在時間和複雜度 O(N) 的情況下獲得完整資訊。</p><p>寫到一半才想到，目的只是要回傳那個沒有重複的值啊，我多做那麼沒用的事情幹嘛!</p><p>於是目標會希望改成只對 A 遍歷 1 次，且減少空間的用量，這時候就會發現我並不需要紀錄每種數字出現幾次，反正出現重複的就刪掉就好，因此空間用量值只會需要一個回傳陣列。<br>由於會需要知道回傳陣列是否已包含當前遍歷到的值，你仍需要以數字種類當索引才能保持每次查找的時間複雜度是 O(N)。<br>可以複習一下我的另一篇文章 : <a href="/PHPArray/">PHP Array</a></p><p>時間和空間複雜度是一個<strong>估算</strong>用的參考，所以不管有沒有記憶數字出現幾次都是 O(N)，但身為工程師你應該會很清楚實際上到底程式執行的細節是什麼，以及當我的<strong>函式/方法已定義好要做 X，就不要浪費資源去多做用不到的 Y</strong>。</p><ul><li>時間複雜度 O(N)</li><li>空間複雜度 O(N) – 實際上最多存到 (N/2)+1，因為已保證只有一個元素不重複</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/Arrays/OddOccurrencesInArray.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/Arrays/OddOccurrencesInArrayTest.php">單元測試</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Codility </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 演算法 </tag>
            
            <tag> Codility </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codility Lesson CyclicRotation</title>
      <link href="/Codility/CodilityLessonCyclicRotation/"/>
      <url>/Codility/CodilityLessonCyclicRotation/</url>
      
        <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://app.codility.com/programmers/lessons/2-arrays/cyclic_rotation/">官網題目連結</a></p><blockquote><p>根據題目敘述，輸入整數陣列 A 和一個整數 K ，將<strong>每個</strong>陣列元素<strong>往右移</strong> K 次。<br>例如輸入 A=[3, 8, 9, 7, 6], K=3，答案應為 [9, 7, 6, 3, 8]。</p><ul><li>N 和 K 都是範圍 [0~100] 的整數。</li><li>陣列 A 的每個元素都是 [−1000~1000] 範圍內的整數。</li></ul><p>題目特別說專注在正確性而不是效能。</p></blockquote><h2 id="解法：">解法：</h2><blockquote><p>共做 K 次，每次將陣列的最後一個元素改放到最前面即可。</p><p>由於 php array 的特性，用 array_pop() 取出最後一個元素為時間複雜度 O(1)，<br>但使用 array_unshift() 將元素放到最前面時，需要時間複雜度 O(N) 來保持索引順序，其中 N 為陣列元素數量。<br>可以複習一下我的另一篇文章 : <a href="/PHPArray/">PHP Array</a></p><ul><li>時間複雜度 O(N * K)</li><li>空間複雜度 O(N) / O(N * K) – 我不確定重複的 array_unshift() 會不會用到相同的空間來搬移陣列，之後可以實驗</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/Arrays/CyclicRotation.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/Arrays/CyclicRotationTest.php">單元測試</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Codility </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 演算法 </tag>
            
            <tag> Codility </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codility Lesson Iterations BinaryGap</title>
      <link href="/Codility/CodilityLessonBinaryGap/"/>
      <url>/Codility/CodilityLessonBinaryGap/</url>
      
        <content type="html"><![CDATA[<h2 id="題目：">題目：</h2><p><a href="https://app.codility.com/programmers/lessons/1-iterations/binary_gap/">官網題目連結</a></p><blockquote><p>根據題目敘述，會需要將輸入的整數 N 轉成二進位，並找出任意<strong>夾在兩個 1 中間</strong>的最大 0 總數。<br>例如輸入 529，轉成二進位是 1<strong>0000</strong>10001，答案就是 4，而如果沒有任何 0 是夾在兩個 1 中間的，則會回傳 0。</p><ul><li>N 是範圍 [1~2147483647] 的整數。</li></ul></blockquote><h2 id="解法：">解法：</h2><blockquote><p>先把數字轉成字串再遍歷一次即可，這邊要注意的陷阱是容易疏忽最後一個 1 的判斷。<br>例如轉成二進位是 1001000 時，由於最後面並沒有結尾的 1 把三個 0 夾住，所以答案是 2 不是 3。<br>所以重點會在於何時將<strong>當前計算</strong>的最大值轉成<strong>合法</strong>的最大值。</p><ul><li>時間複雜度 O(N)</li><li>空間複雜度 O(1)</li></ul></blockquote><h2 id="PHP-程式碼：">PHP 程式碼：</h2><ul><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/app/Codility/Lessons/Iterations/BinaryGap.php">我的解答</a></li><li><a href="https://github.com/Koufuchi/codilityPHP/blob/main/tests/Unit/Codility/Lessons/Iterations/BinaryGapTest.php">單元測試</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Codility </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 演算法 </tag>
            
            <tag> Codility </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRU Cache</title>
      <link href="/Cache/LRUCache/"/>
      <url>/Cache/LRUCache/</url>
      
        <content type="html"><![CDATA[<h2 id="背景">背景</h2><blockquote><p>一般來說快取是將會常被取用的資料<strong>暫存</strong>起來，避免重複的 I/O 以加快速度，而你的空間是有限的，勢必會需要淘汰一些既有資料才能放新的，而<strong>快取檔案置換機制</strong>就是決定哪些資料會優先淘汰，以最大保持你的<strong>快取命中率</strong>。</p></blockquote><h2 id="LRU-Least-Recently-Used-Cache">LRU(Least Recently Used) Cache</h2><blockquote><p>最近最少使用算法，顧名思義就是會優先清除掉沒被使用的資料。</p></blockquote><h2 id="規則：">規則：</h2><ol><li>最先進入快取的 key 會最先被刪除。</li><li>若某一 key 被取用或更新值，則該 key 會視為新寫入，因為要將其被刪除的順序降到最低。</li><li><em><strong>(額外)</strong></em> 由於會使用快取就是為了提高速度，所以實作上必須要求放值和取值都必須達到時間複雜度O(1)</li></ol><h2 id="範例：">範例：</h2><blockquote><p>當你依序放入 a, b, c 三個資料時，他們的優先刪除順序就是 1, 2, 3，所以當空間不夠需要刪除資料時會先刪掉 a，因為他最先加入而且從來沒被取用過。</p><p>讓我們時光倒流回到刪除前，現在有 a, b, c 三個資料時，他們的優先刪除順序就是 1, 2, 3，而這時有人取用了 a，因為 a 被取用了， 他的刪除優先順序會從 1 降成 3，而 b, c 的刪除優先順序則會被提升，所以 a, b, c 他們的優先刪除順序就會變成 3, 1, 2，當空間不夠需要刪除資料時會先刪掉 b。</p></blockquote><h2 id="題目：">題目：</h2><p><a href="https://leetcode.com/problems/lru-cache/">LRU Cache - LeetCode</a></p><h2 id="PHP-實作思路">PHP 實作思路 :</h2><blockquote><p>首先需要思考要用什麼資料結構來存，根據前面提到的 LRU 的概念可以很自然的想到 php array，而必須注意的是 php array 跟一般學資料結構時定義的陣列不一樣，他是實作更高階的關聯陣列，簡單來說就是有序的 HashMap。<br><a href="/PHPArray/">參考我的另一篇文章 - PHP Array</a></p><p>既然已經想到了 php array，再來實作上會發現的關鍵點是你的操作一定會需要用到頭尾，而由於鍵值對都拿去存資料了，你沒辦法用鍵當作順序，那麼應該如何在 O(1) 的情況下取得頭尾呢？</p><p>如果你已經想到要用另外一個空間去儲存順序，那麼恭喜你這道題已經解完了，一般來說這道題最常用的解法就是用 HashMap ＋ 雙向鏈結串列，用 HashMap 存 key 並指向雙向鏈結串列的節點，並用節點屬性來保存值，所以能保證查找的時間複雜度是 O(1)，而由於雙向鏈結串列能在時間複雜度 O(1) 找到所在節點的上下兩個節點，所以你的增刪也是時間複雜度 O(1)</p><p>補充一下，如果你是用 php 的話，你還是有辦法只用一個 php array 就做完的，這是因為 php array 實際上是<strong>有序的 HashMap</strong>，他會多花空間來記錄順序，也有多花空間來記錄起終點，所以剛好可以滿足 LRU 需要的條件，這個方法就是 array_key_first() 或 array_key_last() 。<br><a href="https://wiki.php.net/rfc/array_key_first_last_index">參考官方說明</a>，已明確指出時間複雜度 O(1)，</p><p>如果還是有疑慮或好奇，可以參考 <a href="https://github.com/php/php-src/blob/PHP-7.3.10/ext/standard/array.c">php7.3.10 官方開源</a></p><p>這做法要考量的就是 php array 在有序這件事上到底花了多少成本，有興趣的話可以自己產生一些測試案例來實驗跟紀錄，不過就算比較慢你也沒得挑，因為目前還沒看到 php 能提供無序的方法給你選。</p><p>補充：java 的話可以採用 LinkedHashMap，這是基於 HashMap 的拓展，為有序 HashMap， 但尚未確認取得和插入頭尾的時間複雜度。<br><a href="https://www.jianshu.com/p/8f4f58b4b8ab">图解 LinkedHashMap 原理</a></p></blockquote><h2 id="PHP-實作程式碼">PHP 實作程式碼 :</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">App</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$capacity</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$lruArr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer $capacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="keyword">int</span> <span class="variable">$capacity</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$capacity</span> &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&#x27;input capacity must great than 0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 設定最大容量</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;capacity = <span class="variable">$capacity</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 設定資料存放處，最尾端的優先度最高</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;lruArr = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  取得值</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer $key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Integer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"><span class="variable">$key</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment"># 檢查是否已有鍵，若無則回傳 -1</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;lruArr[<span class="variable">$key</span>])) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找出目標值</span></span><br><span class="line">        <span class="variable">$targetValue</span> = <span class="variable language_">$this</span>-&gt;lruArr[<span class="variable">$key</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 將目標鍵值刪除再寫入，以將其優先度提至最高</span></span><br><span class="line">        <span class="keyword">unset</span>(<span class="variable language_">$this</span>-&gt;lruArr[<span class="variable">$key</span>]);</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;lruArr[<span class="variable">$key</span>] = <span class="variable">$targetValue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$targetValue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  寫入值</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer $key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer $value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> NULL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">put</span>(<span class="params"><span class="variable">$key</span>, <span class="variable">$value</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment"># 未有鍵</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;lruArr[<span class="variable">$key</span>])) &#123;</span><br><span class="line">            <span class="comment"># 容量已滿，刪除優先度最低的</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">count</span>(<span class="variable">$this</span>-&gt;lruArr) == <span class="variable language_">$this</span>-&gt;capacity) &#123;</span><br><span class="line">                <span class="keyword">unset</span>(<span class="variable language_">$this</span>-&gt;lruArr[<span class="title function_ invoke__">array_key_first</span>(<span class="variable">$this</span>-&gt;lruArr)]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment"># 已有鍵，刪除舊值</span></span><br><span class="line">            <span class="keyword">unset</span>(<span class="variable language_">$this</span>-&gt;lruArr[<span class="variable">$key</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 寫入新值</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;lruArr[<span class="variable">$key</span>] = <span class="variable">$value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  遍歷全部</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">all</span>(<span class="params"></span>): <span class="title">array</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;lruArr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 快取 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Array </tag>
            
            <tag> HashTable </tag>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP Array</title>
      <link href="/PHPArray/"/>
      <url>/PHPArray/</url>
      
        <content type="html"><![CDATA[<h2 id="先說結論：">先說結論：</h2><blockquote><p>PHP 的 array 其實是有序的 HashMap</p></blockquote><h2 id="以一般學習資料結構而言：">以一般學習資料結構而言：</h2><ul><li><p>陣列（Array）：使用一連串連續的記憶體空間來存資料。同一陣列只會存放同一種資料型態的值，並用索引來記錄順序。優點是查找時間複雜度為 O(1)，缺點是只要移動資料順序或陣列空間不夠用時（需創建另一串更大的連續記憶體來做搬移），時間複雜度會變成 O(N)。</p></li><li><p>哈希表（HashMap）：先定義好鍵值的型態，並且是<strong>無序</strong>的。當你放值時會用 hash function 算出雜湊值，以對應放值的記憶體位址。遇到碰撞時不同語言會用不同的方式解決，例如常見的拉鍊法。優點是查找和存放的時間複雜度都是 O(1)，缺點是效能會隨使用的 hash function 不同而有差異，且當哈希表容量不足時，會定義一個新的哈希表，並把舊的鍵值移過去，等於每個舊鍵都要重跑一次 hash function，成本大幅提高。</p></li></ul><h2 id="PHP-Array：">PHP Array：</h2><blockquote><p>在 PHP 裡基於 C 語言將兩者實作成關聯陣列，名稱還是叫 Array。可接受存放不同型態的鍵值對，且為有序的 HashMap</p></blockquote><p>補充：</p><blockquote><p>以 JAVA 而言，HashMap 會有預設大小(16)，如果存放內容超過最大容量的 75% 時，程式會自動建立一個更大的 HashMap(2倍)，並將舊的 HashMap 中所有鍵值搬移到新的 HashMap 裡（會重新對應hash值），導致時間複雜度變成O(N)。<br><a href="https://stackoverflow.com/questions/53003761/what-happens-to-the-index-of-the-values-in-a-hashmap-when-it-increases-its-size">參考 stackoverflow 討論</a></p><p>HashMap 在碰撞時會用鏈表存有撞到的值，查詢時會遍歷鍊表（鏈式解決碰撞法），當鍊表大於預設值(8)時會轉存成紅黑樹，以避免若無限碰撞時 HashMap 會變成鍊表。不用二元樹是因為二元樹在最糟情況下等同於鍊表，而小於 8 的情況下用紅黑樹則過於浪費資源。</p></blockquote><h2 id="PHP-Array-使用要點：">PHP Array 使用要點：</h2><ul><li><p>將值加入 array 用 <code>$arr['key'] = 'value'</code> 會比呼叫 array_push 更快。<br><a href="https://stackoverflow.com/questions/1739706/how-to-insert-an-item-at-the-beginning-of-an-array-in-php">參考 stackoverflow 討論</a></p></li><li><p>在 O(1) 的時間複雜度下獲取第一個或最後一個鍵，可以用 array_key_first() 或 array_key_last()。<br><a href="https://wiki.php.net/rfc/array_key_first_last_index">參考官方說明</a></p></li><li><p>計算 array 長度用 count(array) 是時間複雜度 O(1)。<br><a href="https://stackoverflow.com/questions/5835241/is-phps-count-function-o1-or-on-for-arrays">參考 stackoverflow 討論</a></p></li><li><p>大部分 array 相關的原生方法的時間複雜度 :<br><a href="https://stackoverflow.com/questions/2473989/list-of-big-o-for-php-functions?noredirect=1&amp;lq=1">參考 stackoverflow 討論</a></p></li><li><p>使用 count_chars() 的時間複雜度是 O(N)。<br><a href="https://www.php.net/manual/zh/function.count-chars.php">參考官方函式用法</a><br><a href="https://github.com/php/php-src/blob/master/ext/standard/string.c">參考官方字串相關的原始碼</a></p></li><li><p>使用 str_split() 的時間複雜度是 O(N)，與其原理有關，他主要是遍歷字串中每個字符並存到回傳陣列。<br><a href="https://github.com/php/php-src/blob/master/ext/standard/string.c">參考官方字串相關的原始碼</a></p></li></ul><h2 id="參考：">參考：</h2><ul><li><p><a href="https://github.com/php/php-src/blob/PHP-7.3.10/ext/standard/array.c">PHP 7.3.10 官方開源</a></p></li><li><p><a href="https://medium.com/@rtheunissen/efficient-data-structures-for-php-7-9dda7af674cd">Efficient data structures for PHP 7</a></p></li><li><p><a href="https://www.npopov.com/2014/12/22/PHPs-new-hashtable-implementation.html">PHP5 到 PHP7 Array 底層實現的改變</a></p></li><li><p><a href="https://gywbd.github.io/posts/2014/12/php7-new-hashtable-implementation.html">PHP5 到 PHP7 Array 底層實現的改變 - 翻譯版</a></p></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Array </tag>
            
            <tag> HashTable </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
